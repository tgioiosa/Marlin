diff --git a/.github/ISSUE_TEMPLATE/bug_report.yml b/.github/ISSUE_TEMPLATE/bug_report.yml
deleted file mode 100644
index efc5972325..0000000000
--- a/.github/ISSUE_TEMPLATE/bug_report.yml
+++ /dev/null
@@ -1,178 +0,0 @@
-name: ðŸª² Report a bug
-description: Create a bug report to help improve Marlin Firmware
-title: "[BUG] (bug summary)"
-body:
-  - type: markdown
-    attributes:
-      value: >
-        Do you want to ask a question? Are you looking for support? Please use one of the [support links](https://github.com/MarlinFirmware/Marlin/issues/new/choose).
-
-  - type: markdown
-    attributes:
-      value: |
-        **Thank you for reporting a bug in Marlin Firmware!**
-
-        ## Before Reporting a Bug
-
-        - Read and understand Marlin's [Code of Conduct](https://github.com/MarlinFirmware/Marlin/blob/bugfix-2.1.x/.github/code_of_conduct.md). You are expected to comply with it, including treating everyone with respect.
-
-        - Test with the [`bugfix-2.1.x` branch](https://github.com/MarlinFirmware/Marlin/archive/bugfix-2.1.x.zip) to see whether the issue still exists.
-
-        ## Instructions
-
-        Please follow the instructions below. Failure to do so may result in your issue being closed. See [Contributing to Marlin](https://github.com/MarlinFirmware/Marlin/blob/bugfix-2.1.x/.github/contributing.md) for additional guidelines.
-
-        1. Provide a good title starting with [BUG].
-        2. Fill out all sections of this bug report form.
-        3. Always attach configuration files so we can build and test your setup.
-
-  - type: dropdown
-    attributes:
-      label: Did you test the latest `bugfix-2.1.x` code?
-      description: >-
-        Always try the latest code to make sure the issue you are reporting is not already fixed. To download
-        the latest code just [click this link](https://github.com/MarlinFirmware/Marlin/archive/bugfix-2.1.x.zip).
-      options:
-        - Yes, and the problem still exists.
-        - No, but I will test it now!
-    validations:
-      required: true
-
-  - type: markdown
-    attributes:
-      value: |
-        # Bug Details
-
-  - type: textarea
-    attributes:
-      label: Bug Description
-      description: >-
-        Describe the bug in this section. Tell us what you were trying to do and what
-        happened that you did not expect. Provide a clear and concise description of the
-        problem and include as many details as possible.
-
-        When pasting formatted text don't forget to put ` ``` ` (on its own line) before and after to make it readable.
-      placeholder: |
-        Marlin doesn't work.
-    validations:
-      required: true
-
-  - type: input
-    attributes:
-      label: Bug Timeline
-      description: Is this a new bug or an old issue? When did it first start?
-
-  - type: textarea
-    attributes:
-      label: Expected behavior
-      description: >-
-        What did you expect to happen?
-      placeholder: I expected it to move left.
-
-  - type: textarea
-    attributes:
-      label: Actual behavior
-      description: What actually happened instead?
-      placeholder: It moved right instead of left.
-
-  - type: textarea
-    attributes:
-      label: Steps to Reproduce
-      description: >-
-        Please describe the steps needed to reproduce the issue.
-      placeholder: |
-        1. [First Step] ...
-        2. [Second Step] ...
-        3. [and so on] ...
-
-  - type: markdown
-    attributes:
-      value: |
-        # Your Setup
-
-  - type: input
-    attributes:
-      label: Version of Marlin Firmware
-      description: "See the About Menu on the LCD or the output of `M115`. NOTE: For older releases we only patch critical bugs."
-    validations:
-      required: true
-
-  - type: input
-    attributes:
-      label: Printer model
-      description: Creality Ender 3, Prusa mini, or Kossel Delta?
-
-  - type: input
-    attributes:
-      label: Electronics
-      description: Stock electronics, upgrade board, or something else?
-
-  - type: input
-    attributes:
-      label: Add-ons
-      description: Please list any hardware add-ons that could be involved.
-
-  - type: dropdown
-    attributes:
-      label: Bed Leveling
-      description: What kind of bed leveling compensation are you using?
-      options:
-        - UBL Bilinear mesh
-        - ABL Bilinear mesh
-        - ABL Linear grid
-        - ABL 3-point
-        - MBL Manual Bed Leveling
-        - No Bed Leveling
-
-  - type: dropdown
-    attributes:
-      label: Your Slicer
-      description: Do you use Slic3r, Prusa Slicer, Simplify3D, IdeaMaker...?
-      options:
-        - Slic3r
-        - Simplify3D
-        - Prusa Slicer
-        - IdeaMaker
-        - Cura
-        - Other (explain below)
-
-  - type: dropdown
-    attributes:
-      label: Host Software
-      description: Do you use OctoPrint, Repetier Host, Pronterface...?
-      options:
-        - SD Card (headless)
-        - Repetier Host
-        - OctoPrint
-        - Pronterface
-        - Cura
-        - Same as my slicer
-        - Other (explain below)
-
-  - type: markdown
-    attributes:
-      value: |
-        # Attachments
-
-  - type: checkboxes
-    attributes:
-      label: Don't forget to include
-      options:
-        - label: A ZIP file containing your `Configuration.h` and `Configuration_adv.h`.
-          required: true
-
-  - type: markdown
-    attributes:
-      value: |
-        ### Optional items to include:
-        - 'Log output from the host. (`M111 S247` for maximum logging.)'
-        - Images or videos demonstrating the problem, if it helps to make it clear.
-        - A G-Code file that exposes the problem, if not affecting _all_ G-code.
-
-  - type: textarea
-    attributes:
-      label: Additional information & file uploads
-      description: >-
-        If you've made any other modifications to the firmware, please describe them in detail.
-
-        When pasting formatted text don't forget to put ` ``` ` (on its own line) before and after to make it readable.
diff --git a/.github/ISSUE_TEMPLATE/config.yml b/.github/ISSUE_TEMPLATE/config.yml
deleted file mode 100644
index 1fe68966fb..0000000000
--- a/.github/ISSUE_TEMPLATE/config.yml
+++ /dev/null
@@ -1,20 +0,0 @@
-blank_issues_enabled: false
-contact_links:
-  - name: ðŸ“– Marlin Documentation
-    url: https://marlinfw.org/
-    about: Lots of documentation on installing and using Marlin.
-  - name: ðŸ‘¤ MarlinFirmware Facebook group
-    url: https://www.facebook.com/groups/1049718498464482
-    about: Please ask and answer questions here.
-  - name: ðŸ•¹ Marlin on Discord
-    url: https://discord.gg/n5NJ59y
-    about: Join the Discord server for support and discussion.
-  - name: ðŸ”— Marlin Discussion Forum
-    url: https://reprap.org/forum/list.php?415
-    about: A searchable web forum hosted by RepRap dot org.
-  - name: ðŸ“º Marlin Videos on YouTube
-    url: https://www.youtube.com/results?search_query=marlin+firmware
-    about: Tutorials and more from Marlin users all around the world. Great for new users!
-  - name: ðŸ’¸ Want to donate?
-    url: https://www.thinkyhead.com/donate-to-marlin
-    about: Please take a look at the various options to support Marlin Firmware's development financially!
diff --git a/.github/ISSUE_TEMPLATE/feature_request.yml b/.github/ISSUE_TEMPLATE/feature_request.yml
deleted file mode 100644
index b64383cd48..0000000000
--- a/.github/ISSUE_TEMPLATE/feature_request.yml
+++ /dev/null
@@ -1,44 +0,0 @@
-name: âœ¨ Request a feature
-description: Request a new Marlin Firmware feature
-title: "[FR] (feature summary)"
-labels: 'T: Feature Request'
-body:
-  - type: markdown
-    attributes:
-      value: >
-        Do you want to ask a question? Are you looking for support? Please use one of the [support links](https://github.com/MarlinFirmware/Marlin/issues/new/choose).
-
-  - type: markdown
-    attributes:
-      value: >
-        **Thank you for requesting a new Marlin Firmware feature!**
-
-        ## Before Requesting a Feature
-
-        - Read and understand Marlin's [Code of Conduct](https://github.com/MarlinFirmware/Marlin/blob/master/.github/code_of_conduct.md). You are expected to comply with it, including treating everyone with respect.
-
-        - Check the latest [`bugfix-2.1.x` branch](https://github.com/MarlinFirmware/Marlin/archive/bugfix-2.1.x.zip) to see if the feature already exists.
-
-        - Before you proceed with your request, please consider if it is necessary to make it into a firmware feature, or if it may be better suited for a slicer or host feature.
-
-  - type: textarea
-    attributes:
-      label: Is your feature request related to a problem? Please describe.
-      description: A clear description of the problem (e.g., "I need X but Marlin can't do it [...]").
-
-  - type: textarea
-    attributes:
-      label: Are you looking for hardware support?
-      description: Tell us the printer, board, or peripheral that needs support.
-
-  - type: textarea
-    attributes:
-      label: Describe the feature you want
-      description: A clear description of the feature and how you think it should work.
-    validations:
-      required: true
-
-  - type: textarea
-    attributes:
-      label: Additional context
-      description: Add any other context or screenshots about the feature request here.
diff --git a/.github/lock.yml b/.github/lock.yml
deleted file mode 100644
index c5ceff66b0..0000000000
--- a/.github/lock.yml
+++ /dev/null
@@ -1,40 +0,0 @@
-#
-# Configuration for Lock Threads - https://github.com/dessant/lock-threads-app
-#
-
-# Number of days of inactivity before a closed issue or pull request is locked
-daysUntilLock: 60
-
-# Skip issues and pull requests created before a given timestamp. Timestamp must
-# follow ISO 8601 (`YYYY-MM-DD`). Set to `false` to disable
-skipCreatedBefore: false
-
-# Issues and pull requests with these labels will be ignored. Set to `[]` to disable
-exemptLabels: [ 'no-locking' ]
-
-# Label to add before locking, such as `outdated`. Set to `false` to disable
-lockLabel: false
-
-# Comment to post before locking. Set to `false` to disable
-lockComment: >
-  This thread has been automatically locked since there has not been
-  any recent activity after it was closed. Please open a new issue for
-  related bugs.
-
-# Assign `resolved` as the reason for locking. Set to `false` to disable
-setLockReason: true
-
-# Limit to only `issues` or `pulls`
-# only: issues
-
-# Optionally, specify configuration settings just for `issues` or `pulls`
-# issues:
-#   exemptLabels:
-#     - help-wanted
-#   lockLabel: outdated
-
-# pulls:
-#   daysUntilLock: 30
-
-# Repository to extend settings from
-# _extends: repo
diff --git a/.github/workflows/bump-date.yml b/.github/workflows/bump-date.yml
deleted file mode 100644
index 51b58ad493..0000000000
--- a/.github/workflows/bump-date.yml
+++ /dev/null
@@ -1,59 +0,0 @@
-#
-# bump-date.yml
-# Bump the distribution date once per day
-#
-
-name: Bump Distribution Date
-
-on:
-  schedule:
-    - cron: '0 */6 * * *'
-
-jobs:
-  bump_date:
-    name: Bump Distribution Date
-    if: github.repository == 'MarlinFirmware/Marlin'
-
-    runs-on: ubuntu-latest
-
-    steps:
-
-    - name: Check out bugfix-2.1.x
-      uses: actions/checkout@v2
-      with:
-        ref: bugfix-2.1.x
-
-    - name: Bump Date (bugfix-2.0.x)
-      run: |
-        # Inline Bump Script
-        if [[ ! "$( git log -1 --pretty=%B )" =~ ^\[cron\] ]]; then
-          DIST=$( date +"%Y-%m-%d" )
-          eval "sed -E -i 's/(#define +STRING_DISTRIBUTION_DATE) .*$/\1 \"$DIST\"/g' Marlin/src/inc/Version.h" && \
-          eval "sed -E -i 's/(#define +STRING_DISTRIBUTION_DATE) .*$/\1 \"$DIST\"/g' Marlin/Version.h" && \
-          git config user.name "${GITHUB_ACTOR}" && \
-          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com" && \
-          git add . && \
-          git commit -m "[cron] Bump distribution date ($DIST)" && \
-          git push
-        fi
-        exit 0
-
-    - name: Check out bugfix-2.1.x
-      uses: actions/checkout@v2
-      with:
-        ref: bugfix-2.1.x
-
-    - name: Bump Date (bugfix-2.1.x)
-      run: |
-        # Inline Bump Script
-        if [[ ! "$( git log -1 --pretty=%B )" =~ ^\[cron\] ]]; then
-          DIST=$( date +"%Y-%m-%d" )
-          eval "sed -E -i 's/(#define +STRING_DISTRIBUTION_DATE) .*$/\1 \"$DIST\"/g' Marlin/src/inc/Version.h" && \
-          eval "sed -E -i 's/(#define +STRING_DISTRIBUTION_DATE) .*$/\1 \"$DIST\"/g' Marlin/Version.h" && \
-          git config user.name "${GITHUB_ACTOR}" && \
-          git config user.email "${GITHUB_ACTOR}@users.noreply.github.com" && \
-          git add . && \
-          git commit -m "[cron] Bump distribution date ($DIST)" && \
-          git push
-        fi
-        exit 0
diff --git a/.github/workflows/check-pr.yml b/.github/workflows/check-pr.yml
deleted file mode 100644
index abb0d44706..0000000000
--- a/.github/workflows/check-pr.yml
+++ /dev/null
@@ -1,34 +0,0 @@
-#
-# check-pr.yml
-# Close PRs directed at release branches
-#
-
-name: PR Bad Target
-
-on:
-  pull_request_target:
-    types: [opened]
-    branches:
-    - 1.0.x
-    - 1.1.x
-    - 2.0.x
-    - 2.1.x
-
-jobs:
-  bad_target:
-    name: PR Bad Target
-    if: github.repository == 'MarlinFirmware/Marlin'
-
-    runs-on: ubuntu-latest
-
-    steps:
-    - uses: superbrothers/close-pull-request@v3
-      with:
-        comment: >
-          Thanks for your contribution! Unfortunately we can't accept PRs directed at release branches. We make patches to the bugfix branches and only later do we push them out as releases.
-
-          Please redo this PR starting with the `bugfix-2.1.x` branch and be careful to target `bugfix-2.1.x` when resubmitting the PR. Patches may also target `bugfix-2.0.x` if they are specifically for 2.0.9.x.
-
-          It may help to set your fork's default branch to `bugfix-2.1.x`.
-
-          See [this page](https://marlinfw.org/docs/development/getting_started_pull_requests.html) for full instructions.
diff --git a/.github/workflows/clean-closed.yml b/.github/workflows/clean-closed.yml
deleted file mode 100644
index befec4498f..0000000000
--- a/.github/workflows/clean-closed.yml
+++ /dev/null
@@ -1,39 +0,0 @@
-#
-# clean-closed.yml
-# Remove obsolete labels when an Issue or PR is closed
-#
-
-name: Clean Closed
-
-on:
-  pull_request:
-    types: [closed]
-  issues:
-    types: [closed]
-
-jobs:
-  remove_label:
-    runs-on: ubuntu-latest
-
-    strategy:
-      matrix:
-        label:
-          - "S: Don't Merge"
-          - "S: Hold for 2.1"
-          - "S: Please Merge"
-          - "S: Please Test"
-          - "help wanted"
-          - "Needs: Discussion"
-          - "Needs: Documentation"
-          - "Needs: More Data"
-          - "Needs: Patch"
-          - "Needs: Testing"
-          - "Needs: Work"
-
-    steps:
-      - uses: actions/checkout@v2
-      - name: Remove Labels
-        uses: actions-ecosystem/action-remove-labels@v1
-        with:
-          github_token: ${{ github.token }}
-          labels: ${{ matrix.label }}
diff --git a/.github/workflows/close-stale.yml b/.github/workflows/close-stale.yml
deleted file mode 100644
index 88fea1996d..0000000000
--- a/.github/workflows/close-stale.yml
+++ /dev/null
@@ -1,28 +0,0 @@
-#
-# close-stale.yml
-# Close open issues after a period of inactivity
-#
-
-name: Close Stale Issues
-
-on:
-  schedule:
-  - cron: "22 1 * * *"
-
-jobs:
-  stale:
-    name: Close Stale Issues
-    if: github.repository == 'MarlinFirmware/Marlin'
-
-    runs-on: ubuntu-latest
-
-    steps:
-    - uses: actions/stale@v3
-      with:
-        repo-token: ${{ secrets.GITHUB_TOKEN }}
-        stale-issue-message: 'This issue has had no activity in the last 60 days. Please add a reply if you want to keep this issue active, otherwise it will be automatically closed within 10 days.'
-        days-before-stale: 60
-        days-before-close: 10
-        stale-issue-label: 'stale-closing-soon'
-        exempt-all-assignees: true
-        exempt-issue-labels: 'Bug: Confirmed !,T: Feature Request,Needs: More Data,Needs: Discussion,Needs: Documentation,Needs: Patch,Needs: Work,Needs: Testing,help wanted,no-locking'
diff --git a/.github/workflows/lock-closed.yml b/.github/workflows/lock-closed.yml
deleted file mode 100644
index 8cdcd7a836..0000000000
--- a/.github/workflows/lock-closed.yml
+++ /dev/null
@@ -1,32 +0,0 @@
-#
-# lock-closed.yml
-# Lock closed issues after a period of inactivity
-#
-
-name: Lock Closed Issues
-
-on:
-  schedule:
-    - cron: '0 1/13 * * *'
-
-jobs:
-  lock:
-    name: Lock Closed Issues
-    if: github.repository == 'MarlinFirmware/Marlin'
-
-    runs-on: ubuntu-latest
-
-    steps:
-    - uses: dessant/lock-threads@v2
-      with:
-        github-token: ${{ github.token }}
-        process-only: 'issues'
-        issue-lock-inactive-days: '60'
-        issue-exclude-created-before: ''
-        issue-exclude-labels: 'no-locking'
-        issue-lock-labels: ''
-        issue-lock-comment: >
-          This issue has been automatically locked since there
-          has not been any recent activity after it was closed.
-          Please open a new issue for related bugs.
-        issue-lock-reason: ''
diff --git a/.github/workflows/test-builds.yml b/.github/workflows/test-builds.yml
deleted file mode 100644
index 9debb82bc9..0000000000
--- a/.github/workflows/test-builds.yml
+++ /dev/null
@@ -1,153 +0,0 @@
-#
-# test-builds.yml
-# Do test builds to catch compile errors
-#
-
-name: CI
-
-on:
-  pull_request:
-    branches:
-    - bugfix-2.1.x
-    paths-ignore:
-    - config/**
-    - data/**
-    - docs/**
-    - '**/*.md'
-  push:
-    branches:
-    - bugfix-2.1.x
-    paths-ignore:
-    - config/**
-    - data/**
-    - docs/**
-    - '**/*.md'
-
-jobs:
-  test_builds:
-    name: Run All Tests
-    if: github.repository == 'MarlinFirmware/Marlin'
-
-    runs-on: ubuntu-latest
-
-    strategy:
-      matrix:
-        test-platform:
-        # Base Environments
-
-        - DUE
-        - DUE_archim
-        - esp32
-        - linux_native
-        - mega2560
-        - at90usb1286_dfu
-        - teensy31
-        - teensy35
-        - teensy41
-        - SAMD21_minitronics20
-        - SAMD51_grandcentral_m4
-        - PANDA_PI_V29
-
-        # Extended AVR Environments
-
-        - FYSETC_F6
-        - mega1280
-        - rambo
-        - sanguino1284p
-        - sanguino644p
-
-        # STM32F1 (Maple) Environments
-
-        #- STM32F103RC_btt_maple
-        - STM32F103RC_btt_USB_maple
-        - STM32F103RC_fysetc_maple
-        - STM32F103RC_meeb_maple
-        - jgaurora_a5s_a1_maple
-        - STM32F103VE_longer_maple
-        #- mks_robin_maple
-        - mks_robin_lite_maple
-        - mks_robin_pro_maple
-        #- mks_robin_nano_v1v2_maple
-        #- STM32F103RE_creality_maple
-        - STM32F103VE_ZM3E4V2_USB_maple
-
-        # STM32 (ST) Environments
-
-        - STM32F103RC_btt
-        #- STM32F103RC_btt_USB
-        - STM32F103RE_btt
-        - STM32F103RE_btt_USB
-        - STM32F103RE_creality
-        - STM32F401RC_creality
-        - STM32F103VE_longer
-        - STM32F407VE_black
-        - BIGTREE_BTT002
-        - BIGTREE_SKR_PRO
-        - BIGTREE_GTR_V1_0
-        - mks_robin
-        - ARMED
-        - FYSETC_S6
-        - STM32F070CB_malyan
-        - STM32F070RB_malyan
-        - malyan_M300
-        - FLYF407ZG
-        - rumba32
-        - LERDGEX
-        - LERDGEK
-        - mks_robin_nano_v1v2
-        #- mks_robin_nano_v1v2_usbmod
-        #- mks_robin_nano_v1_3_f4_usbmod
-        - NUCLEO_F767ZI
-        - REMRAM_V1
-        - BTT_SKR_SE_BX
-        - chitu_f103
-        - Opulo_Lumen_REV3
-
-        # ESP32 environments
-        - mks_tinybee
-
-        # Put lengthy tests last
-
-        - LPC1768
-        - LPC1769
-
-        # Non-working environment tests
-        #- at90usb1286_cdc
-        #- STM32F103CB_malyan
-        #- STM32F103RE
-        #- mks_robin_mini
-
-    steps:
-
-    - name: Check out the PR
-      uses: actions/checkout@v3
-
-    - name: Cache pip
-      uses: actions/cache@v3
-      with:
-        path: ~/.cache/pip
-        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
-        restore-keys: |
-          ${{ runner.os }}-pip-
-
-    - name: Cache PlatformIO
-      uses: actions/cache@v3
-      with:
-        path: ~/.platformio
-        key: ${{ runner.os }}-${{ hashFiles('**/lockfiles') }}
-
-    - name: Select Python 3.7
-      uses: actions/setup-python@v3
-      with:
-        python-version: '3.7' # Version range or exact version of a Python version to use, using semvers version range syntax.
-        architecture: 'x64' # optional x64 or x86. Defaults to x64 if not specified
-
-    - name: Install PlatformIO
-      run: |
-        pip install -U platformio
-        pio upgrade --dev
-        pio pkg update --global
-
-    - name: Run ${{ matrix.test-platform }} Tests
-      run: |
-        make tests-single-ci TEST_TARGET=${{ matrix.test-platform }}
diff --git a/.github/workflows/unlock-reopened.yml b/.github/workflows/unlock-reopened.yml
deleted file mode 100644
index 614ef3fab2..0000000000
--- a/.github/workflows/unlock-reopened.yml
+++ /dev/null
@@ -1,22 +0,0 @@
-#
-# unlock-reopened.yml
-# Unlock an issue whenever it is re-opened
-#
-
-name: "Unlock reopened issue"
-
-on:
-  issues:
-    types: [reopened]
-
-jobs:
-  unlock:
-    name: Unlock Reopened
-    if: github.repository == 'MarlinFirmware/Marlin'
-
-    runs-on: ubuntu-latest
-
-    steps:
-    - uses: OSDKDev/unlock-issues@v1.1
-      with:
-        repo-token: "${{ secrets.GITHUB_TOKEN }}"
diff --git a/.gitignore b/.gitignore
index 555bde8622..c34331a583 100755
--- a/.gitignore
+++ b/.gitignore
@@ -21,8 +21,7 @@
 
 # Generated files
 _Version.h
-bdf2u8g.exe
-genpages.exe
+bdf2u8g
 marlin_config.json
 mczip.h
 *.gen
@@ -142,7 +141,7 @@ vc-fileutils.settings
 
 # Visual Studio Code
 .vscode/*
-!.vscode/extensions.json
+#!.vscode/extensions.json
 
 #Simulation
 imgui.ini
diff --git a/.vscode/extensions.json b/.vscode/extensions.json
index f495d14f53..83b7c7594e 100644
--- a/.vscode/extensions.json
+++ b/.vscode/extensions.json
@@ -2,10 +2,10 @@
     // See http://go.microsoft.com/fwlink/?LinkId=827846
     // for the documentation about the extensions.json format
     "recommendations": [
-        "marlinfirmware.auto-build",
         "platformio.platformio-ide"
     ],
     "unwantedRecommendations": [
+        "marlinfirmware.auto-build",
         "ms-vscode.cpptools-extension-pack"
     ]
 }
diff --git a/LPC1769 Timers and PWM in Marlin.txt b/LPC1769 Timers and PWM in Marlin.txt
new file mode 100644
index 0000000000..d9fadffa6d
--- /dev/null
+++ b/LPC1769 Timers and PWM in Marlin.txt	
@@ -0,0 +1,8 @@
+SOFT_PWM option uses LPC_TIM3 and can emulate a PWM on any pin.
+If not using SOFT_PWM use TIM3 capture in on P0_23 TH1 or P0_24 TH2
+If SOFT_PWM is needed, swap LPC_TIM2 for LPC_TIM3, it looks like
+LPC_TIM2 is not being used, so that would free up LPC_TIM3 to access
+these avaiable pins for an RPM input sense. LPC_TIM2 pins are already
+being used by other functions on the SGEN board.
+
+HARD_PWM uses LPC_PWM1
\ No newline at end of file
diff --git a/Marlin Serial Com operation.txt b/Marlin Serial Com operation.txt
new file mode 100644
index 0000000000..168fde8144
--- /dev/null
+++ b/Marlin Serial Com operation.txt	
@@ -0,0 +1,176 @@
+Understanding Marlin Serial Com
+
+Marlin\src\HAL\LPC1768\MarlinSerial.cpp - has definitions for _MSerial0 - _MSerial3 which
+	points to LPCUART0-LPCUART3 and assigns the interrupt handlers.
+
+Marlin\src\HAL\NATIVE_SIM\HAL.h - checks the macros SERIAL_PORT, SERIAL_PORT1, MMU2_SERIAL_PORT,
+	and LCD_SERIAL_PORT to be within 0 to 3, and calls MSERIAL(0-3) to set LPC1769 UARTs and
+	interrupt handlers. If these are defined, then the following are defined:
+		#if WITHIN(SERIAL_PORT, -1, 3)		#define USBSerial or MSerial(0,1,2,3)
+		#if WITHIN(SERIAL_PORT_2, -1, 3)	#define USBSerial or MSerial(0,1,2,3)
+		#if WITHIN(SERIAL_PORT_3, -1, 3)	#define USBSerial or MSerial(0,1,2,3)
+		#if WITHIN(MMU2_SERIAL_PORT, -1, 3) 	#define USBSerial or MSerial(0,1,2,3)
+		#if WITHIN(LCD_SERIAL_PORT, -1, 3) 	#define USBSerial or MSerial(0,1,2,3)
+
+For all the above #defines that set to MSerial(0-3), MSerial(0-3) is an MSerialT type which is defined as a ForwardSerial1Class<MarlinSerial> in MarlinSerial.h.
+The MarlinSerial class references class HardwareSerial in HardwareSerial.h to setup the correct UART pins and registers, enables the interrupts, and defines the
+actual read, write, begin, etc code and all the other details needed to handle a specific UART port instance.
+
+
+NOTES:	SERIAL_PORT (logical first serial port) represents the primary HOST<>MARLIN communication port
+	SERIAL_PORT = 0 assigns it to LPC1769 UART0(P0.2/P0.3) which connect to AUX-1 on the SGEN board.
+	AUX-1 signals are RX0/TX0/RTS/CTS (RTS/CTS are just buffered versions of RX/TX).
+	AUX-1 is connected to the TFT35 LCD serial connection.
+
+	SERIAL_PORT_2 (logical second serial port)
+	SERIAL_PORT_2 = -1 assigns it to the USB port (P0_29/P0_30) 
+
+	SERIAL_PORT_3 (logical third serial port)
+	SERIAL_PORT_3 = currently not assigned
+
+	LCD_SERIAL_PORT (logical serial port)
+ 	LCD_SERIAL_PORT = currently not assigned
+
+	MMU2_SERIAL_PORT = (logical serial port)
+	MMU2_SERIAL_PORT = currently not assigned
+
+
+
+
+
+
+Josey76
+How to setup second independant serial port on Marlin 2.0.9
+October 05, 2021 12:22AM
+
+Hi, I'm new to the Reprap forums. A bit of history about me, I'm an electronics tech at work and I've been exploring 3D printing as a hobby for about 2.5 years. I've built my own core XY printer and I've been using Marlin on it and it works great.
+
+So when a project came up at work needing 5 axis stepper control, Marlin was the first thing I looked into. To my surprise 6 axis support has recently been added. We setup an Adafruit Grand Central and a RAMPS 1.4 board and so far Marlin 2.0.9 has been working great on this setup. I've added some simple position error correction using rotary quadrature encoders and some M codes for controlling solenoids and such and all that is working great.
+
+So my next big hurdle is connecting another device to Marlin over RS485. Here is where I've hit a block. If I enable another serial port in Configuration.h:
+#define SERIAL_PORT_2 1
+#define BAUDRATE_2 9600 // Enable to override BAUDRATE
+I get another serial port that translates fine over a MAX3485. I'm using a USB to RS485 adapter to read the signal back into my laptop for testing. I can transmit data from Marlin over RS485 to the external device, but I can't receive anything back. I can confirm that Marlin is reading the serial port correctly (via the MAX3485) because I can send G code and M code through this port and get responses.
+
+If my understanding is correct, this serial port is part of a "multiserial" object that combines several serial ports into one. This allows gcode to be sent over either the USB (my default connection), or the second serial port (RS485 in my case). This also means that data coming into this port is forwarded to the gcode parser so I can't read it for my purposes using Serial.read() etc... I think I also read somewhere that the entire serial port structure was revamped to this new style very recently (2.0.8 maybe?)
+
+So my question is how do I create the second serial port, but have it be independant so that I can send data to my device and receive it's response? I've read through the "docs/Serial.md" file which has helped me understand more, but I'm not the best at C++ and the code is a bit hard for me to follow. Does anyone have some instructions or some example code on how to do what I'm looking for? Or some helpful tips or explanations that might point me in the right direction to figure it out?
+
+Thanks in advance for any help.
+
+
+Dust
+Re: How to setup second independant serial port on Marlin 2.0.9
+October 05, 2021 12:25AM
+Marlin SERIAL_PORT, SERIAL_PORT_2 and SERIAL_PORT_3 all expect standard gcode
+
+If your wanting some other protocol you dont use these
+For other serial devices have a look at code using LCD_SERIAL_PORT or MMU2_SERIAL_PORT
+
+
+Josey76
+Re: How to setup second independant serial port on Marlin 2.0.9
+October 05, 2021 12:44PM
+Hi Dust,
+
+Thanks so much for that clue! That was exactly what I was looking for. Now I can read and write to the serial port as I wish.
+
+For anybody else who wants to do the same thing, here is how I got it working. If there is a cleaner way please let me know.
+
+In Configuration.h I added:
+
+#define LCD_SERIAL_PORT 1  // rs485 port
+#define LCD_BAUDRATE 9600
+
+
+
+I wanted to use the I2C pins on the RAMPs board (D20 and D21) so serial 2 is configured in MarlinSerial_AGCM4.cpp (for the Adafruit Grand Central):
+
+#if USING_HW_SERIAL1
+  UartT Serial2(false, &sercom3, PIN_SERIAL2_RX, PIN_SERIAL2_TX, PAD_SERIAL2_RX, PAD_SERIAL2_TX);
+  void SERCOM3_0_Handler() { Serial2.IrqHandler(); }
+  void SERCOM3_1_Handler() { Serial2.IrqHandler(); }
+  void SERCOM3_2_Handler() { Serial2.IrqHandler(); }
+  void SERCOM3_3_Handler() { Serial2.IrqHandler(); }
+#endif
+
+and in variant.h:
+
+// Serial2
+#define PIN_SERIAL2_RX      (21)
+#define PIN_SERIAL2_TX      (20)
+#define PAD_SERIAL2_TX      (UART_TX_PAD_0)
+#define PAD_SERIAL2_RX      (SERCOM_RX_PAD_1)
+#define SERCOM_SERIAL2		  sercom3
+
+In my .cpp file as part of an M code to initialize the device (copied from dwin_lcd.cpp):
+
+LCD_SERIAL.begin(LCD_BAUDRATE);
+
+const millis_t serial_connect_timeout = millis() + 1000UL;
+while (!LCD_SERIAL.connected() && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
+SERIAL_ECHOLN("serial ready");
+
+And if anyone wants to use a MAX3485 transciever this seems to work well. Pin A4 (also pin D71) is the transmit enable:
+"
+void writeRS485(char* msg485) {
+  WRITE(71, HIGH);
+
+  strcat(msg485, "\r\n");
+  SERIAL_ECHOLN("WRITING 485");
+  LCD_SERIAL.print(msg485);
+  // Serial2.print(msg485);
+
+  while (Serial2.availableForWrite() < SERIAL_BUFFER_SIZE - 1) {
+    gcode.dwell(1);
+  }
+  gcode.dwell(2);
+  WRITE(71, LOW);
+  gcode.dwell(50);
+  SERIAL_ECHOLN("reading");
+  while (LCD_SERIAL.available()) {
+    char in485 = LCD_SERIAL.read();
+    if (in485 != '\r')
+      SERIAL_CHAR(in485);
+  }
+}
+
+
+Hopefully this helps someone.
+
+Thanks again for the help.
+
+
+
+
+16.3 The Curiously Recurring Template Pattern (CRTP)
+This oddly named pattern refers to a general class of techniques that consists of passing a derived class as a
+template argument to one of its own base classes. In its simplest form, C++ code for such a pattern looks as follows:
+template <typename Derived>
+class CuriousBase {
+ â€¦
+};
+class Curious : public CuriousBase<Curious> {
+ â€¦
+};
+Our first outline of CRTP shows a nondependent base class: The class Curious is not a template and is therefore
+immune to some of the name visibility issues of dependent base classes. However, this is not an intrinsic
+characteristic of CRTP. Indeed, we could just as well have used the following alternative outline:
+template <typename Derived>
+class CuriousBase {
+ â€¦
+};
+template <typename T>
+class CuriousTemplate : public CuriousBase<CuriousTemplate<T> > {
+ â€¦
+};
+From this outline, however, it is not a far stretch to propose yet another alternative formulation, this time involving a
+template template parameter:
+template <template<typename> class Derived>
+class MoreCuriousBase {
+ â€¦
+};
+template <typename T>
+class MoreCurious : public MoreCuriousBase<MoreCurious> {
+ â€¦
+}; 
\ No newline at end of file
diff --git a/Marlin/Configuration.h b/Marlin/Configuration.h
index 54a895712d..5cb25f92db 100644
--- a/Marlin/Configuration.h
+++ b/Marlin/Configuration.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -37,6 +37,10 @@
  */
 #define CONFIGURATION_H_VERSION 02010300
 
+//TG 1/19/20 added this to re-assign Y_STEP_PIN and Y_DIR_PIN pins needed for JTAG debugging
+// note: the Y-AXIS driver cannot be used because it still connects to old Y_STEP_PIN and Y_DIR_PIN
+// so be sure to pull the driver out!!
+//#define JTAG_DEBUGGING
 //===========================================================================
 //============================= Getting Started =============================
 //===========================================================================
@@ -60,7 +64,7 @@
 // @section info
 
 // Author info of this build printed to the host during boot and M115
-#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.
+#define STRING_CONFIG_H_AUTHOR "(TG Engineering, Tony, MKS-SGEN)" //TG 12/30/2020 Who made the changes.
 //#define CUSTOM_VERSION_FILE Version.h // Path from the root directory (no quotes)
 
 /**
@@ -78,7 +82,7 @@
 #define SHOW_BOOTSCREEN
 
 // Show the bitmap in Marlin/_Bootscreen.h on startup.
-//#define SHOW_CUSTOM_BOOTSCREEN
+#define SHOW_CUSTOM_BOOTSCREEN	//TG 12/30/2020
 
 // Show the bitmap in Marlin/_Statusscreen.h on the status screen.
 //#define CUSTOM_STATUS_SCREEN_IMAGE
@@ -87,7 +91,7 @@
 
 // Choose the name from boards.h that matches your setup
 #ifndef MOTHERBOARD
-  #define MOTHERBOARD BOARD_RAMPS_14_EFB
+  #define MOTHERBOARD BOARD_MKS_SGEN	//TG 12/30/2020
 #endif
 
 /**
@@ -120,22 +124,23 @@
  * Currently Ethernet (-2) is only supported on Teensy 4.1 boards.
  * :[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7]
  */
-//#define SERIAL_PORT_2 -1
-//#define BAUDRATE_2 250000   // :[2400, 9600, 19200, 38400, 57600, 115200, 250000, 500000, 1000000] Enable to override BAUDRATE
+#define SERIAL_PORT_2 -1  //TG 12/30/2020 this will enable the USBSerial port, 0 for GEN_L and SGEN, -1 for SKR boards
+//#define BAUDRATE_2 250000   // Enable to override BAUDRATE
 
 /**
  * Select a third serial port on the board to use for communication with the host.
  * Currently only supported for AVR, DUE, LPC1768/9 and STM32/STM32F1
  * :[-1, 0, 1, 2, 3, 4, 5, 6, 7]
  */
-//#define SERIAL_PORT_3 1
-//#define BAUDRATE_3 250000   // :[2400, 9600, 19200, 38400, 57600, 115200, 250000, 500000, 1000000] Enable to override BAUDRATE
+//#define SERIAL_PORT_3 3
+//#define BAUDRATE_3 38400   // Enable to override BAUDRATE
+
 
 // Enable the Bluetooth serial interface on AT90USB devices
 //#define BLUETOOTH
 
 // Name displayed in the LCD "Ready" message and Info menu
-//#define CUSTOM_MACHINE_NAME "3D Printer"
+#define CUSTOM_MACHINE_NAME "MPCNC-MKS_SGEN"	//TG 12/30/2020
 
 // Printer's unique ID, used by some programs to differentiate between machines.
 // Choose your own or use a service like https://www.uuidgenerator.net/version4
@@ -149,6 +154,8 @@
  * These settings allow Marlin to tune stepper driver timing and enable advanced options for
  * stepper drivers that support them. You may also override timing options in Configuration_adv.h.
  *
+ * A4988 is assumed for unspecified drivers.
+ *
  * Use TMC2208/TMC2208_STANDALONE for TMC2225 drivers and TMC2209/TMC2209_STANDALONE for TMC2226 drivers.
  *
  * Options: A4988, A5984, DRV8825, LV8729, TB6560, TB6600, TMC2100,
@@ -158,11 +165,11 @@
  *          TMC5130, TMC5130_STANDALONE, TMC5160, TMC5160_STANDALONE
  * :['A4988', 'A5984', 'DRV8825', 'LV8729', 'TB6560', 'TB6600', 'TMC2100', 'TMC2130', 'TMC2130_STANDALONE', 'TMC2160', 'TMC2160_STANDALONE', 'TMC2208', 'TMC2208_STANDALONE', 'TMC2209', 'TMC2209_STANDALONE', 'TMC26X', 'TMC26X_STANDALONE', 'TMC2660', 'TMC2660_STANDALONE', 'TMC5130', 'TMC5130_STANDALONE', 'TMC5160', 'TMC5160_STANDALONE']
  */
-#define X_DRIVER_TYPE  A4988
-#define Y_DRIVER_TYPE  A4988
-#define Z_DRIVER_TYPE  A4988
-//#define X2_DRIVER_TYPE A4988
-//#define Y2_DRIVER_TYPE A4988
+#define X_DRIVER_TYPE  TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)  0.85V=600ma, 0.92V=650ma, 1.00V=710ma, 1.06V=750ma 
+#define Y_DRIVER_TYPE  TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)  1.13V=800ma, 1.20V=850ma, 1.27V=900ma, 1.41V=1000ma
+#define Z_DRIVER_TYPE  TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)  all currents are RMS, not peak
+#define X2_DRIVER_TYPE TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)
+#define Y2_DRIVER_TYPE TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)
 //#define Z2_DRIVER_TYPE A4988
 //#define Z3_DRIVER_TYPE A4988
 //#define Z4_DRIVER_TYPE A4988
@@ -172,8 +179,8 @@
 //#define U_DRIVER_TYPE  A4988
 //#define V_DRIVER_TYPE  A4988
 //#define W_DRIVER_TYPE  A4988
-#define E0_DRIVER_TYPE A4988
-//#define E1_DRIVER_TYPE A4988
+#define E0_DRIVER_TYPE TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)
+#define E1_DRIVER_TYPE TMC2100	//TG 3/6/2021 set all driver Vref to 0.75V (530mA)
 //#define E2_DRIVER_TYPE A4988
 //#define E3_DRIVER_TYPE A4988
 //#define E4_DRIVER_TYPE A4988
@@ -198,6 +205,7 @@
  *
  * Regardless of these settings the axes are internally named I, J, K, U, V, W.
  */
+ 
 #ifdef I_DRIVER_TYPE
   #define AXIS4_NAME 'A' // :['A', 'B', 'C', 'U', 'V', 'W']
   #define AXIS4_ROTATES
@@ -227,7 +235,12 @@
 
 // This defines the number of extruders
 // :[0, 1, 2, 3, 4, 5, 6, 7, 8]
-#define EXTRUDERS 1
+#define EXTRUDERS 0	                          //TG 12/30/2020
+#define SPINDLES 1                            //TG 2/3/2021
+
+// Spindle/Laser can use Fan & Heater outputs for control if no extruders or bed. If zero will optionally
+// use J8 header pins for spindle/laser as long as J8 is not being used for TMC UART devices like 2208/2209
+#define SPINDLE_LASER_USE_FAN_HEATER_PINS 0   //TG 2/11/21 force use of J8 pins = 0 ( use Fan & Heater pins = 1)
 
 // Generally expected filament diameter (1.75, 2.85, 3.0, ...). Used for Volumetric, Filament Width Sensor, etc.
 #define DEFAULT_NOMINAL_FILAMENT_DIA 1.75
@@ -545,15 +558,15 @@
  *   999 : Dummy Table that ALWAYS reads 100Â°C or the temperature defined below.
  *
  */
-#define TEMP_SENSOR_0 1
-#define TEMP_SENSOR_1 0
+#define TEMP_SENSOR_0 999	  //TG 12/30/2020
+#define TEMP_SENSOR_1 998   //TG 12/30/2020
 #define TEMP_SENSOR_2 0
 #define TEMP_SENSOR_3 0
 #define TEMP_SENSOR_4 0
 #define TEMP_SENSOR_5 0
 #define TEMP_SENSOR_6 0
 #define TEMP_SENSOR_7 0
-#define TEMP_SENSOR_BED 0
+#define TEMP_SENSOR_BED 998	//TG 12/30/2020
 #define TEMP_SENSOR_PROBE 0
 #define TEMP_SENSOR_CHAMBER 0
 #define TEMP_SENSOR_COOLER 0
@@ -652,14 +665,12 @@
 //===========================================================================
 //============================= PID Settings ================================
 //===========================================================================
-
+// PID Tuning Guide here: https://reprap.org/wiki/PID_Tuning
 // @section hotend temp
-
 // Enable PIDTEMP for PID control or MPCTEMP for Predictive Model.
 // temperature control. Disable both for bang-bang heating.
-#define PIDTEMP          // See the PID Tuning Guide at https://reprap.org/wiki/PID_Tuning
+//#define PIDTEMP 	//TG 12/30/2020 disable PID for BED heater, but we will use the Kp,Ki,Kd values for Spindle Speed
 //#define MPCTEMP        // ** EXPERIMENTAL **
-
 #define BANG_MAX 255     // Limits current to nozzle while in bang-bang mode; 255=full current
 #define PID_MAX BANG_MAX // Limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current
 #define PID_K1 0.95      // Smoothing factor within any PID loop
@@ -730,7 +741,7 @@
 //===========================================================================
 
 /**
- * PID Bed Heating
+ * PID Bed Heating  //TG **for CNC we can use Kp,Ki,Kd from BED to get access to M304 and EEPROM storage  
  *
  * If this option is enabled set PID constants below.
  * If this option is disabled, bang-bang will be used and BED_LIMIT_SWITCHING will enable hysteresis.
@@ -741,9 +752,15 @@
  * impact FET heating. This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W
  * heater. If your configuration is significantly different than this and you don't understand
  * the issues involved, don't use bed PID until someone else verifies that your hardware works.
+
  * @section bed temp
  */
-//#define PIDTEMPBED
+//#define PIDTEMPBED	//TG 12/30/2020
+
+/*
+ * //TG 9/28/21 - note: for CNC we can use Kp,Ki,Kd from BED to get access to M304 and EEPROM storage
+ */
+#define PIDSPINDLE_USE_PIDTEMPBED   //TG 9/21/21 added to allow using Kp,Ki,Kd from BED to get access to M304 and EEPROM storage
 
 //#define BED_LIMIT_SWITCHING
 
@@ -755,15 +772,16 @@
  */
 #define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current
 
-#if ENABLED(PIDTEMPBED)
+#if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
   //#define MIN_BED_POWER 0
   //#define PID_BED_DEBUG // Print Bed PID debug data to the serial port.
 
-  // 120V 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)
-  // from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)
-  #define DEFAULT_bedKp 10.00
-  #define DEFAULT_bedKi .023
-  #define DEFAULT_bedKd 305.4
+  //TG 10/2/21  default values for DeWalt 660 spindle motor
+  // 
+  #define DEFAULT_bedKp 0.19
+  #define DEFAULT_bedKi 0.19
+  #define DEFAULT_bedKd 0.00
+  
 
   // FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.
 #endif // PIDTEMPBED
@@ -813,7 +831,7 @@
   // FIND YOUR OWN: "M303 E-2 C8 S50" to run autotune on the chamber at 50 degreesC for 8 cycles.
 #endif // PIDTEMPCHAMBER
 
-#if ANY(PIDTEMP, PIDTEMPBED, PIDTEMPCHAMBER)
+#if ANY(PIDTEMP, PIDTEMPBED, PIDTEMPCHAMBER, PIDSPINDLE_USE_PIDTEMPBED)   //TG 3/9/23 added PIDSPINDLE_USE_PIDTEMPBED
   //#define PID_OPENLOOP          // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX
   //#define SLOW_PWM_HEATERS      // PWM with very low frequency (roughly 0.125Hz=8s) and minimum state time of approximately 1s useful for heaters driven by a relay
   #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature
@@ -859,10 +877,12 @@
  * details can be tuned in Configuration_adv.h
  */
 
-#define THERMAL_PROTECTION_HOTENDS // Enable thermal protection for all extruders
-#define THERMAL_PROTECTION_BED     // Enable thermal protection for the heated bed
-#define THERMAL_PROTECTION_CHAMBER // Enable thermal protection for the heated chamber
-#define THERMAL_PROTECTION_COOLER  // Enable thermal protection for the laser cooling
+
+//TG 2/22/21 need all of these turned off since for CNC there is no hotend, bed, or chamber
+//#define THERMAL_PROTECTION_HOTENDS // Enable thermal protection for all extruders
+//#define THERMAL_PROTECTION_BED     // Enable thermal protection for the heated bed
+//#define THERMAL_PROTECTION_CHAMBER // Enable thermal protection for the heated chamber
+//#define THERMAL_PROTECTION_COOLER  // Enable thermal protection for the laser cooling
 
 //===========================================================================
 //============================= Mechanical Settings =========================
@@ -1097,16 +1117,16 @@
 // extra connectors. Leave undefined any used for non-endstop and non-probe purposes.
 #define USE_XMIN_PLUG
 #define USE_YMIN_PLUG
-#define USE_ZMIN_PLUG
+#define USE_ZMIN_PLUG   //TG 9/30/2022 for MPCNC probing down or 3d printer homing / BL Touch probing down
 //#define USE_IMIN_PLUG
 //#define USE_JMIN_PLUG
 //#define USE_KMIN_PLUG
 //#define USE_UMIN_PLUG
 //#define USE_VMIN_PLUG
 //#define USE_WMIN_PLUG
-//#define USE_XMAX_PLUG
-//#define USE_YMAX_PLUG
-//#define USE_ZMAX_PLUG
+#define USE_XMAX_PLUG	//TG 12/30/2020
+#define USE_YMAX_PLUG	//TG 12/30/2020
+#define USE_ZMAX_PLUG   //TG 9/30/2022  for MPCNC homing up 
 //#define USE_IMAX_PLUG
 //#define USE_JMAX_PLUG
 //#define USE_KMAX_PLUG
@@ -1164,10 +1184,10 @@
   //#define ENDSTOPPULLDOWN_ZMIN_PROBE
 #endif
 
-// Mechanical endstop with COM to ground and NC to Signal uses "false" here (most common setup).
-#define X_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
-#define Y_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
-#define Z_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
+// Mechanical endstop with COM to ground and NC to Signal uses "false" here, goes high when activated (most common setup).
+#define X_MIN_ENDSTOP_INVERTING false 	//TG 12/30/2020 Set to true to invert the logic of the endstop.
+#define Y_MIN_ENDSTOP_INVERTING false 	//TG 12/30/2020 Set to true to invert the logic of the endstop.
+#define Z_MIN_ENDSTOP_INVERTING true 	  //TG 3/5/2021 Zmin switch wired NO, closes to ground when activated
 #define I_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define J_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define K_MIN_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
@@ -1183,7 +1203,8 @@
 #define U_MAX_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define V_MAX_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
 #define W_MAX_ENDSTOP_INVERTING false // Set to true to invert the logic of the endstop.
-#define Z_MIN_PROBE_ENDSTOP_INVERTING false // Set to true to invert the logic of the probe.
+#define Z_MIN_PROBE_ENDSTOP_INVERTING true 	//TG 3/5/2021 Zmin switch wired NO, closes to ground when activated
+
 
 // Enable this feature if all enabled endstop pins are interrupt-capable.
 // This will remove the need to poll the interrupt pins, saving many CPU cycles.
@@ -1231,18 +1252,18 @@
  * Override with M92
  *                                      X, Y, Z [, I [, J [, K...]]], E0 [, E1[, E2...]]
  */
-#define DEFAULT_AXIS_STEPS_PER_UNIT   { 80, 80, 400, 500 }
+#define DEFAULT_AXIS_STEPS_PER_UNIT   { 99.8, 99.8, 399.5 }	//TG 2/5/2022
 
 /**
  * Default Max Feed Rate (linear=mm/s, rotational=Â°/s)
  * Override with M203
  *                                      X, Y, Z [, I [, J [, K...]]], E0 [, E1[, E2...]]
  */
-#define DEFAULT_MAX_FEEDRATE          { 300, 300, 5, 25 }
+#define DEFAULT_MAX_FEEDRATE          { 200, 200, 60 }	//TG 12/30/2020
 
 //#define LIMITED_MAX_FR_EDITING        // Limit edit via M203 or LCD to DEFAULT_MAX_FEEDRATE * 2
 #if ENABLED(LIMITED_MAX_FR_EDITING)
-  #define MAX_FEEDRATE_EDIT_VALUES    { 600, 600, 10, 50 } // ...or, set your own edit limits
+  #define MAX_FEEDRATE_EDIT_VALUES    { 600, 600, 10 } // ...or, set your own edit limits
 #endif
 
 /**
@@ -1251,11 +1272,11 @@
  * Override with M201
  *                                      X, Y, Z [, I [, J [, K...]]], E0 [, E1[, E2...]]
  */
-#define DEFAULT_MAX_ACCELERATION      { 3000, 3000, 100, 10000 }
+#define DEFAULT_MAX_ACCELERATION      { 180, 180, 80}	//TG 12/30/2020
 
 //#define LIMITED_MAX_ACCEL_EDITING     // Limit edit via M201 or LCD to DEFAULT_MAX_ACCELERATION * 2
 #if ENABLED(LIMITED_MAX_ACCEL_EDITING)
-  #define MAX_ACCEL_EDIT_VALUES       { 6000, 6000, 200, 20000 } // ...or, set your own edit limits
+  #define MAX_ACCEL_EDIT_VALUES       { 6000, 6000, 200 } // ...or, set your own edit limits
 #endif
 
 /**
@@ -1266,9 +1287,9 @@
  *   M204 R    Retract Acceleration
  *   M204 T    Travel Acceleration
  */
-#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E acceleration for printing moves
-#define DEFAULT_RETRACT_ACCELERATION  3000    // E acceleration for retracts
-#define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration for travel (non printing) moves
+#define DEFAULT_ACCELERATION          180    	//TG 12/30/2020 X, Y, Z and E acceleration for printing moves
+#define DEFAULT_RETRACT_ACCELERATION  3000    //TG 12/30/2020 E acceleration for retracts
+#define DEFAULT_TRAVEL_ACCELERATION   180    	//TG 12/30/2020 X, Y, Z acceleration for travel (non printing) moves
 
 /**
  * Default Jerk limits (mm/s)
@@ -1280,8 +1301,8 @@
  */
 //#define CLASSIC_JERK
 #if ENABLED(CLASSIC_JERK)
-  #define DEFAULT_XJERK 10.0
-  #define DEFAULT_YJERK 10.0
+  #define DEFAULT_XJERK 3.5	//TG 12/30/2020
+  #define DEFAULT_YJERK 3.5	//TG 12/30/2020
   #define DEFAULT_ZJERK  0.3
   //#define DEFAULT_IJERK  0.3
   //#define DEFAULT_JJERK  0.3
@@ -1294,7 +1315,7 @@
 
   //#define LIMITED_JERK_EDITING        // Limit edit via M205 or LCD to DEFAULT_aJERK * 2
   #if ENABLED(LIMITED_JERK_EDITING)
-    #define MAX_JERK_EDIT_VALUES { 20, 20, 0.6, 10 } // ...or, set your own edit limits
+    #define MAX_JERK_EDIT_VALUES { 20, 20, 0.6 } // ...or, set your own edit limits
   #endif
 #endif
 
@@ -1308,7 +1329,7 @@
  *   https://blog.kyneticcnc.com/2018/10/computing-junction-deviation-for-marlin.html
  */
 #if DISABLED(CLASSIC_JERK)
-  #define JUNCTION_DEVIATION_MM 0.013 // (mm) Distance from real junction edge
+  #define JUNCTION_DEVIATION_MM 0.04 	//TG 12/30/2020 (mm) Distance from real junction edge
   #define JD_HANDLE_SMALL_SEGMENTS    // Use curvature estimation instead of just the junction angle
                                       // for small segments (< 1mm) with large junction angles (> 135Â°).
 #endif
@@ -1321,7 +1342,7 @@
  *
  * See https://github.com/synthetos/TinyG/wiki/Jerk-Controlled-Motion-Explained
  */
-//#define S_CURVE_ACCELERATION
+#define S_CURVE_ACCELERATION	//TG 12/30/2020
 
 //===========================================================================
 //============================= Z Probe Options =============================
@@ -1337,7 +1358,7 @@
  * The probe replaces the Z-MIN endstop and is used for Z homing.
  * (Automatically enables USE_PROBE_FOR_Z_HOMING.)
  */
-#define Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN
+//#define Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN	//TG 12/30/2020
 
 // Force the use of the probe for Z-axis homing
 //#define USE_PROBE_FOR_Z_HOMING
@@ -1357,7 +1378,7 @@
  *      - normally-closed switches to GND and D32.
  *      - normally-open switches to 5V and D32.
  */
-//#define Z_MIN_PROBE_PIN 32 // Pin 32 is the RAMPS default
+#define Z_MIN_PROBE_PIN P1_28 // Pin 32 is the RAMPS default
 
 /**
  * Probe Type
@@ -1377,7 +1398,7 @@
  * A Fix-Mounted Probe either doesn't deploy or needs manual deployment.
  *   (e.g., an inductive probe or a nozzle-based probe-switch.)
  */
-//#define FIX_MOUNTED_PROBE
+#define FIX_MOUNTED_PROBE   //TG 9/30/2022 uncomment for G38 to work using ZMIN endstop pin as a Probe
 
 /**
  * Use the nozzle as the probe, as with a conductive
@@ -1553,13 +1574,13 @@
 #define PROBING_MARGIN 10
 
 // X and Y axis travel speed (mm/min) between probes
-#define XY_PROBE_FEEDRATE (133*60)
+#define XY_PROBE_FEEDRATE (133*60)	//TG 12/30/2020
 
 // Feedrate (mm/min) for the first approach when double-probing (MULTIPLE_PROBING == 2)
-#define Z_PROBE_FEEDRATE_FAST (4*60)
+#define Z_PROBE_FEEDRATE_FAST (3*60)
 
 // Feedrate (mm/min) for the "accurate" probe of each point
-#define Z_PROBE_FEEDRATE_SLOW (Z_PROBE_FEEDRATE_FAST / 2)
+#define Z_PROBE_FEEDRATE_SLOW (Z_PROBE_FEEDRATE_FAST / 2)	//TG 12/30/2020
 
 /**
  * Probe Activation Switch
@@ -1628,7 +1649,9 @@
 #define Z_CLEARANCE_MULTI_PROBE     5 // Z Clearance between multiple probes
 //#define Z_AFTER_PROBING           5 // Z position after probing is done
 
-#define Z_PROBE_LOW_POINT          -2 // Farthest distance below the trigger-point to go before stopping
+//TG 9/30/2022 modified to take Z_MIN_POS into account when homing dir is reversed(up) and probing is negative dir
+#define Z_PROBE_LOW_POINT   Z_MIN_POS - 2     // Farthest distance below the trigger-point to go before stopping
+                                              
 
 // For M851 give a range for adjusting the Z probe offset
 #define Z_PROBE_OFFSET_RANGE_MIN -20
@@ -1682,30 +1705,30 @@
 
 // Disable axis steppers immediately when they're not being stepped.
 // WARNING: When motors turn off there is a chance of losing position accuracy!
-//#define DISABLE_X
-//#define DISABLE_Y
-//#define DISABLE_Z
-//#define DISABLE_I
-//#define DISABLE_J
-//#define DISABLE_K
-//#define DISABLE_U
-//#define DISABLE_V
-//#define DISABLE_W
+#define DISABLE_X false
+#define DISABLE_Y false
+#define DISABLE_Z false
+//#define DISABLE_I false
+//#define DISABLE_J false
+//#define DISABLE_K false
+//#define DISABLE_U false
+//#define DISABLE_V false
+//#define DISABLE_W false
 
 // Turn off the display blinking that warns about possible accuracy reduction
 //#define DISABLE_REDUCED_ACCURACY_WARNING
 
 // @section extruder
 
-//#define DISABLE_E                 // Disable the extruder when not stepping
+#define DISABLE_E false             // Disable the extruder when not stepping
 #define DISABLE_INACTIVE_EXTRUDER   // Keep only the active extruder enabled
 
 // @section motion
 
 // Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.
-#define INVERT_X_DIR false
-#define INVERT_Y_DIR true
-#define INVERT_Z_DIR false
+#define INVERT_X_DIR false  //TG 3/4/2021 correct for MPCNC
+#define INVERT_Y_DIR true   //TG 3/4/2021 correct for MPCNC
+#define INVERT_Z_DIR true	  //TG 3/4/2021 correct for MPCNC
 //#define INVERT_I_DIR false
 //#define INVERT_J_DIR false
 //#define INVERT_K_DIR false
@@ -1716,8 +1739,8 @@
 // @section extruder
 
 // For direct drive extruder v9 set to true, for geared extruder set to false.
-#define INVERT_E0_DIR false
-#define INVERT_E1_DIR false
+#define INVERT_E0_DIR false	//TG 3/4/2021 correct for MPCNC
+#define INVERT_E1_DIR false	//TG 3/4/2021 correct for MPCNC
 #define INVERT_E2_DIR false
 #define INVERT_E3_DIR false
 #define INVERT_E4_DIR false
@@ -1746,8 +1769,8 @@
 // :[-1,1]
 #define X_HOME_DIR -1
 #define Y_HOME_DIR -1
-#define Z_HOME_DIR -1
-//#define I_HOME_DIR -1
+#define Z_HOME_DIR  1    //TG 9/30/2022 - changed to Home Z up to max(MPCNC limit when tube slips past lower bearings )
+//#define I_HOME_DIR -1  //               using ZMAX endstop for homing now (was -1 when using ZMIN endstop for homing)            
 //#define J_HOME_DIR -1
 //#define K_HOME_DIR -1
 //#define U_HOME_DIR -1
@@ -1756,17 +1779,20 @@
 
 // @section geometry
 
-// The size of the printable area
-#define X_BED_SIZE 200
-#define Y_BED_SIZE 200
+// The size of the print bed
+#define X_BED_SIZE 510	//TG 4/30/2021  updated after vacuum system added was 550
+#define Y_BED_SIZE 510	//TG 4/30/2021  updated after vacuum system added was 540
 
 // Travel limits (linear=mm, rotational=Â°) after homing, corresponding to endstop positions.
 #define X_MIN_POS 0
 #define Y_MIN_POS 0
-#define Z_MIN_POS 0
+#define Z_MIN_POS -65 //TG 9/30/2022 min travel of MPCNC (w/15.7mm tool length) just hits spoilboard 
+                      //if Z Homing down(normal 3D) use 0, if Z Homing up(new MPCNC) use -65
 #define X_MAX_POS X_BED_SIZE
 #define Y_MAX_POS Y_BED_SIZE
-#define Z_MAX_POS 200
+#define Z_MAX_POS 0	  //TG 9/30/2022 max travel of MPCNC before rail tube rises past lower bearings 
+                      //if Z Homing up(new MPCNC) use 0, if Z Homing down(normal 3D) use 65
+
 //#define I_MIN_POS 0
 //#define I_MAX_POS 50
 //#define J_MIN_POS 0
@@ -1794,7 +1820,7 @@
 #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
   #define MIN_SOFTWARE_ENDSTOP_X
   #define MIN_SOFTWARE_ENDSTOP_Y
-  #define MIN_SOFTWARE_ENDSTOP_Z
+  #define MIN_SOFTWARE_ENDSTOP_Z	//TG 9/30/2022 homing Z now up to max travel endstop
   #define MIN_SOFTWARE_ENDSTOP_I
   #define MIN_SOFTWARE_ENDSTOP_J
   #define MIN_SOFTWARE_ENDSTOP_K
@@ -1804,11 +1830,11 @@
 #endif
 
 // Max software endstops constrain movement within maximum coordinate bounds
-#define MAX_SOFTWARE_ENDSTOPS
+#define MAX_SOFTWARE_ENDSTOPS	//TG 12/30/2020
 #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
   #define MAX_SOFTWARE_ENDSTOP_X
   #define MAX_SOFTWARE_ENDSTOP_Y
-  #define MAX_SOFTWARE_ENDSTOP_Z
+  //#define MAX_SOFTWARE_ENDSTOP_Z  //TG 9/30/2022 homing Z now up to max travel endstop
   #define MAX_SOFTWARE_ENDSTOP_I
   #define MAX_SOFTWARE_ENDSTOP_J
   #define MAX_SOFTWARE_ENDSTOP_K
@@ -1818,7 +1844,7 @@
 #endif
 
 #if EITHER(MIN_SOFTWARE_ENDSTOPS, MAX_SOFTWARE_ENDSTOPS)
-  //#define SOFT_ENDSTOPS_MENU_ITEM  // Enable/Disable software endstops from the LCD
+  #define SOFT_ENDSTOPS_MENU_ITEM  // Enable/Disable software endstops from the LCD
 #endif
 
 /**
@@ -2258,12 +2284,12 @@
  *   M501 - Read settings from EEPROM. (i.e., Throw away unsaved changes)
  *   M502 - Revert settings to "factory" defaults. (Follow with M500 to init the EEPROM.)
  */
-//#define EEPROM_SETTINGS     // Persistent storage with M500 and M501
-//#define DISABLE_M503        // Saves ~2700 bytes of flash. Disable for release!
+#define EEPROM_SETTINGS       //TG 3/4/21 make sure this is enabled  Persistent storage with M500 and M501
+//#define DISABLE_M503        // Saves ~2700 bytes of PROGMEM. Disable for release!
 #define EEPROM_CHITCHAT       // Give feedback on EEPROM commands. Disable to save PROGMEM.
 #define EEPROM_BOOT_SILENT    // Keep M503 quiet and only give errors during first load
 #if ENABLED(EEPROM_SETTINGS)
-  //#define EEPROM_AUTO_INIT  // Init EEPROM automatically on any errors.
+  #define EEPROM_AUTO_INIT    //TG 12/30/2020 Init EEPROM automatically on any errors.  //#define EEPROM_AUTO_INIT  // Init EEPROM automatically on any errors.
   //#define EEPROM_INIT_NOW   // Init EEPROM on first boot after a new build.
 #endif
 
@@ -2542,7 +2568,7 @@
  * SD Card support is disabled by default. If your controller has an SD slot,
  * you must uncomment the following option or it won't work.
  */
-//#define SDSUPPORT
+#define SDSUPPORT
 
 /**
  * SD CARD: ENABLE CRC
@@ -2622,8 +2648,8 @@
 //
 // Add individual axis homing items (Home X, Home Y, and Home Z) to the LCD menu.
 //
-//#define INDIVIDUAL_AXIS_HOMING_MENU
-//#define INDIVIDUAL_AXIS_HOMING_SUBMENU
+#define INDIVIDUAL_AXIS_HOMING_MENU	//TG 12/30/2020
+#define INDIVIDUAL_AXIS_HOMING_SUBMENU //TG 12/30/2020
 
 //
 // SPEAKER/BUZZER
@@ -2813,7 +2839,7 @@
 // RepRapDiscount FULL GRAPHIC Smart Controller
 // https://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller
 //
-//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER
+#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER  //TG enabled
 
 //
 // K.3D Full Graphic Smart Controller
@@ -3020,6 +3046,15 @@
 
 /**
  * DGUS Touch Display with DWIN OS. (Choose one.)
+ * ORIGIN : https://www.aliexpress.com/item/32993409517.html
+ * FYSETC : https://www.aliexpress.com/item/32961471929.html
+ * MKS    : https://www.aliexpress.com/item/1005002008179262.html
+ *
+ * Flash display with DGUS Displays for Marlin:
+ *  - Format the SD card to FAT32 with an allocation size of 4kb.
+ *  - Download files as specified for your type of display.
+ *  - Plug the microSD card into the back of the display.
+ *  - Boot the display and wait for the update to complete.
  *
  * ORIGIN (Marlin DWIN_SET)
  *  - Download https://github.com/coldtobi/Marlin_DGUS_Resources
@@ -3308,7 +3343,7 @@
 // Use software PWM to drive the fan, as for the heaters. This uses a very low frequency
 // which is not as annoying as with the hardware PWM. On the other hand, if this frequency
 // is too low, you should also increment SOFT_PWM_SCALE.
-//#define FAN_SOFT_PWM
+//#define FAN_SOFT_PWM                  //TG 9/1/21 this option gives PWM freq of 7 Hz @ SOFT_PWM_SCALE=0, 124 Hz @ SOFT_PWM_SCALE=4 
 
 // Incrementing this by 1 will double the software PWM frequency,
 // affecting heaters, and the fan if FAN_SOFT_PWM is enabled.
@@ -3372,13 +3407,10 @@
 //#define RGBW_LED
 
 #if EITHER(RGB_LED, RGBW_LED)
-  //#define RGB_LED_R_PIN 34
-  //#define RGB_LED_G_PIN 43
-  //#define RGB_LED_B_PIN 35
-  //#define RGB_LED_W_PIN -1
-#endif
-
-#if ANY(RGB_LED, RGBW_LED, PCA9632)
+  #define RGB_LED_R_PIN 5 //TG 12/30/2020  these are for SWX1 board
+  #define RGB_LED_G_PIN 4 //TG 12/30/2020
+  #define RGB_LED_B_PIN 6 //TG 12/30/2020
+  #define RGB_LED_W_PIN -1
   //#define RGB_STARTUP_TEST              // For PWM pins, fade between all colors
   #if ENABLED(RGB_STARTUP_TEST)
     #define RGB_STARTUP_TEST_INNER_MS 10  // (ms) Reduce or increase fading speed
@@ -3453,6 +3485,13 @@
 
 // Edit servo angles with M281 and save to EEPROM with M500
 //#define EDITABLE_SERVO_ANGLES
+#define SHORT_BUILD_VERSION "106T 2.1.x (bugfix) "
+
+
+//TG 4/30/21 added this to fix garbled characters in Marlin Mode on SGEN boards
+//#define ST7920_DELAY_1 DELAY_NS(100)
+//#define ST7920_DELAY_2 DELAY_NS(1000)
+//#define ST7920_DELAY_3 DELAY_NS(1000)
 
 // Disable servo with M282 to reduce power consumption, noise, and heat when not in use
 //#define SERVO_DETACH_GCODE
diff --git a/Marlin/Configuration_adv.h b/Marlin/Configuration_adv.h
index abb238e33e..d4879f7e26 100644
--- a/Marlin/Configuration_adv.h
+++ b/Marlin/Configuration_adv.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -32,6 +32,18 @@
  */
 #define CONFIGURATION_ADV_H_VERSION 02010300
 
+//===========================================================================
+//=================== TG CUSTOM Version Settings ============================
+//===========================================================================
+// @section TGcustom
+
+#define NO_AUTO_ASSIGN_WARNING // turn off auto-assign type warnings from compile
+
+//TG enable this to append current WCS info at end of temperature autoreport
+#define REPORT_WCS
+//TG NEW G39 = output Active Workspace, G39 T = output table of all workspaces, G39 P = current position in physical and logical units
+#define ENABLE_G39
+
 // @section develop
 
 /**
@@ -171,6 +183,13 @@
 
 /**
  * Thermocouple Options â€” for MAX6675 (-2), MAX31855 (-3), and MAX31865 (-5).
+ *   FORCE_HW_SPI:   Ignore SCK/MOSI/MISO pins and just use the CS pin & default SPI bus.
+ *   MAX31865_WIRES: Set the number of wires for the probe connected to a MAX31865 board, 2-4. Default: 2
+ *   MAX31865_50HZ:  Enable 50Hz filter instead of the default 60Hz.
+ *   MAX31865_USE_READ_ERROR_DETECTION: Detects random read errors from value spikes (a 20Â°C difference in less than 1sec)
+ *   MAX31865_USE_AUTO_MODE: Faster and more frequent reads than 1-shot, but bias voltage always on, slightly affecting RTD temperature.
+ *   MAX31865_MIN_SAMPLING_TIME_MSEC: in 1-shot mode, the minimum time between subsequent reads. This reduces the effect of bias voltage by leaving the sensor unpowered for longer intervals.
+ *   MAX31865_WIRE_OHMS: In 2-wire configurations, manually set the wire resistance for more accurate readings
  */
 //#define TEMP_SENSOR_FORCE_HW_SPI                // Ignore SCK/MOSI/MISO pins; use CS and the default SPI bus.
 //#define MAX31865_SENSOR_WIRES_0 2               // (2-4) Number of wires for the probe connected to a MAX31865 board.
@@ -803,6 +822,16 @@
  * The following explanations for X also apply to Y and Z multi-stepper setups.
  * Endstop offsets may be changed by 'M666 X<offset> Y<offset> Z<offset>' and stored to EEPROM.
  *
+ * This section will allow you to use extra E drivers to drive a second motor for X, Y, or Z axes.
+* For example, set X_DUAL_STEPPER_DRIVERS setting to use a second motor. If the motors need to
+ * spin in opposite directions set INVERT_X2_VS_X_DIR. If the second motor needs its own endstop
+ * set X_DUAL_ENDSTOPS. This can adjust for "racking." Use X2_USE_ENDSTOP to set the endstop plug
+ * that should be used for the second endstop. Extra endstops will appear in the output of 'M119'.
+ *
+ * Use X_DUAL_ENDSTOP_ADJUSTMENT to adjust for mechanical imperfection. After homing both motors
+ * this offset is applied to the X2 motor. To find the offset home the X axis, and measure the error
+ * in X2. Dual endstop offsets can be set at runtime with 'M666 X<offset> Y<offset> Z<offset>'.
+ *
  * - Enable INVERT_X2_VS_X_DIR if the X2 motor requires an opposite DIR signal from X.
  *
  * - Enable X_DUAL_ENDSTOPS if the second motor has its own endstop, with adjustable offset.
@@ -817,8 +846,8 @@
  *   - Use X2_USE_ENDSTOP to set the endstop plug by name. (_XMIN_, _XMAX_, _YMIN_, _YMAX_, _ZMIN_, _ZMAX_)
  */
 #if HAS_X2_STEPPER && DISABLED(DUAL_X_CARRIAGE)
-  //#define INVERT_X2_VS_X_DIR        // X2 direction signal is the opposite of X
-  //#define X_DUAL_ENDSTOPS           // X2 has its own endstop
+  #define INVERT_X2_VS_X_DIR        // X2 direction signal is the opposite of X  //TG 12/30/20
+  #define X_DUAL_ENDSTOPS           // X2 has its own endstop
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define X2_USE_ENDSTOP    _XMAX_  // X2 endstop board plug. Don't forget to enable USE_*_PLUG.
     #define X2_ENDSTOP_ADJUSTMENT  0  // X2 offset relative to X endstop
@@ -826,8 +855,8 @@
 #endif
 
 #if HAS_DUAL_Y_STEPPERS
-  //#define INVERT_Y2_VS_Y_DIR        // Y2 direction signal is the opposite of Y
-  //#define Y_DUAL_ENDSTOPS           // Y2 has its own endstop
+  #define INVERT_Y2_VS_Y_DIR    // Enable if Y2 direction signal is opposite of Y
+  #define Y_DUAL_ENDSTOPS		// Y2 has its own endstop //TG 12/30/2020
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define Y2_USE_ENDSTOP    _YMAX_  // Y2 endstop board plug. Don't forget to enable USE_*_PLUG.
     #define Y2_ENDSTOP_ADJUSTMENT  0  // Y2 offset relative to Y endstop
@@ -864,7 +893,7 @@
 // Drive the E axis with two synchronized steppers
 //#define E_DUAL_STEPPER_DRIVERS
 #if ENABLED(E_DUAL_STEPPER_DRIVERS)
-  //#define INVERT_E1_VS_E0_DIR       // E direction signals are opposites
+  //#define INVERT_E1_VS_E0_DIR   // Enable if the E motors need opposite DIR states
 #endif
 
 // Activate a solenoid on the active extruder with M380. Disable all with M381.
@@ -1099,7 +1128,7 @@
   //#define SHAPING_MENU                // Add a menu to the LCD to set shaping parameters.
 #endif
 
-#define AXIS_RELATIVE_MODES { false, false, false, false }
+#define AXIS_RELATIVE_MODES { false, false, false }
 
 // Add a Duplicate option for well-separated conjoined nozzles
 //#define MULTI_NOZZLE_DUPLICATION
@@ -1121,16 +1150,16 @@
  * Enable DISABLE_INACTIVE_* to shut down axis steppers after an idle period.
  * The Deactive Time can be overridden with M18 and M84. Set to 0 for No Timeout.
  */
-#define DEFAULT_STEPPER_DEACTIVE_TIME 120
-#define DISABLE_INACTIVE_X
-#define DISABLE_INACTIVE_Y
-#define DISABLE_INACTIVE_Z  // Disable if the nozzle could fall onto your printed part!
-//#define DISABLE_INACTIVE_I
-//#define DISABLE_INACTIVE_J
-//#define DISABLE_INACTIVE_K
-//#define DISABLE_INACTIVE_U
-//#define DISABLE_INACTIVE_V
-//#define DISABLE_INACTIVE_W
+#define DEFAULT_STEPPER_DEACTIVE_TIME 1200	//TG 12/30/2020 was 120
+#define DISABLE_INACTIVE_X true
+#define DISABLE_INACTIVE_Y true
+#define DISABLE_INACTIVE_Z false  	//TG 12/30/2020 Set 'false' if the nozzle could fall onto your printed part!
+#define DISABLE_INACTIVE_I true
+#define DISABLE_INACTIVE_J true
+#define DISABLE_INACTIVE_K true
+#define DISABLE_INACTIVE_U true
+#define DISABLE_INACTIVE_V true
+#define DISABLE_INACTIVE_W true
 
 // Default Minimum Feedrates for printing and travel moves
 #define DEFAULT_MINIMUMFEEDRATE       0.0     // (mm/s. Â°/s for rotational-only moves) Minimum feedrate. Set with M205 S.
@@ -1152,7 +1181,7 @@
  * See https://hydraraptor.blogspot.com/2010/12/frequency-limit.html
  * Use M201 F<freq> G<min%> to change limits at runtime.
  */
-//#define XY_FREQUENCY_LIMIT      10 // (Hz) Maximum frequency of small zigzag infill moves. Set with M201 F<hertz>.
+//#define XY_FREQUENCY_LIMIT      10 	//TG 12/30/2020 (Hz) Maximum frequency of small zigzag infill moves. Set with M201 F<hertz>.
 #ifdef XY_FREQUENCY_LIMIT
   #define XY_FREQUENCY_MIN_PERCENT 5 // (percent) Minimum FR percentage to apply. Set with M201 G<min%>.
 #endif
@@ -1273,7 +1302,7 @@
  * vibration and surface artifacts. The algorithm adapts to provide the best possible step smoothing at the
  * lowest stepping frequencies.
  */
-//#define ADAPTIVE_STEP_SMOOTHING
+#define ADAPTIVE_STEP_SMOOTHING	//TG 12/30/2020
 
 /**
  * Custom Microstepping
@@ -1348,7 +1377,7 @@
 // @section lcd
 
 #if HAS_MANUAL_MOVE_MENU
-  #define MANUAL_FEEDRATE { 50*60, 50*60, 4*60, 2*60 } // (mm/min) Feedrates for manual moves along X, Y, Z, E from panel
+  #define MANUAL_FEEDRATE { 50*60, 50*60, 4*60 } // (mm/min) Feedrates for manual moves along X, Y, Z, E from panel
   #define FINE_MANUAL_MOVE 0.025    // (mm) Smallest manual move (< 0.1mm) applying to Z on most machines
   #if IS_ULTIPANEL
     #define MANUAL_E_MOVES_RELATIVE // Display extruder move distance rather than "position"
@@ -1375,6 +1404,7 @@
 //
 //#define LCD_BACKLIGHT_TIMEOUT_MINS 1  // (minutes) Timeout before turning off the backlight
 
+// Add Probe Z Offset calibration to the Z Probe Offsets menu
 #if HAS_BED_PROBE && EITHER(HAS_MARLINUI_MENU, HAS_TFT_LVGL_UI)
   //#define PROBE_OFFSET_WIZARD       // Add a Probe Z Offset calibration option to the LCD menu
   #if ENABLED(PROBE_OFFSET_WIZARD)
@@ -1432,8 +1462,8 @@
   //#define SOUND_MENU_ITEM   // Add a mute option to the LCD menu
   #define SOUND_ON_DEFAULT    // Buzzer/speaker default enabled state
 
-  // The timeout to return to the status screen from sub-menus
-  //#define LCD_TIMEOUT_TO_STATUS 15000   // (ms)
+  // The timeout (in ms) to return to the status screen from sub-menus
+#define LCD_TIMEOUT_TO_STATUS 180000	//TG 12/30/2020
 
   #if ENABLED(SHOW_BOOTSCREEN)
     #define BOOTSCREEN_TIMEOUT 4000       // (ms) Total Duration to display the boot screen(s)
@@ -1443,8 +1473,7 @@
   #endif
 
   // Scroll a longer status message into view
-  //#define STATUS_MESSAGE_SCROLLING
-
+  #define STATUS_MESSAGE_SCROLLING  //TG 12/30/2020
   // Apply a timeout to low-priority status messages
   //#define STATUS_MESSAGE_TIMEOUT_SEC 30 // (seconds)
 
@@ -1454,6 +1483,17 @@
   // Show the E position (filament used) during printing
   //#define LCD_SHOW_E_TOTAL
 
+
+  // Include a page of printer information in the LCD Main Menu
+  #define LCD_INFO_MENU //TG 12/30/2020
+  #if ENABLED(LCD_INFO_MENU)
+    //#define LCD_PRINTER_INFO_IS_BOOTSCREEN // Show bootscreen(s) instead of Printer Info pages
+  #endif
+
+  // BACK menu items keep the highlight at the top
+  #define TURBO_BACK_MENU_ITEM //TG 12/30/2020
+
+
   // Display a negative temperature instead of "err"
   //#define SHOW_TEMPERATURE_BELOW_ZERO
 
@@ -1508,11 +1548,11 @@
   //#define PRINT_PROGRESS_SHOW_DECIMALS  // Show/report progress with decimal digits, not all UIs support this
 
   #if EITHER(HAS_MARLINUI_HD44780, IS_TFTGLCD_PANEL)
-    //#define LCD_PROGRESS_BAR            // Show a progress bar on HD44780 LCDs for SD printing
+    #define LCD_PROGRESS_BAR            //TG 12/30/2020 Show a progress bar on HD44780 LCDs for SD printing
     #if ENABLED(LCD_PROGRESS_BAR)
       #define PROGRESS_BAR_BAR_TIME 2000  // (ms) Amount of time to show the bar
       #define PROGRESS_BAR_MSG_TIME 3000  // (ms) Amount of time to show the status message
-      #define PROGRESS_MSG_EXPIRE      0  // (ms) Amount of time to retain the status message (0=forever)
+      #define PROGRESS_MSG_EXPIRE   0     // (ms) Amount of time to retain the status message (0=forever)
       //#define PROGRESS_MSG_ONCE         // Show the message for MSG_TIME then clear it
       //#define LCD_PROGRESS_BAR_TEST     // Add a menu item to test the progress bar
     #endif
@@ -1542,7 +1582,7 @@
 
   #define SD_PROCEDURE_DEPTH 1              // Increase if you need more nested M32 calls
 
-  #define SD_FINISHED_STEPPERRELEASE true   // Disable steppers when SD Print is finished
+  #define SD_FINISHED_STEPPERRELEASE false  //TG 12/30/2020 Disable steppers when SD Print is finished
   #define SD_FINISHED_RELEASECOMMAND "M84"  // Use "M84XYE" to keep Z enabled so your bed stays in place
 
   // Reverse SD sort to show "more recent" files first, according to the card's FAT.
@@ -1655,9 +1695,17 @@
     //#define SD_ABORT_ON_ENDSTOP_HIT_GCODE "G28XY" // G-code to run on endstop hit (e.g., "G28XY" or "G27")
   #endif
 
-  //#define SD_REPRINT_LAST_SELECTED_FILE // On print completion open the LCD Menu and select the same file
+  /**
+   * This option makes it easier to print the same SD Card file again.
+   * On print completion the LCD Menu will open with the file selected.
+   * You can just click to start the print, or navigate elsewhere.
+   */
+  //#define SD_REPRINT_LAST_SELECTED_FILE
 
-  //#define AUTO_REPORT_SD_STATUS         // Auto-report media status with 'M27 S<seconds>'
+  /**
+   * Auto-report SdCard status with M27 S<seconds>
+   */
+  #define AUTO_REPORT_SD_STATUS	//TG 1/9/2020 enabled for TFT35
 
   /**
    * Support for USB thumb drives using an Arduino USB Host Shield or
@@ -1742,7 +1790,7 @@
    *
    * :[ 'LCD', 'ONBOARD', 'CUSTOM_CABLE' ]
    */
-  //#define SDCARD_CONNECTION LCD
+  #define SDCARD_CONNECTION LCD //TG 12/30/2020
 
   // Enable if SD detect is rendered useless (e.g., by using an SD extender)
   //#define NO_SD_DETECT
@@ -1837,7 +1885,7 @@
   #define STATUS_HOTEND_ANIM          // Use a second bitmap to indicate hotend heating
   #define STATUS_BED_ANIM             // Use a second bitmap to indicate bed heating
   #define STATUS_CHAMBER_ANIM         // Use a second bitmap to indicate chamber heating
-  //#define STATUS_CUTTER_ANIM        // Use a second bitmap to indicate spindle / laser active
+  #define STATUS_CUTTER_ANIM        //TG 4/30/21 enabled Use a second bitmap to indicate spindle / laser active
   //#define STATUS_COOLER_ANIM        // Use a second bitmap to indicate laser cooling
   //#define STATUS_FLOWMETER_ANIM     // Use multiple bitmaps to indicate coolant flow
   //#define STATUS_ALT_BED_BITMAP     // Use the alternative bed bitmap
@@ -1855,8 +1903,14 @@
 #endif // HAS_MARLINUI_U8GLIB
 
 #if HAS_MARLINUI_U8GLIB || IS_DWIN_MARLINUI
-  #define MENU_HOLLOW_FRAME           // Enable to save many cycles by drawing a hollow frame on Menu Screens
-  //#define OVERLAY_GFX_REVERSE       // Swap the CW/CCW indicators in the graphics overlay
+  // Show SD percentage next to the progress bar
+  //#define SHOW_SD_PERCENT
+
+  // Enable to save many cycles by drawing a hollow frame on Menu Screens
+  #define MENU_HOLLOW_FRAME
+
+  // Swap the CW/CCW indicators in the graphics overlay
+  //#define OVERLAY_GFX_REVERSE
 #endif
 
 //
@@ -2065,11 +2119,11 @@
  *
  * Warning: Does not respect endstops!
  */
-//#define BABYSTEPPING
+#define BABYSTEPPING  //TG 5/5/2021
 #if ENABLED(BABYSTEPPING)
   //#define INTEGRATED_BABYSTEPPING         // EXPERIMENTAL integration of babystepping into the Stepper ISR
   //#define BABYSTEP_WITHOUT_HOMING
-  //#define BABYSTEP_ALWAYS_AVAILABLE       // Allow babystepping at all times (not just during movement).
+  #define BABYSTEP_ALWAYS_AVAILABLE         //TG 5/5/21 Allow babystepping at all times (not just during movement).
   //#define BABYSTEP_XY                     // Also enable X/Y Babystepping. Not supported on DELTA!
   #define BABYSTEP_INVERT_Z false           // Change if Z babysteps should go the other way
   //#define BABYSTEP_MILLIMETER_UNITS       // Specify BABYSTEP_MULTIPLICATOR_(XY|Z) in mm instead of micro-steps
@@ -2086,12 +2140,12 @@
     #endif
   #endif
 
-  //#define BABYSTEP_DISPLAY_TOTAL          // Display total babysteps since last G28
+  #define BABYSTEP_DISPLAY_TOTAL            //TG 5/5/21 Display total babysteps since last G28
 
-  //#define BABYSTEP_ZPROBE_OFFSET          // Combine M851 Z and Babystepping
+  //#define BABYSTEP_ZPROBE_OFFSET          // Combine M851 Z and Babystepping (a probe must be defined!)
   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
     //#define BABYSTEP_HOTEND_Z_OFFSET      // For multiple hotends, babystep relative Z offsets
-    //#define BABYSTEP_GFX_OVERLAY          // Enable graphical overlay on Z-offset editor
+    //#define BABYSTEP_ZPROBE_GFX_OVERLAY   // Enable graphical overlay on Z-offset editor
   #endif
 #endif
 
@@ -2112,7 +2166,7 @@
  *
  * See https://marlinfw.org/docs/features/lin_advance.html for full instructions.
  */
-//#define LIN_ADVANCE
+//#define LIN_ADVANCE	//TG 12/30/2020
 #if ENABLED(LIN_ADVANCE)
   #if ENABLED(DISTINCT_E_FACTORS)
     #define ADVANCE_K { 0.22 }    // (mm) Compression length per 1mm/s extruder speed, per extruder
@@ -2121,6 +2175,7 @@
   #endif
   //#define ADVANCE_K_EXTRA       // Add a second linear advance constant, configurable with M900 L.
   //#define LA_DEBUG              // Print debug information to serial during operation. Disable for production use.
+  //#define EXPERIMENTAL_SCURVE   // Allow S-Curve Acceleration to be used with LA.
   //#define ALLOW_LOW_EJERK       // Allow a DEFAULT_EJERK value of <10. Recommended for direct drive hotends.
   //#define EXPERIMENTAL_I2S_LA   // Allow I2S_STEPPER_STREAM to be used with LA. Performance degrades as the LA step rate reaches ~20kHz.
 #endif
@@ -2273,7 +2328,7 @@
 
     // Height above Z=0.0 to raise the nozzle. Lowering this can help the probe to heat faster.
     // Note: The Z=0.0 offset is determined by the probe Z offset (e.g., as set with M851 Z).
-    #define PTC_PROBE_HEATING_OFFSET 0.5
+    //#define PTC_PROBE_HEATING_OFFSET 0.5
   #endif
 #endif // PTC_PROBE || PTC_BED || PTC_HOTEND
 
@@ -2287,7 +2342,7 @@
 //
 // G2/G3 Arc Support
 //
-#define ARC_SUPPORT                   // Requires ~3226 bytes
+#define ARC_SUPPORT                 //TG 12/30/2020 Disable this feature to save ~3226 bytes
 #if ENABLED(ARC_SUPPORT)
   #define MIN_ARC_SEGMENT_MM      0.1 // (mm) Minimum length of each arc segment
   #define MAX_ARC_SEGMENT_MM      1.0 // (mm) Maximum length of each arc segment
@@ -2322,7 +2377,7 @@
  * and optionally G38.4 and G38.5 (probe away from target).
  * Set MULTIPLE_PROBING for G38 to probe more than once.
  */
-//#define G38_PROBE_TARGET
+#define G38_PROBE_TARGET          //TG 9/30/2022 - enabled for MPCNC using Probe Z to Max (up)
 #if ENABLED(G38_PROBE_TARGET)
   //#define G38_PROBE_AWAY        // Include G38.4 and G38.5 to probe away from target
   #define G38_MINIMUM_MOVE 0.0275 // (mm) Minimum distance that will produce a move.
@@ -2446,7 +2501,7 @@
  * Currently handles M108, M112, M410, M876
  * NOTE: Not yet implemented for all platforms.
  */
-//#define EMERGENCY_PARSER
+#define EMERGENCY_PARSER  //TG 12/30/2020 required for TFT35
 
 /**
  * Realtime Reporting (requires EMERGENCY_PARSER)
@@ -2482,8 +2537,7 @@
 #define SERIAL_OVERRUN_PROTECTION
 
 // For serial echo, the number of digits after the decimal point
-//#define SERIAL_FLOAT_PRECISION 4
-
+#define SERIAL_FLOAT_PRECISION 4  //TG 12/30/2020 required for TFT35
 /**
  * Set the number of proportional font spaces required to fill up a typical character space.
  * This can help to better align the output of commands like `G29 O` Mesh Output.
@@ -2690,7 +2744,7 @@
   //#define PARK_HEAD_ON_PAUSE                    // Park the nozzle during pause and filament change.
   //#define HOME_BEFORE_FILAMENT_CHANGE           // If needed, home before parking for filament change
 
-  //#define FILAMENT_LOAD_UNLOAD_GCODES           // Add M701/M702 Load/Unload G-codes, plus Load/Unload in the LCD Prepare menu.
+  #define FILAMENT_LOAD_UNLOAD_GCODES             //TG 1/9/2020 enabled for TFT35  Add M701/M702 Load/Unload G-codes, plus Load/Unload in the LCD Prepare menu.
   //#define FILAMENT_UNLOAD_ALL_EXTRUDERS         // Allow M702 to unload all extruders above a minimum target temp (as set by M302)
 #endif
 
@@ -3207,7 +3261,7 @@
    * Beta feature!
    * Create a 50/50 square wave step pulse optimal for stepper drivers.
    */
-  //#define SQUARE_WAVE_STEPPING
+  #define SQUARE_WAVE_STEPPING	//TG 12/30/2020
 
   /**
    * Enable M122 debugging command for TMC stepper drivers.
@@ -3268,7 +3322,20 @@
 
 //#define EXPERIMENTAL_I2CBUS
 #if ENABLED(EXPERIMENTAL_I2CBUS)
-  #define I2C_SLAVE_ADDRESS  0  // Set a value from 8 to 127 to act as a slave
+  #define I2C_SLAVE_ADDRESS  0x7F  // Set a value from 8 to 127 to act as a slave
+#endif
+
+
+
+// @section i2cbus
+// **********************************************************************************************************
+//TG 5/14/22 - I2C support for communicating between CNC control board (AVR128DB28) and Marlin (LPC1769).
+//             Currently only Slave mode is supported, Master can be added in the future if needed.
+// **********************************************************************************************************
+#ifdef TG_I2C_SUPPORT
+  #define USEDI2CDEV_M -1           // choose a Master I2C peripheral from 0 to 2 (-1 is not used)
+  #define USEDI2CDEV_S 1            // choose a Slave I2C peripheral from 0 to 2 (-1 is not used)
+  #define I2C_SLAVE_ADDRESS  0x7F   // Set a value from 8 to 127 to act as a slave
 #endif
 
 // @section photo
@@ -3316,8 +3383,8 @@
 
 // @section cnc
 
-/**
- * Spindle & Laser control
+/**********************************************************************************************************
+ * Spindle & Laser    //TG 12/16/22 modified for many options
  *
  * Add the M3, M4, and M5 commands to turn the spindle/laser on and off, and
  * to set spindle speed, spindle direction, and laser power.
@@ -3331,15 +3398,18 @@
  *
  * See https://marlinfw.org/docs/configuration/2.0.9/laser_spindle.html for more config details.
  */
-//#define SPINDLE_FEATURE
+//-------------  Select either Spindle or Laser here  ----------------------------------------------------------------------
+#define SPINDLE_FEATURE                        //TG 1/17/20 enabled to test CNC
 //#define LASER_FEATURE
 #if EITHER(SPINDLE_FEATURE, LASER_FEATURE)
-  #define SPINDLE_LASER_ACTIVE_STATE    LOW    // Set to "HIGH" if SPINDLE_LASER_ENA_PIN is active HIGH
-
-  #define SPINDLE_LASER_USE_PWM                // Enable if your controller supports setting the speed/power
+  #define SPINDLE_LASER_ACTIVE_STATE    HIGH   // Set to "HIGH" if SPINDLE_LASER_ENA_PIN is active HIGH
+  
+  //-----  Enable if your controller supports setting the speed/power via PWM signal supplied from Marlin  -----------------
+  #define SPINDLE_LASER_USE_PWM                 
   #if ENABLED(SPINDLE_LASER_USE_PWM)
     #define SPINDLE_LASER_PWM_INVERT    false  // Set to "true" if the speed/power goes up when you want it to go slower
-    #define SPINDLE_LASER_FREQUENCY     2500   // (Hz) Spindle/laser frequency (only on supported HALs: AVR, ESP32, and LPC)
+    #define SPINDLE_LASER_FREQUENCY     1000   // (Hz) Spindle/laser frequency (only on supported HALs: AVR and LPC)
+    #define SPINDLE_LASER_PWM_RES       1023   // resolution of hardware PWM for spindle255, 511, 1023, 2047 ........
                                                // ESP32: If SPINDLE_LASER_PWM_PIN is onboard then <=78125Hz. For I2S expander
                                                //  the frequency determines the PWM resolution. 2500Hz = 0-100, 977Hz = 0-255, ...
                                                //  (250000 / SPINDLE_LASER_FREQUENCY) = max value.
@@ -3370,7 +3440,11 @@
    *  - RPM     (S0 - S50000)  Best for use with a spindle
    *  - SERVO   (S0 - S180)
    */
-  #define CUTTER_POWER_UNIT PWM255
+  //#define PWM255  0
+  //#define PERCENT 1
+  //#define RPM     2
+  //#define SERVO   3
+  #define CUTTER_POWER_UNIT RPM               //TG 1/17/20 set RPM to test CNC
 
   /**
    * Relative Cutter Power
@@ -3383,12 +3457,66 @@
   //#define CUTTER_POWER_RELATIVE              // Set speed proportional to [SPEED_POWER_MIN...SPEED_POWER_MAX]
 
   #if ENABLED(SPINDLE_FEATURE)
-    //#define SPINDLE_CHANGE_DIR               // Enable if your spindle controller can change spindle direction
+    #define SPINDLE_CHANGE_DIR                 // Enable if your spindle controller can change spindle direction  //TG 1/17/20 enabled
     #define SPINDLE_CHANGE_DIR_STOP            // Enable if the spindle should stop before changing spin direction
     #define SPINDLE_INVERT_DIR          false  // Set to "true" if the spin direction is reversed
 
     #define SPINDLE_LASER_POWERUP_DELAY   5000 // (ms) Delay to allow the spindle/laser to come up to speed/power
     #define SPINDLE_LASER_POWERDOWN_DELAY 5000 // (ms) Delay to allow the spindle to stop
+    
+    //TG 9/27/21 to set whether spindle speed will use Marlin - PID control, requires USE_RPM_SENSOR enabled
+    #define SPINDLE_USE_PID  false             
+   
+    //--------------------------------------------------------------------------------------------------------------------------
+    // following are options for spindle control and RPM sensing of spindle rotation which could be
+    // used instead of the default Marlin spindle ON/OFF control or SPINDLE_LASER_USE_PWM method up above.
+    //--------------------------------------------------------------------------------------------------------------------------
+    
+    //-------------   Enable if spindle is controlled by AVR Triac board //TG 12/16/22  ----------------------------------------
+    //#define AVR_TRIAC_CONTROLLER                
+    // Marlin sends TARGET_RPM to controller, controller measures RPM sensor and returns ACTUAL_RPM to Marlin
+    // Many other features such as an extra LCD display, PID control, etc. all done via I2C from controller to Marlin.
+    // No PWM is required in Marlin. PID control handled by Triac Controller.
+    #if ENABLED(AVR_TRIAC_CONTROLLER) 
+      #define TG_I2C_SUPPORT                    // brings in TG_I2CSlave.cpp,h, calls I2C.begin, set master/slave operation, etc.
+    #endif
+
+    //-------------   Enable if spindle is controlled by VFD //TG 12/16/22  ----------------------------------------------------
+    #define VFD_CONTROLLER
+    // Marlin sends TARGET_RPM to VFD and Marlin measures RPM sensor(optional). All parameters are exchanged via
+    // Serial Comm (UART) pins P0.0(TX3)/P0.1(RX3) of UART3 connected to an RS485 converter to/from the VFD.
+    // No PWM is required in Marlin. No PID is used with VFD either. Requires USE_RPM_SENSOR to measure actual RPM.
+    #if ENABLED(VFD_CONTROLLER)       // brings in serial comm for USART3 in LPC1769 using LCD_SERIAL object            
+      #define LCD_SERIAL_PORT 3       // use LPC1769 UART #3 as it is the only available option, we access it through LCD_SERIAL
+      #define LCD_BAUDRATE 9600       // object (not SERIAL_3 because it's a Multi-Serial with 1 and 2).
+    #endif 
+    
+    //-------------  Enable reading an attached RPM sensor  //TG 12/16/22  ------------------------------------------------------
+    #define USE_RPM_SENSOR                     
+    #if ENABLED(USE_RPM_SENSOR)       // brings in rpmTimer.cpp,h for Timer3 to count pulses at CAP3.0 (P0_23)             
+    /* 
+    force RPM to be updated on display as fast as possible(once per RPM Sample Time), this may cause other functions to be delayed,
+    if any strange motion errors or lockups occur comment this out! Turning this on does not improve the RPM sampling and PID control
+    response rate, only how fast the TFT is updated. NOTE: These following two flags are checked in Conditionals_post.h so 
+    TEMP_TIMER_FREQUENCY can be redefined early on allowing code dependent on TEMP_TIMER_FREQUENCY to get the updated value!
+    */
+    //#define FAST_RPM_REPORTING                //TG 5/25/21 Added this option       
+    //#define PID_WAVEFORM_LOGGING              // uncomment if you want to log PID info to terminal for graphing
+    #endif
+
+	/** //TG 2/18/21 added
+	 * Vacuum Dust Collection Control
+	 *
+	 * Note: VACCUM_ENABLE_PIN must be defined
+	 */
+	#define VACUUM_CONTROL
+	#if ENABLED(VACUUM_CONTROL)
+	 #ifndef VACUUM_ENA_PIN
+	   #define VACUUM_ENA_PIN  P1_22
+	 #endif
+	 #define VACUUM_INVERT_DIR  false          // Set to "true" if active low required
+	#endif
+
 
     /**
      * M3/M4 Power Equation
@@ -3401,12 +3529,12 @@
      */
     #if ENABLED(SPINDLE_LASER_USE_PWM)
       #define SPEED_POWER_INTERCEPT       0    // (%) 0-100 i.e., Minimum power percentage
-      #define SPEED_POWER_MIN          5000    // (RPM)
-      #define SPEED_POWER_MAX         30000    // (RPM) SuperPID router controller 0 - 30,000 RPM
-      #define SPEED_POWER_STARTUP     25000    // (RPM) M3/M4 speed/power default (with no arguments)
+      #define SPEED_POWER_MIN             0    // (RPM)
+      #define SPEED_POWER_MAX         24000    // (RPM) SuperPID router controller 0 - 30,000 RPM
+      #define SPEED_POWER_STARTUP     20000    // (RPM) M3/M4 speed/power default (with no arguments)
     #endif
 
-  #else
+  #else   // this is for LASER
 
     #if ENABLED(SPINDLE_LASER_USE_PWM)
       #define SPEED_POWER_INTERCEPT       0    // (%) 0-100 i.e., Minimum power percentage
@@ -3489,8 +3617,9 @@
       #endif
     #endif
 
-  #endif
-#endif // SPINDLE_FEATURE || LASER_FEATURE
+  #endif //if ENABLED(SPINDLE_FEATURE) else this is for LASER
+#endif // if EITHER(SPINDLE_FEATURE, LASER_FEATURE)
+
 
 /**
  * Synchronous Laser Control with M106/M107
@@ -3598,8 +3727,7 @@
  * Enables G53 and G54-G59.3 commands to select coordinate systems
  * and G92.1 to reset the workspace to native machine space.
  */
-//#define CNC_COORDINATE_SYSTEMS
-
+#define CNC_COORDINATE_SYSTEMS	//TG 12/30/2020
 // @section reporting
 
 /**
@@ -3611,7 +3739,7 @@
 /**
  * Auto-report temperatures with M155 S<seconds>
  */
-#define AUTO_REPORT_TEMPERATURES
+#define AUTO_REPORT_TEMPERATURES	//TG 1/9/2020 enabled for TFT35
 #if ENABLED(AUTO_REPORT_TEMPERATURES) && TEMP_SENSOR_REDUNDANT
   //#define AUTO_REPORT_REDUNDANT // Include the "R" sensor in the auto-report
 #endif
@@ -3626,7 +3754,7 @@
  */
 #define EXTENDED_CAPABILITIES_REPORT
 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
-  //#define M115_GEOMETRY_REPORT
+  #define M115_GEOMETRY_REPORT  //TG 12/30/2020  required for TFT35
 #endif
 
 // @section security
@@ -3671,11 +3799,12 @@
 // @section reporting
 
 // Extra options for the M114 "Current Position" report
-//#define M114_DETAIL         // Use 'M114` for details to check planner calculations
-//#define M114_REALTIME       // Real current position based on forward kinematics
+#define M114_DETAIL         // Use 'M114` for details to check planner calculations  //TG 1/9/2020 enabled for TFT35//
+#define M114_REALTIME       // Real current position based on forward kinematics
 //#define M114_LEGACY         // M114 used to synchronize on every call. Enable if needed.
+#define REPORT_FAN_CHANGE     //TG 12/30/2020 Report the new fan speed when changed by M106 (and others)
 
-//#define REPORT_FAN_CHANGE   // Report the new fan speed when changed by M106 (and others)
+#define REPORT_SPINDLE_CHANGE     //TG 1/17/2020 Report the new spindle speed when changed by M3,4
 
 // @section gcode
 
@@ -3712,7 +3841,7 @@
  * High feedrates may cause ringing and harm print quality.
  */
 //#define PAREN_COMMENTS      // Support for parentheses-delimited comments
-//#define GCODE_MOTION_MODES  // Remember the motion mode (G0 G1 G2 G3 G5 G38.X) and apply for X Y Z E F, etc.
+#define GCODE_MOTION_MODES    //TG 12/30/2020 Remember the motion mode (G0 G1 G2 G3 G5 G38.X) and apply for X Y Z E F, etc.
 
 // Enable and set a (default) feedrate for all G0 moves
 //#define G0_FEEDRATE 3000 // (mm/min)
@@ -3749,24 +3878,24 @@
 // @section custom main menu
 
 // Custom Menu: Main Menu
-//#define CUSTOM_MENU_MAIN
+//#define CUSTOM_MENU_MAIN  //TG 12/30/2020
 #if ENABLED(CUSTOM_MENU_MAIN)
-  //#define CUSTOM_MENU_MAIN_TITLE "Custom Commands"
+  //#define CUSTOM_MENU_MAIN_TITLE "V1 Custom Menu"	//TG 12/30/2020
   #define CUSTOM_MENU_MAIN_SCRIPT_DONE "M117 User Script Done"
   #define CUSTOM_MENU_MAIN_SCRIPT_AUDIBLE_FEEDBACK
   //#define CUSTOM_MENU_MAIN_SCRIPT_RETURN   // Return to status screen after a script
   #define CUSTOM_MENU_MAIN_ONLY_IDLE         // Only show custom menu when the machine is idle
 
-  #define MAIN_MENU_ITEM_1_DESC "Home & UBL Info"
-  #define MAIN_MENU_ITEM_1_GCODE "G28\nG29 W"
+  #define MAIN_MENU_ITEM_1_DESC "Reset XYZ Coords (no motion)"	//TG 12/30/2020
+  #define MAIN_MENU_ITEM_1_GCODE "G92 X0 Y0 Z0"	//TG 12/30/2020
   //#define MAIN_MENU_ITEM_1_CONFIRM          // Show a confirmation dialog before this action
 
-  #define MAIN_MENU_ITEM_2_DESC "Preheat for " PREHEAT_1_LABEL
-  #define MAIN_MENU_ITEM_2_GCODE "M140 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\nM104 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND)
+  #define MAIN_MENU_ITEM_2_DESC "Home X&Y"	//TG 12/30/2020
+  #define MAIN_MENU_ITEM_2_GCODE "G28 X Y"	//TG 12/30/2020
   //#define MAIN_MENU_ITEM_2_CONFIRM
 
-  //#define MAIN_MENU_ITEM_3_DESC "Preheat for " PREHEAT_2_LABEL
-  //#define MAIN_MENU_ITEM_3_GCODE "M140 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\nM104 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND)
+  //#define MAIN_MENU_ITEM_3_DESC "Home Z Axis"	//TG 12/30/2020
+  //#define MAIN_MENU_ITEM_3_GCODE "G28 Z"	//TG 12/30/2020
   //#define MAIN_MENU_ITEM_3_CONFIRM
 
   //#define MAIN_MENU_ITEM_4_DESC "Heat Bed/Home/Level"
@@ -3859,15 +3988,15 @@
  * Host Prompt Support enables Marlin to use the host for user prompts so
  * filament runout and other processes can be managed from the host side.
  */
-//#define HOST_ACTION_COMMANDS
-#if ENABLED(HOST_ACTION_COMMANDS)
-  //#define HOST_PAUSE_M76                // Tell the host to pause in response to M76
-  //#define HOST_PROMPT_SUPPORT           // Initiate host prompts to get user feedback
+#define HOST_ACTION_COMMANDS  		//TG 1/9/2020 enabled for TFT35
+#if ENABLED(HOST_ACTION_COMMANDS)	//TG 1/9/2020 enabled for TFT35
+  #define HOST_PAUSE_M76			Tell the host to pause in response to M76
+  #define HOST_PROMPT_SUPPORT		//TG 1/9/2020 enabled for TFT35 Initiate host prompts to get user feedback
   #if ENABLED(HOST_PROMPT_SUPPORT)
     //#define HOST_STATUS_NOTIFICATIONS   // Send some status messages to the host as notifications
   #endif
-  //#define HOST_START_MENU_ITEM          // Add a menu item that tells the host to start
-  //#define HOST_SHUTDOWN_MENU_ITEM       // Add a menu item that tells the host to shut down
+  #define HOST_START_MENU_ITEM      // Add a menu item that tells the host to start
+  #define HOST_SHUTDOWN_MENU_ITEM   // Add a menu item that tells the host to shut down
 #endif
 
 // @section extras
@@ -4007,6 +4136,7 @@
 
 /**
  * Instant freeze / unfreeze functionality
+ * Specified pin has pullup and connecting to ground will instantly pause motion.
  * Potentially useful for emergency stop that allows being resumed.
  * @section interface
  */
@@ -4227,12 +4357,12 @@
 //
 // M42 - Set pin states
 //
-//#define DIRECT_PIN_CONTROL
+#define DIRECT_PIN_CONTROL  //TG 1/12/20 enabled needed to control some CNC devices (like Vacuum)
 
 //
 // M43 - display pin status, toggle pins, watch pins, watch endstops & toggle LED, test servo probe
 //
-//#define PINS_DEBUGGING
+#define PINS_DEBUGGING      //TG 1/12/20 enabled
 
 // Enable Tests that will run at startup and produce a report
 //#define MARLIN_TEST_BUILD
diff --git a/Marlin/Version.h b/Marlin/Version.h
index 504127e34f..3514add53b 100644
--- a/Marlin/Version.h
+++ b/Marlin/Version.h
@@ -28,7 +28,7 @@
 /**
  * Marlin release version identifier
  */
-//#define SHORT_BUILD_VERSION "bugfix-2.1.x"
+//#define SHORT_BUILD_VERSION "2.1.2"
 
 /**
  * Verbose version identifier which should contain a reference to the location
@@ -41,7 +41,7 @@
  * here we define this default string as the date where the latest release
  * version was tagged.
  */
-//#define STRING_DISTRIBUTION_DATE "2023-03-08"
+//#define STRING_DISTRIBUTION_DATE "2022-12-17"
 
 /**
  * Defines a generic printer name to be output to the LCD after booting Marlin.
diff --git a/Marlin/_Bootscreen.h b/Marlin/_Bootscreen.h
new file mode 100644
index 0000000000..fa72bc8b4a
--- /dev/null
+++ b/Marlin/_Bootscreen.h
@@ -0,0 +1,74 @@
+/**
+ * Made with Marlin Bitmap Converter
+ * http://marlinfw.org/tools/u8glib/converter.html
+ *
+ * This bitmap from the file '120 Square.bmp'
+ */
+#define CUSTOM_BOOTSCREEN_BMPWIDTH  128
+#define CUSTOM_BOOTSCREEN_BMPHEIGHT 64
+const unsigned char custom_start_bmp[] PROGMEM = {
+  0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC1,0x83,0xFF,0xC0,0x00, // ...............###########################################################################.....##.....############..............
+  0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0xE1,0xFF,0xE0,0x00, // .............############################################################################....######....############.............
+  0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xF0,0x7F,0xF0,0x00, // ............############################################################################....########.....###########............
+  0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFC,0x3F,0xF0,0x00, // ............###............................................................................###########....##########............
+  0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xFE,0x00,0x38,0x00, // ...........###............................................................................#############...........###...........
+  0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x80,0x38,0x00, // ...........###...........................................................................################.........###...........
+  0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x1F,0xC0,0x38,0x00, // ...........###.........................................................................#########...#######........###...........
+  0x00,0x1C,0x3C,0x00,0x00,0x78,0x0F,0x80,0x00,0x00,0x03,0xFE,0x0F,0xC0,0x38,0x00, // ...........###....####...................####.......#####.............................#########.....######........###...........
+  0x00,0x1C,0x3C,0x00,0x00,0x78,0x3F,0x80,0x00,0x00,0x0F,0xFC,0x07,0xC0,0x38,0x00, // ...........###....####...................####.....#######...........................##########.......#####........###...........
+  0x00,0x1C,0x3C,0x00,0x00,0xF8,0xFF,0x80,0x00,0x00,0x1F,0xFC,0x0F,0xC0,0x38,0x00, // ...........###....####..................#####...#########..........................###########......######........###...........
+  0x00,0x1C,0x3E,0x00,0x00,0xF8,0xFF,0x80,0x00,0x00,0x7F,0xF8,0x0F,0x80,0x38,0x00, // ...........###....#####.................#####...#########........................############.......#####.........###...........
+  0x00,0x1C,0x1E,0x00,0x00,0xF0,0xF7,0x80,0x00,0x01,0xFF,0xF8,0x1F,0x80,0x38,0x00, // ...........###.....####.................####....####.####......................##############......######.........###...........
+  0x00,0x1C,0x1F,0x00,0x01,0xF0,0x07,0x80,0x00,0x07,0xFF,0xF0,0x1F,0x80,0x38,0x00, // ...........###.....#####...............#####.........####....................###############.......######.........###...........
+  0x00,0x1C,0x1F,0x00,0x01,0xE0,0x07,0x80,0x00,0x1F,0xFF,0xF0,0x3F,0x80,0x38,0x00, // ...........###.....#####...............####..........####..................#################......#######.........###...........
+  0x00,0x1C,0x0F,0x00,0x03,0xE0,0x07,0x80,0x00,0x7F,0xFF,0xE0,0x7F,0x80,0x38,0x00, // ...........###......####..............#####..........####................##################......########.........###...........
+  0x00,0x1C,0x0F,0x80,0x03,0xE0,0x07,0x80,0x03,0xFF,0xFF,0xC0,0x7F,0x80,0x38,0x00, // ...........###......#####.............#####..........####.............####################.......########.........###...........
+  0x00,0x1C,0x07,0x80,0x03,0xC0,0x07,0x80,0x1F,0xFF,0xFE,0x00,0xFF,0x80,0x38,0x00, // ...........###.......####.............####...........####..........####################.........#########.........###...........
+  0x00,0x1C,0x07,0x80,0x07,0xC0,0x07,0x80,0x3F,0xFF,0xF8,0x00,0xFF,0x80,0x38,0x00, // ...........###.......####............#####...........####.........###################...........#########.........###...........
+  0x00,0x1C,0x07,0xC0,0x07,0x80,0x07,0x80,0x7F,0xFF,0xE0,0x01,0xFF,0x00,0x38,0x00, // ...........###.......#####...........####............####........##################............#########..........###...........
+  0x00,0x1C,0x03,0xC0,0x07,0x80,0x07,0x80,0x7F,0xFF,0xE0,0x01,0xFF,0x00,0x38,0x00, // ...........###........####...........####............####........##################............#########..........###...........
+  0x00,0x1C,0x03,0xE0,0x0F,0x80,0x07,0x80,0x7F,0xFF,0xC0,0x00,0xFF,0x00,0x38,0x00, // ...........###........#####.........#####............####........#################..............########..........###...........
+  0x00,0x1C,0x01,0xE0,0x0F,0x00,0x07,0x80,0x78,0x00,0x00,0x00,0xFF,0x00,0x38,0x00, // ...........###.........####.........####.............####........####...........................########..........###...........
+  0x00,0x1C,0x01,0xE0,0x1F,0x00,0x07,0x80,0x78,0x00,0x00,0x00,0xFF,0x00,0x38,0x00, // ...........###.........####........#####.............####........####...........................########..........###...........
+  0x00,0x1C,0x01,0xF0,0x1E,0x00,0x07,0x80,0x78,0x00,0x00,0x00,0xFF,0x00,0x38,0x00, // ...........###.........#####.......####..............####........####...........................########..........###...........
+  0x00,0x1C,0x00,0xF0,0x1E,0x00,0x07,0x80,0x78,0x00,0x00,0x00,0xFF,0x00,0x38,0x00, // ...........###..........####.......####..............####........####...........................########..........###...........
+  0x00,0x1C,0x00,0xF8,0x3E,0x00,0x07,0x80,0x78,0x00,0x00,0x00,0xFF,0x00,0x38,0x00, // ...........###..........#####.....#####..............####........####...........................########..........###...........
+  0x00,0x1C,0x00,0xF8,0x3C,0x00,0x07,0x80,0x7F,0xFF,0xC0,0x00,0xFF,0x00,0x38,0x00, // ...........###..........#####.....####...............####........#################..............########..........###...........
+  0x00,0x1C,0x00,0x78,0x7C,0x00,0x07,0x80,0x7F,0xFF,0xE0,0x01,0xFF,0x00,0x38,0x00, // ...........###...........####....#####...............####........##################............#########..........###...........
+  0x00,0x1C,0x00,0x7C,0x7C,0x00,0x07,0x80,0x7F,0xFF,0xE0,0x01,0xFF,0x00,0x38,0x00, // ...........###...........#####...#####...............####........##################............#########..........###...........
+  0x00,0x1C,0x00,0x3C,0x78,0x00,0x07,0x80,0x7F,0xFF,0xF0,0x01,0xFF,0x00,0x38,0x00, // ...........###............####...####................####........###################...........#########..........###...........
+  0x00,0x1C,0x00,0x3E,0xF8,0x00,0x07,0x80,0x3F,0xFF,0xFC,0x00,0xFF,0x80,0x38,0x00, // ...........###............#####.#####................####.........####################..........#########.........###...........
+  0x00,0x1C,0x00,0x3E,0xF0,0x00,0x07,0x80,0x07,0xFF,0xFF,0xC0,0x7F,0x80,0x38,0x00, // ...........###............#####.####.................####............#####################.......########.........###...........
+  0x00,0x1C,0x00,0x1F,0xF0,0x00,0x07,0x80,0x00,0xFF,0xFF,0xE0,0x7F,0x80,0x38,0x00, // ...........###.............#########.................####...............###################......########.........###...........
+  0x00,0x1C,0x00,0x1F,0xF0,0x00,0x07,0x80,0x00,0x1F,0xFF,0xE0,0x3F,0x80,0x38,0x00, // ...........###.............#########.................####..................################.......#######.........###...........
+  0x00,0x1C,0x00,0x0F,0xE0,0x00,0x07,0x80,0x00,0x07,0xFF,0xF0,0x3F,0x80,0x38,0x00, // ...........###..............#######..................####....................###############......#######.........###...........
+  0x00,0x1C,0x00,0x0F,0xE0,0x00,0x07,0x80,0x00,0x01,0xFF,0xF8,0x1F,0x80,0x38,0x00, // ...........###..............#######..................####......................##############......######.........###...........
+  0x00,0x1C,0x00,0x0F,0xC0,0x00,0x07,0x80,0x00,0x00,0x7F,0xF8,0x0F,0x80,0x38,0x00, // ...........###..............######...................####........................############.......#####.........###...........
+  0x00,0x1C,0x00,0x07,0xC0,0x00,0x07,0x80,0x00,0x00,0x3F,0xFC,0x0F,0xC0,0x38,0x00, // ...........###...............#####...................####.........................############......######........###...........
+  0x00,0x1C,0x00,0x07,0xC0,0x00,0x07,0x80,0x00,0x00,0x0F,0xFC,0x07,0xC0,0x38,0x00, // ...........###...............#####...................####...........................##########.......#####........###...........
+  0x00,0x1C,0x00,0x03,0x80,0x00,0x07,0x80,0x00,0x00,0x07,0xFE,0x07,0xC0,0x38,0x00, // ...........###................###....................####............................##########......#####........###...........
+  0x00,0x1C,0x00,0x03,0x80,0x00,0x03,0x00,0x00,0x00,0x01,0xFE,0x0F,0xC0,0x38,0x00, // ...........###................###.....................##...............................########.....######........###...........
+  0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x3F,0x80,0x38,0x00, // ...........###..........................................................................########..#######.........###...........
+  0x00,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x00,0x38,0x00, // ...........###...........................................................................###############..........###...........
+  0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFC,0x00,0x78,0x00, // ............###............................................................................###########...........####...........
+  0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,0xF0,0x3F,0xF8,0x00, // ............############################################################################....########......###########...........
+  0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0xE0,0xFF,0xF0,0x00, // .............############################################################################....######.....############............
+  0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC3,0x83,0xFF,0xE0,0x00, // ..............############################################################################....###.....#############.............
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ................................................................................................................................
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ................................................................................................................................
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ................................................................................................................................
+  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ................................................................................................................................
+  0x00,0x0F,0xF4,0x03,0x07,0xC2,0x80,0x67,0xF9,0xFF,0x3E,0x0A,0x01,0x83,0xE0,0x00, // ............########.#........##.....#####....#.#........##..########..#########..#####.....#.#........##.....#####.............
+  0x00,0x1F,0xF6,0x03,0x1F,0xE6,0xC0,0x6F,0xFB,0xFF,0x7F,0x1B,0x01,0x8F,0xF0,0x00, // ...........#########.##.......##...########..##.##.......##.#########.##########.#######...##.##.......##...########............
+  0x00,0x18,0x07,0x03,0x38,0x76,0xE0,0x6C,0x03,0x00,0x63,0x1B,0x81,0x9C,0x18,0x00, // ...........##........###......##..###....###.##.###......##.##........##.........##...##...##.###......##..###.....##...........
+  0x00,0x18,0x07,0x83,0x30,0x06,0xF0,0x6C,0x03,0x00,0x61,0x9B,0xC1,0x98,0x00,0x00, // ...........##........####.....##..##.........##.####.....##.##........##.........##....##..##.####.....##..##...................
+  0x00,0x18,0x07,0xC3,0x60,0x06,0xF8,0x6C,0x03,0x00,0x61,0x9B,0xE1,0xB0,0x00,0x00, // ...........##........#####....##.##..........##.#####....##.##........##.........##....##..##.#####....##.##....................
+  0x00,0x18,0x06,0xE3,0x60,0x06,0xDC,0x6C,0x03,0x00,0x63,0x9B,0x71,0xB0,0x00,0x00, // ...........##........##.###...##.##..........##.##.###...##.##........##.........##...###..##.##.###...##.##....................
+  0x00,0x1F,0xE6,0x73,0x61,0xE6,0xCE,0x6F,0xF3,0xFC,0x7F,0x1B,0x39,0xB0,0xF0,0x00, // ...........########..##..###..##.##....####..##.##..###..##.########..########...#######...##.##..###..##.##....####............
+  0x00,0x18,0x06,0x3B,0x61,0xF6,0xC7,0x6C,0x03,0x00,0x7E,0x1B,0x1D,0xB0,0xF8,0x00, // ...........##........##...###.##.##....#####.##.##...###.##.##........##.........######....##.##...###.##.##....#####...........
+  0x00,0x18,0x06,0x1F,0x60,0x36,0xC3,0xEC,0x03,0x00,0x67,0x1B,0x0F,0xB0,0x18,0x00, // ...........##........##....#####.##.......##.##.##....#####.##........##.........##..###...##.##....#####.##.......##...........
+  0x00,0x18,0x06,0x0F,0x30,0x36,0xC1,0xEC,0x03,0x00,0x63,0x9B,0x07,0x98,0x18,0x00, // ...........##........##.....####..##......##.##.##.....####.##........##.........##...###..##.##.....####..##......##...........
+  0x00,0x18,0x06,0x07,0x18,0x76,0xC0,0xEC,0x03,0x00,0x61,0x9B,0x03,0x8C,0x38,0x00, // ...........##........##......###...##....###.##.##......###.##........##.........##....##..##.##......###...##....###...........
+  0x00,0x1F,0xF6,0x03,0x0F,0xE6,0xC0,0x6F,0xFB,0xFE,0x60,0xDB,0x01,0x87,0xF0,0x00, // ...........#########.##.......##....#######..##.##.......##.#########.#########..##.....##.##.##.......##....#######............
+  0x00,0x0F,0xF6,0x01,0x07,0xC6,0xC0,0x27,0xF9,0xFE,0x60,0xDB,0x00,0x83,0xE0,0x00  // ............########.##........#.....#####...##.##........#..########..########..##.....##.##.##........#.....#####.............
+};
diff --git a/Marlin/src/HAL/AVR/watchdog.cpp b/Marlin/src/HAL/AVR/watchdog.cpp
new file mode 100644
index 0000000000..3f10c4adff
--- /dev/null
+++ b/Marlin/src/HAL/AVR/watchdog.cpp
@@ -0,0 +1,70 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef __AVR__
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include "watchdog.h"
+
+#include "../../MarlinCore.h"
+
+// Initialize watchdog with 8s timeout, if possible. Otherwise, make it 4s.
+void watchdog_init() {
+  #if ENABLED(WATCHDOG_DURATION_8S) && defined(WDTO_8S)
+    #define WDTO_NS WDTO_8S
+  #else
+    #define WDTO_NS WDTO_4S
+  #endif
+  #if ENABLED(WATCHDOG_RESET_MANUAL)
+    // Enable the watchdog timer, but only for the interrupt.
+    // Take care, as this requires the correct order of operation, with interrupts disabled.
+    // See the datasheet of any AVR chip for details.
+    wdt_reset();
+    cli();
+    _WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);
+    _WD_CONTROL_REG = _BV(WDIE) | (WDTO_NS & 0x07) | ((WDTO_NS & 0x08) << 2); // WDTO_NS directly does not work. bit 0-2 are consecutive in the register but the highest value bit is at bit 5
+                                                                              // So worked for up to WDTO_2S
+    sei();
+    wdt_reset();
+  #else
+    wdt_enable(WDTO_NS); // The function handles the upper bit correct.
+  #endif
+  //delay(10000); // test it!
+}
+
+//===========================================================================
+//=================================== ISR ===================================
+//===========================================================================
+
+// Watchdog timer interrupt, called if main program blocks >4sec and manual reset is enabled.
+#if ENABLED(WATCHDOG_RESET_MANUAL)
+  ISR(WDT_vect) {
+    sei();  // With the interrupt driven serial we need to allow interrupts.
+    SERIAL_ERROR_MSG(STR_WATCHDOG_FIRED);
+    minkill();  // interrupt-safe final kill and infinite loop
+  }
+#endif
+
+#endif // USE_WATCHDOG
+#endif // __AVR__
diff --git a/Marlin/src/HAL/AVR/watchdog.h b/Marlin/src/HAL/AVR/watchdog.h
new file mode 100644
index 0000000000..a16c88b35e
--- /dev/null
+++ b/Marlin/src/HAL/AVR/watchdog.h
@@ -0,0 +1,31 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include <avr/wdt.h>
+
+// Initialize watchdog with a 4 second interrupt time
+void watchdog_init();
+
+// Reset watchdog. MUST be called at least every 4 seconds after the
+// first watchdog_init or AVR will go into emergency procedures.
+inline void HAL_watchdog_refresh() { wdt_reset(); }
diff --git a/Marlin/src/HAL/DUE/HAL_MinSerial.cpp b/Marlin/src/HAL/DUE/HAL_MinSerial.cpp
new file mode 100644
index 0000000000..93c4ed67d6
--- /dev/null
+++ b/Marlin/src/HAL/DUE/HAL_MinSerial.cpp
@@ -0,0 +1,91 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef ARDUINO_ARCH_SAM
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(POSTMORTEM_DEBUGGING)
+
+#include "../shared/HAL_MinSerial.h"
+
+#include <stdarg.h>
+
+static void TXBegin() {
+  // Disable UART interrupt in NVIC
+  NVIC_DisableIRQ( UART_IRQn );
+
+  // We NEED memory barriers to ensure Interrupts are actually disabled!
+  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
+  __DSB();
+  __ISB();
+
+  // Disable clock
+  pmc_disable_periph_clk( ID_UART );
+
+  // Configure PMC
+  pmc_enable_periph_clk( ID_UART );
+
+  // Disable PDC channel
+  UART->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
+
+  // Reset and disable receiver and transmitter
+  UART->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX | UART_CR_RXDIS | UART_CR_TXDIS;
+
+  // Configure mode: 8bit, No parity, 1 bit stop
+  UART->UART_MR = UART_MR_CHMODE_NORMAL | US_MR_CHRL_8_BIT | US_MR_NBSTOP_1_BIT | UART_MR_PAR_NO;
+
+  // Configure baudrate (asynchronous, no oversampling) to BAUDRATE bauds
+  UART->UART_BRGR = (SystemCoreClock / (BAUDRATE << 4));
+
+  // Enable receiver and transmitter
+  UART->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
+}
+
+// A SW memory barrier, to ensure GCC does not overoptimize loops
+#define sw_barrier() __asm__ volatile("": : :"memory");
+static void TX(char c) {
+  while (!(UART->UART_SR & UART_SR_TXRDY)) { WDT_Restart(WDT); sw_barrier(); };
+  UART->UART_THR = c;
+}
+
+void install_min_serial() {
+  HAL_min_serial_init = &TXBegin;
+  HAL_min_serial_out = &TX;
+}
+
+#if DISABLED(DYNAMIC_VECTORTABLE)
+extern "C" {
+  __attribute__((naked)) void JumpHandler_ASM() {
+    __asm__ __volatile__ (
+      "b CommonHandler_ASM\n"
+    );
+  }
+  void __attribute__((naked, alias("JumpHandler_ASM"))) HardFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) BusFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) UsageFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) MemManage_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) NMI_Handler();
+}
+#endif
+
+#endif // POSTMORTEM_DEBUGGING
+#endif // ARDUINO_ARCH_SAM
diff --git a/Marlin/src/HAL/DUE/watchdog.cpp b/Marlin/src/HAL/DUE/watchdog.cpp
new file mode 100644
index 0000000000..e144db8291
--- /dev/null
+++ b/Marlin/src/HAL/DUE/watchdog.cpp
@@ -0,0 +1,114 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef ARDUINO_ARCH_SAM
+
+#include "../../inc/MarlinConfig.h"
+#include "../../MarlinCore.h"
+#include "watchdog.h"
+
+// Override Arduino runtime to either config or disable the watchdog
+//
+// We need to configure the watchdog as soon as possible in the boot
+// process, because watchdog initialization at hardware reset on SAM3X8E
+// is unreliable, and there is risk of unintended resets if we delay
+// that initialization to a later time.
+void watchdogSetup() {
+
+  #if ENABLED(USE_WATCHDOG)
+
+    // 4 seconds timeout
+    uint32_t timeout = TERN(WATCHDOG_DURATION_8S, 8000, 4000);
+
+    // Calculate timeout value in WDT counter ticks: This assumes
+    // the slow clock is running at 32.768 kHz watchdog
+    // frequency is therefore 32768 / 128 = 256 Hz
+    timeout = (timeout << 8) / 1000;
+    if (timeout == 0)
+      timeout = 1;
+    else if (timeout > 0xFFF)
+      timeout = 0xFFF;
+
+    // We want to enable the watchdog with the specified timeout
+    uint32_t value =
+      WDT_MR_WDV(timeout) |               // With the specified timeout
+      WDT_MR_WDD(timeout) |               // and no invalid write window
+    #if !(SAMV70 || SAMV71 || SAME70 || SAMS70)
+      WDT_MR_WDRPROC   |                  // WDT fault resets processor only - We want
+                                          // to keep PIO controller state
+    #endif
+      WDT_MR_WDDBGHLT  |                  // WDT stops in debug state.
+      WDT_MR_WDIDLEHLT;                   // WDT stops in idle state.
+
+    #if ENABLED(WATCHDOG_RESET_MANUAL)
+      // We enable the watchdog timer, but only for the interrupt.
+
+      // Configure WDT to only trigger an interrupt
+      value |= WDT_MR_WDFIEN;             // Enable WDT fault interrupt.
+
+      // Disable WDT interrupt (just in case, to avoid triggering it!)
+      NVIC_DisableIRQ(WDT_IRQn);
+
+      // We NEED memory barriers to ensure Interrupts are actually disabled!
+      // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
+      __DSB();
+      __ISB();
+
+      // Initialize WDT with the given parameters
+      WDT_Enable(WDT, value);
+
+      // Configure and enable WDT interrupt.
+      NVIC_ClearPendingIRQ(WDT_IRQn);
+      NVIC_SetPriority(WDT_IRQn, 0); // Use highest priority, so we detect all kinds of lockups
+      NVIC_EnableIRQ(WDT_IRQn);
+
+    #else
+
+      // a WDT fault triggers a reset
+      value |= WDT_MR_WDRSTEN;
+
+      // Initialize WDT with the given parameters
+      WDT_Enable(WDT, value);
+
+    #endif
+
+    // Reset the watchdog
+    WDT_Restart(WDT);
+
+  #else
+
+    // Make sure to completely disable the Watchdog
+    WDT_Disable(WDT);
+
+  #endif
+}
+
+#if ENABLED(USE_WATCHDOG)
+  // Initialize watchdog - On SAM3X, Watchdog was already configured
+  //  and enabled or disabled at startup, so no need to reconfigure it
+  //  here.
+  void watchdog_init() {
+    // Reset watchdog to start clean
+    WDT_Restart(WDT);
+  }
+#endif // USE_WATCHDOG
+
+#endif
diff --git a/Marlin/src/HAL/DUE/watchdog.h b/Marlin/src/HAL/DUE/watchdog.h
new file mode 100644
index 0000000000..5725a10007
--- /dev/null
+++ b/Marlin/src/HAL/DUE/watchdog.h
@@ -0,0 +1,33 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+// Arduino Due core now has watchdog support
+
+#include "HAL.h"
+
+// Initialize watchdog with a 4 second interrupt time
+void watchdog_init();
+
+// Reset watchdog. MUST be called at least every 4 seconds after the
+// first watchdog_init or AVR will go into emergency procedures.
+inline void HAL_watchdog_refresh() { watchdogReset(); }
diff --git a/Marlin/src/HAL/ESP32/watchdog.cpp b/Marlin/src/HAL/ESP32/watchdog.cpp
new file mode 100644
index 0000000000..5ec03c4607
--- /dev/null
+++ b/Marlin/src/HAL/ESP32/watchdog.cpp
@@ -0,0 +1,42 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef ARDUINO_ARCH_ESP32
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#define WDT_TIMEOUT_US TERN(WATCHDOG_DURATION_8S, 8000000, 4000000) // 4 or 8 second timeout
+
+#include "watchdog.h"
+
+void watchdogSetup() {
+  // do whatever. don't remove this function.
+}
+
+void watchdog_init() {
+  // TODO
+}
+
+#endif // USE_WATCHDOG
+
+#endif // ARDUINO_ARCH_ESP32
diff --git a/Marlin/src/HAL/ESP32/watchdog.h b/Marlin/src/HAL/ESP32/watchdog.h
new file mode 100644
index 0000000000..43db813076
--- /dev/null
+++ b/Marlin/src/HAL/ESP32/watchdog.h
@@ -0,0 +1,38 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#ifdef __cplusplus
+  extern "C" {
+#endif
+
+  esp_err_t esp_task_wdt_reset();
+
+#ifdef __cplusplus
+  }
+#endif
+
+// Initialize watchdog with a 4 second interrupt time
+void watchdog_init();
+
+// Reset watchdog.
+inline void HAL_watchdog_refresh() { esp_task_wdt_reset(); }
diff --git a/Marlin/src/HAL/LINUX/watchdog.cpp b/Marlin/src/HAL/LINUX/watchdog.cpp
new file mode 100644
index 0000000000..84202e48b6
--- /dev/null
+++ b/Marlin/src/HAL/LINUX/watchdog.cpp
@@ -0,0 +1,37 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef __PLAT_LINUX__
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include "watchdog.h"
+
+#define WDT_TIMEOUT_US TERN(WATCHDOG_DURATION_8S, 8000000, 4000000) // 4 or 8 second timeout
+
+void watchdog_init() {}
+void HAL_watchdog_refresh() {}
+
+#endif
+
+#endif // __PLAT_LINUX__
diff --git a/Marlin/src/HAL/LINUX/watchdog.h b/Marlin/src/HAL/LINUX/watchdog.h
new file mode 100644
index 0000000000..49a0d9c631
--- /dev/null
+++ b/Marlin/src/HAL/LINUX/watchdog.h
@@ -0,0 +1,25 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+void watchdog_init();
+void HAL_watchdog_refresh();
diff --git a/Marlin/src/HAL/LPC1768/HAL_MinSerial.cpp b/Marlin/src/HAL/LPC1768/HAL_MinSerial.cpp
new file mode 100644
index 0000000000..57065c49ac
--- /dev/null
+++ b/Marlin/src/HAL/LPC1768/HAL_MinSerial.cpp
@@ -0,0 +1,51 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef TARGET_LPC1768
+
+#include "../../inc/MarlinConfig.h"
+#include "HAL.h"
+
+#if ENABLED(POSTMORTEM_DEBUGGING)
+
+#include "../shared/HAL_MinSerial.h"
+#include <debug_frmwrk.h>
+
+static void TX(char c) { _DBC(c); }
+void install_min_serial() { HAL_min_serial_out = &TX; }
+
+#if DISABLED(DYNAMIC_VECTORTABLE)
+extern "C" {
+  __attribute__((naked)) void JumpHandler_ASM() {
+    __asm__ __volatile__ (
+      "b CommonHandler_ASM\n"
+    );
+  }
+  void __attribute__((naked, alias("JumpHandler_ASM"))) HardFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) BusFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) UsageFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) MemManage_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"))) NMI_Handler();
+}
+#endif
+
+#endif // POSTMORTEM_DEBUGGING
+#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/main.cpp b/Marlin/src/HAL/LPC1768/main.cpp
index 419c99793f..b818493de2 100644
--- a/Marlin/src/HAL/LPC1768/main.cpp
+++ b/Marlin/src/HAL/LPC1768/main.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
diff --git a/Marlin/src/HAL/LPC1768/watchdog.cpp b/Marlin/src/HAL/LPC1768/watchdog.cpp
new file mode 100644
index 0000000000..f23ccf5b51
--- /dev/null
+++ b/Marlin/src/HAL/LPC1768/watchdog.cpp
@@ -0,0 +1,72 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef TARGET_LPC1768
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include <lpc17xx_wdt.h>
+#include "watchdog.h"
+
+#define WDT_TIMEOUT_US TERN(WATCHDOG_DURATION_8S, 8000000, 4000000) // 4 or 8 second timeout
+
+void watchdog_init() {
+  #if ENABLED(WATCHDOG_RESET_MANUAL)
+    // We enable the watchdog timer, but only for the interrupt.
+
+    // Configure WDT to only trigger an interrupt
+    // Disable WDT interrupt (just in case, to avoid triggering it!)
+    NVIC_DisableIRQ(WDT_IRQn);
+
+    // We NEED memory barriers to ensure Interrupts are actually disabled!
+    // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
+    __DSB();
+    __ISB();
+
+    // Configure WDT to only trigger an interrupt
+    // Initialize WDT with the given parameters
+    WDT_Init(WDT_CLKSRC_IRC, WDT_MODE_INT_ONLY);
+
+    // Configure and enable WDT interrupt.
+    NVIC_ClearPendingIRQ(WDT_IRQn);
+    NVIC_SetPriority(WDT_IRQn, 0); // Use highest priority, so we detect all kinds of lockups
+    NVIC_EnableIRQ(WDT_IRQn);
+  #else
+    WDT_Init(WDT_CLKSRC_IRC, WDT_MODE_RESET);
+  #endif
+  WDT_Start(WDT_TIMEOUT_US);
+}
+
+void HAL_watchdog_refresh() {
+  WDT_Feed();
+  #if DISABLED(PINS_DEBUGGING) && PIN_EXISTS(LED)
+    TOGGLE(LED_PIN);  // heartbeat indicator
+  #endif
+}
+
+// Timeout state
+bool watchdog_timed_out() { return TEST(WDT_ReadTimeOutFlag(), 0); }
+void watchdog_clear_timeout_flag() { WDT_ClrTimeOutFlag(); }
+
+#endif // USE_WATCHDOG
+#endif // TARGET_LPC1768
diff --git a/Marlin/src/HAL/LPC1768/watchdog.h b/Marlin/src/HAL/LPC1768/watchdog.h
new file mode 100644
index 0000000000..c843f0ed55
--- /dev/null
+++ b/Marlin/src/HAL/LPC1768/watchdog.h
@@ -0,0 +1,28 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+void watchdog_init();
+void HAL_watchdog_refresh();
+
+bool watchdog_timed_out();
+void watchdog_clear_timeout_flag();
diff --git a/Marlin/src/HAL/NATIVE_SIM/watchdog.h b/Marlin/src/HAL/NATIVE_SIM/watchdog.h
new file mode 100644
index 0000000000..4e404c3887
--- /dev/null
+++ b/Marlin/src/HAL/NATIVE_SIM/watchdog.h
@@ -0,0 +1,27 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#define WDT_TIMEOUT   4000000 // 4 second timeout
+
+void watchdog_init();
+void HAL_watchdog_refresh();
diff --git a/Marlin/src/HAL/SAMD51/watchdog.cpp b/Marlin/src/HAL/SAMD51/watchdog.cpp
new file mode 100644
index 0000000000..9de451836a
--- /dev/null
+++ b/Marlin/src/HAL/SAMD51/watchdog.cpp
@@ -0,0 +1,54 @@
+/**
+ * Marlin 3D Printer Firmware
+ *
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef __SAMD51__
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include "watchdog.h"
+
+#define WDT_TIMEOUT_REG TERN(WATCHDOG_DURATION_8S, WDT_CONFIG_PER_CYC8192, WDT_CONFIG_PER_CYC4096) // 4 or 8 second timeout
+
+void watchdog_init() {
+  // The low-power oscillator used by the WDT runs at 32,768 Hz with
+  // a 1:32 prescale, thus 1024 Hz, though probably not super precise.
+
+  // Setup WDT clocks
+  MCLK->APBAMASK.bit.OSC32KCTRL_ = true;
+  MCLK->APBAMASK.bit.WDT_ = true;
+  OSC32KCTRL->OSCULP32K.bit.EN1K = true;      // Enable out 1K (this is what WDT uses)
+
+  WDT->CTRLA.bit.ENABLE = false;              // Disable watchdog for config
+  SYNC(WDT->SYNCBUSY.bit.ENABLE);
+
+  WDT->INTENCLR.reg = WDT_INTENCLR_EW;        // Disable early warning interrupt
+  WDT->CONFIG.reg = WDT_TIMEOUT_REG;          // Set a 4s or 8s period for chip reset
+
+  HAL_watchdog_refresh();
+
+  WDT->CTRLA.reg = WDT_CTRLA_ENABLE;          // Start watchdog now in normal mode
+  SYNC(WDT->SYNCBUSY.bit.ENABLE);
+}
+
+#endif // USE_WATCHDOG
+
+#endif // __SAMD51__
diff --git a/Marlin/src/HAL/SAMD51/watchdog.h b/Marlin/src/HAL/SAMD51/watchdog.h
new file mode 100644
index 0000000000..2cd4788229
--- /dev/null
+++ b/Marlin/src/HAL/SAMD51/watchdog.h
@@ -0,0 +1,31 @@
+/**
+ * Marlin 3D Printer Firmware
+ *
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * SAMD51 HAL developed by Giuliano Zaro (AKA GMagician)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+// Initialize watchdog with a 4 second interrupt time
+void watchdog_init();
+
+// Reset watchdog. MUST be called at least every 4 seconds after the
+// first watchdog_init or SAMD will go into emergency procedures.
+inline void HAL_watchdog_refresh() {
+  SYNC(WDT->SYNCBUSY.bit.CLEAR);        // Test first if previous is 'ongoing' to save time waiting for command execution
+  WDT->CLEAR.reg = WDT_CLEAR_CLEAR_KEY;
+}
diff --git a/Marlin/src/HAL/STM32/HAL_MinSerial.cpp b/Marlin/src/HAL/STM32/HAL_MinSerial.cpp
new file mode 100644
index 0000000000..b6e86b72da
--- /dev/null
+++ b/Marlin/src/HAL/STM32/HAL_MinSerial.cpp
@@ -0,0 +1,154 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2017 Victor Perez
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#include "../platforms.h"
+
+#ifdef HAL_STM32
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(POSTMORTEM_DEBUGGING)
+
+#include "../shared/HAL_MinSerial.h"
+#include "watchdog.h"
+
+/* Instruction Synchronization Barrier */
+#define isb() __asm__ __volatile__ ("isb" : : : "memory")
+
+/* Data Synchronization Barrier */
+#define dsb() __asm__ __volatile__ ("dsb" : : : "memory")
+
+// Dumb mapping over the registers of a USART device on STM32
+struct USARTMin {
+  volatile uint32_t SR;
+  volatile uint32_t DR;
+  volatile uint32_t BRR;
+  volatile uint32_t CR1;
+  volatile uint32_t CR2;
+};
+
+#if WITHIN(SERIAL_PORT, 1, 6)
+  // Depending on the CPU, the serial port is different for USART1
+  static const uintptr_t regsAddr[] = {
+    TERN(STM32F1xx, 0x40013800, 0x40011000), // USART1
+    0x40004400, // USART2
+    0x40004800, // USART3
+    0x40004C00, // UART4_BASE
+    0x40005000, // UART5_BASE
+    0x40011400  // USART6
+  };
+  static USARTMin * regs = (USARTMin*)regsAddr[SERIAL_PORT - 1];
+#endif
+
+static void TXBegin() {
+  #if !WITHIN(SERIAL_PORT, 1, 6)
+    #warning "Using POSTMORTEM_DEBUGGING requires a physical U(S)ART hardware in case of severe error."
+    #warning "Disabling the severe error reporting feature currently because the used serial port is not a HW port."
+  #else
+    // This is common between STM32F1/STM32F2 and STM32F4
+    const int nvicUART[] = { /* NVIC_USART1 */ 37, /* NVIC_USART2 */ 38, /* NVIC_USART3 */ 39, /* NVIC_UART4 */ 52, /* NVIC_UART5 */ 53, /* NVIC_USART6 */ 71 };
+    int nvicIndex = nvicUART[SERIAL_PORT - 1];
+
+    struct NVICMin {
+      volatile uint32_t ISER[32];
+      volatile uint32_t ICER[32];
+    };
+
+    NVICMin *nvicBase = (NVICMin*)0xE000E100;
+    SBI32(nvicBase->ICER[nvicIndex >> 5], nvicIndex & 0x1F);
+
+    // We NEED memory barriers to ensure Interrupts are actually disabled!
+    // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
+    dsb();
+    isb();
+
+    // Example for USART1 disable:  (RCC->APB2ENR &= ~(RCC_APB2ENR_USART1EN))
+    // Too difficult to reimplement here, let's query the STM32duino macro here
+    #if SERIAL_PORT == 1
+      __HAL_RCC_USART1_CLK_DISABLE();
+      __HAL_RCC_USART1_CLK_ENABLE();
+    #elif SERIAL_PORT == 2
+      __HAL_RCC_USART2_CLK_DISABLE();
+      __HAL_RCC_USART2_CLK_ENABLE();
+    #elif SERIAL_PORT == 3
+      __HAL_RCC_USART3_CLK_DISABLE();
+      __HAL_RCC_USART3_CLK_ENABLE();
+    #elif SERIAL_PORT == 4
+      __HAL_RCC_UART4_CLK_DISABLE(); // BEWARE: UART4 and not USART4 here
+      __HAL_RCC_UART4_CLK_ENABLE();
+    #elif SERIAL_PORT == 5
+      __HAL_RCC_UART5_CLK_DISABLE(); // BEWARE: UART5 and not USART5 here
+      __HAL_RCC_UART5_CLK_ENABLE();
+    #elif SERIAL_PORT == 6
+      __HAL_RCC_USART6_CLK_DISABLE();
+      __HAL_RCC_USART6_CLK_ENABLE();
+    #endif
+
+    uint32_t brr = regs->BRR;
+    regs->CR1 = 0; // Reset the USART
+    regs->CR2 = 0; // 1 stop bit
+
+    // If we don't touch the BRR (baudrate register), we don't need to recompute.
+    regs->BRR = brr;
+
+    regs->CR1 = _BV(3) | _BV(13); // 8 bits, no parity, 1 stop bit (TE | UE)
+  #endif
+}
+
+// A SW memory barrier, to ensure GCC does not overoptimize loops
+#define sw_barrier() __asm__ volatile("": : :"memory");
+static void TX(char c) {
+  #if WITHIN(SERIAL_PORT, 1, 6)
+    constexpr uint32_t usart_sr_txe = _BV(7);
+    while (!(regs->SR & usart_sr_txe)) {
+      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+      sw_barrier();
+    }
+    regs->DR = c;
+  #else
+    // Let's hope a mystical guru will fix this, one day by writing interrupt-free USB CDC ACM code (or, at least, by polling the registers since interrupt will be queued but will never trigger)
+    // For now, it's completely lost to oblivion.
+  #endif
+}
+
+void install_min_serial() {
+  HAL_min_serial_init = &TXBegin;
+  HAL_min_serial_out = &TX;
+}
+
+#if NONE(DYNAMIC_VECTORTABLE, STM32F0xx, STM32G0xx) // Cortex M0 can't jump to a symbol that's too far from the current function, so we work around this in exception_arm.cpp
+extern "C" {
+  __attribute__((naked)) void JumpHandler_ASM() {
+    __asm__ __volatile__ (
+      "b CommonHandler_ASM\n"
+    );
+  }
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) HardFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) BusFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) UsageFault_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) MemManage_Handler();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) NMI_Handler();
+}
+#endif
+
+#endif // POSTMORTEM_DEBUGGING
+#endif // HAL_STM32
diff --git a/Marlin/src/HAL/STM32/watchdog.cpp b/Marlin/src/HAL/STM32/watchdog.cpp
new file mode 100644
index 0000000000..1eccdec498
--- /dev/null
+++ b/Marlin/src/HAL/STM32/watchdog.cpp
@@ -0,0 +1,52 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../platforms.h"
+
+#ifdef HAL_STM32
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#define WDT_TIMEOUT_US TERN(WATCHDOG_DURATION_8S, 8000000, 4000000) // 4 or 8 second timeout
+
+#include "../../inc/MarlinConfig.h"
+
+#include "watchdog.h"
+#include <IWatchdog.h>
+
+void watchdog_init() {
+  #if DISABLED(DISABLE_WATCHDOG_INIT)
+    IWatchdog.begin(WDT_TIMEOUT_US);
+  #endif
+}
+
+void HAL_watchdog_refresh() {
+  IWatchdog.reload();
+  #if DISABLED(PINS_DEBUGGING) && PIN_EXISTS(LED)
+    TOGGLE(LED_PIN);  // heartbeat indicator
+  #endif
+}
+
+#endif // USE_WATCHDOG
+#endif // HAL_STM32
diff --git a/Marlin/src/HAL/STM32/watchdog.h b/Marlin/src/HAL/STM32/watchdog.h
new file mode 100644
index 0000000000..49a0d9c631
--- /dev/null
+++ b/Marlin/src/HAL/STM32/watchdog.h
@@ -0,0 +1,25 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+void watchdog_init();
+void HAL_watchdog_refresh();
diff --git a/Marlin/src/HAL/STM32F1/HAL_MinSerial.cpp b/Marlin/src/HAL/STM32F1/HAL_MinSerial.cpp
new file mode 100644
index 0000000000..0fc3d014d4
--- /dev/null
+++ b/Marlin/src/HAL/STM32F1/HAL_MinSerial.cpp
@@ -0,0 +1,118 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2017 Victor Perez
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef __STM32F1__
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(POSTMORTEM_DEBUGGING)
+
+#include "../shared/HAL_MinSerial.h"
+#include "watchdog.h"
+
+#include <libmaple/usart.h>
+#include <libmaple/rcc.h>
+#include <libmaple/nvic.h>
+
+/* Instruction Synchronization Barrier */
+#define isb() __asm__ __volatile__ ("isb" : : : "memory")
+
+/* Data Synchronization Barrier */
+#define dsb() __asm__ __volatile__ ("dsb" : : : "memory")
+
+static void TXBegin() {
+  #if !WITHIN(SERIAL_PORT, 1, 6)
+    #warning "Using POSTMORTEM_DEBUGGING requires a physical U(S)ART hardware in case of severe error."
+    #warning "Disabling the severe error reporting feature currently because the used serial port is not a HW port."
+  #else
+    // We use MYSERIAL1 here, so we need to figure out how to get the linked register
+    struct usart_dev* dev = MYSERIAL1.c_dev();
+
+    // Or use this if removing libmaple
+    // int irq = dev->irq_num;
+    // int nvicUART[] = { NVIC_USART1 /* = 37 */, NVIC_USART2 /* = 38 */, NVIC_USART3 /* = 39 */, NVIC_UART4 /* = 52 */, NVIC_UART5 /* = 53 */ };
+    // Disabling irq means setting the bit in the NVIC ICER register located at
+    // Disable UART interrupt in NVIC
+    nvic_irq_disable(dev->irq_num);
+
+    // Use this if removing libmaple
+    //SBI(NVIC_BASE->ICER[1], irq - 32);
+
+    // We NEED memory barriers to ensure Interrupts are actually disabled!
+    // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
+    dsb();
+    isb();
+
+    rcc_clk_disable(dev->clk_id);
+    rcc_clk_enable(dev->clk_id);
+
+    usart_reg_map *regs = dev->regs;
+    regs->CR1 = 0; // Reset the USART
+    regs->CR2 = 0; // 1 stop bit
+
+    // If we don't touch the BRR (baudrate register), we don't need to recompute. Else we would need to call
+    usart_set_baud_rate(dev, 0, BAUDRATE);
+
+    regs->CR1 = (USART_CR1_TE | USART_CR1_UE); // 8 bits, no parity, 1 stop bit
+  #endif
+}
+
+// A SW memory barrier, to ensure GCC does not overoptimize loops
+#define sw_barrier() __asm__ volatile("": : :"memory");
+static void TX(char c) {
+  #if WITHIN(SERIAL_PORT, 1, 6)
+    struct usart_dev* dev = MYSERIAL1.c_dev();
+    while (!(dev->regs->SR & USART_SR_TXE)) {
+      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+      sw_barrier();
+    }
+    dev->regs->DR = c;
+  #endif
+}
+
+void install_min_serial() {
+  HAL_min_serial_init = &TXBegin;
+  HAL_min_serial_out = &TX;
+}
+
+#if DISABLED(DYNAMIC_VECTORTABLE) && DISABLED(STM32F0xx) // Cortex M0 can't branch to a symbol that's too far, so we have a specific hack for them
+extern "C" {
+  __attribute__((naked)) void JumpHandler_ASM() {
+    __asm__ __volatile__ (
+      "b CommonHandler_ASM\n"
+    );
+  }
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __exc_hardfault();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __exc_busfault();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __exc_usagefault();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __exc_memmanage();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __exc_nmi();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __stm32reservedexception7();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __stm32reservedexception8();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __stm32reservedexception9();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __stm32reservedexception10();
+  void __attribute__((naked, alias("JumpHandler_ASM"), nothrow)) __stm32reservedexception13();
+}
+#endif
+
+#endif // POSTMORTEM_DEBUGGING
+#endif // __STM32F1__
diff --git a/Marlin/src/HAL/STM32F1/watchdog.cpp b/Marlin/src/HAL/STM32F1/watchdog.cpp
new file mode 100644
index 0000000000..b812a4fa64
--- /dev/null
+++ b/Marlin/src/HAL/STM32F1/watchdog.cpp
@@ -0,0 +1,66 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * HAL for stm32duino.com based on Libmaple and compatible (STM32F1)
+ */
+
+#ifdef __STM32F1__
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include <libmaple/iwdg.h>
+#include "watchdog.h"
+
+/**
+ *  The watchdog clock is 40Khz. So for a 4s or 8s interval use a /256 preescaler and 625 or 1250 reload value (counts down to 0).
+ */
+#define STM32F1_WD_RELOAD TERN(WATCHDOG_DURATION_8S, 1250, 625) // 4 or 8 second timeout
+
+void HAL_watchdog_refresh() {
+  #if DISABLED(PINS_DEBUGGING) && PIN_EXISTS(LED)
+    TOGGLE(LED_PIN);  // heartbeat indicator
+  #endif
+  iwdg_feed();
+}
+
+void watchdogSetup() {
+  // do whatever. don't remove this function.
+}
+
+/**
+ * @brief  Initialized the independent hardware watchdog.
+ *
+ * @return No return
+ *
+ * @details The watchdog clock is 40Khz. So for a 4s or 8s interval use a /256 preescaler and 625 or 1250 reload value (counts down to 0).
+ */
+void watchdog_init() {
+  #if DISABLED(DISABLE_WATCHDOG_INIT)
+    iwdg_init(IWDG_PRE_256, STM32F1_WD_RELOAD);
+  #endif
+}
+
+#endif // USE_WATCHDOG
+#endif // __STM32F1__
diff --git a/Marlin/src/HAL/STM32F1/watchdog.h b/Marlin/src/HAL/STM32F1/watchdog.h
new file mode 100644
index 0000000000..68920f8cb6
--- /dev/null
+++ b/Marlin/src/HAL/STM32F1/watchdog.h
@@ -0,0 +1,35 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * HAL for stm32duino.com based on Libmaple and compatible (STM32F1)
+ */
+
+#include <libmaple/iwdg.h>
+
+// Initialize watchdog with a 4 or 8 second countdown time
+void watchdog_init();
+
+// Reset watchdog. MUST be called every 4 or 8 seconds after the
+// first watchdog_init or the STM32F1 will reset.
+void HAL_watchdog_refresh();
diff --git a/Marlin/src/HAL/TEENSY31_32/watchdog.cpp b/Marlin/src/HAL/TEENSY31_32/watchdog.cpp
new file mode 100644
index 0000000000..5e21236129
--- /dev/null
+++ b/Marlin/src/HAL/TEENSY31_32/watchdog.cpp
@@ -0,0 +1,40 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef __MK20DX256__
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include "watchdog.h"
+
+#define WDT_TIMEOUT_MS TERN(WATCHDOG_DURATION_8S, 8000, 4000) // 4 or 8 second timeout
+
+void watchdog_init() {
+  WDOG_TOVALH = 0;
+  WDOG_TOVALL = WDT_TIMEOUT_MS;
+  WDOG_STCTRLH = WDOG_STCTRLH_WDOGEN;
+}
+
+#endif // USE_WATCHDOG
+
+#endif // __MK20DX256__
diff --git a/Marlin/src/HAL/TEENSY31_32/watchdog.h b/Marlin/src/HAL/TEENSY31_32/watchdog.h
new file mode 100644
index 0000000000..b8b46a4030
--- /dev/null
+++ b/Marlin/src/HAL/TEENSY31_32/watchdog.h
@@ -0,0 +1,34 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "HAL.h"
+
+// Arduino Due core now has watchdog support
+
+void watchdog_init();
+
+inline void HAL_watchdog_refresh() {
+  // Watchdog refresh sequence
+  WDOG_REFRESH = 0xA602;
+  WDOG_REFRESH = 0xB480;
+}
diff --git a/Marlin/src/HAL/TEENSY35_36/watchdog.cpp b/Marlin/src/HAL/TEENSY35_36/watchdog.cpp
new file mode 100644
index 0000000000..3825e27928
--- /dev/null
+++ b/Marlin/src/HAL/TEENSY35_36/watchdog.cpp
@@ -0,0 +1,40 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#if defined(__MK64FX512__) || defined(__MK66FX1M0__)
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include "watchdog.h"
+
+#define WDT_TIMEOUT_MS TERN(WATCHDOG_DURATION_8S, 8000, 4000) // 4 or 8 second timeout
+
+void watchdog_init() {
+  WDOG_TOVALH = 0;
+  WDOG_TOVALL = WDT_TIMEOUT_MS;
+  WDOG_STCTRLH = WDOG_STCTRLH_WDOGEN;
+}
+
+#endif // USE_WATCHDOG
+
+#endif // __MK64FX512__ || __MK66FX1M0__
diff --git a/Marlin/src/HAL/TEENSY35_36/watchdog.h b/Marlin/src/HAL/TEENSY35_36/watchdog.h
new file mode 100644
index 0000000000..981b1f0bd2
--- /dev/null
+++ b/Marlin/src/HAL/TEENSY35_36/watchdog.h
@@ -0,0 +1,30 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+void watchdog_init();
+
+inline void HAL_watchdog_refresh() {
+  // Watchdog refresh sequence
+  WDOG_REFRESH = 0xA602;
+  WDOG_REFRESH = 0xB480;
+}
diff --git a/Marlin/src/HAL/TEENSY40_41/watchdog.cpp b/Marlin/src/HAL/TEENSY40_41/watchdog.cpp
new file mode 100644
index 0000000000..dd7c0aa92f
--- /dev/null
+++ b/Marlin/src/HAL/TEENSY40_41/watchdog.cpp
@@ -0,0 +1,52 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#ifdef __IMXRT1062__
+
+/**
+ * HAL Watchdog for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(USE_WATCHDOG)
+
+#include "watchdog.h"
+
+#define WDT_TIMEOUT TERN(WATCHDOG_DURATION_8S, 8, 4) // 4 or 8 second timeout
+
+constexpr uint8_t timeoutval = (WDT_TIMEOUT - 0.5f) / 0.5f;
+
+void watchdog_init() {
+  CCM_CCGR3 |= CCM_CCGR3_WDOG1(3);  // enable WDOG1 clocks
+  WDOG1_WMCR = 0;                   // disable power down PDE
+  WDOG1_WCR |= WDOG_WCR_SRS | WDOG_WCR_WT(timeoutval);
+  WDOG1_WCR |= WDOG_WCR_WDE | WDOG_WCR_WDT | WDOG_WCR_SRE;
+}
+
+void HAL_watchdog_refresh() {
+  // Watchdog refresh sequence
+  WDOG1_WSR = 0x5555;
+  WDOG1_WSR = 0xAAAA;
+}
+
+#endif // USE_WATCHDOG
+#endif // __IMXRT1062__
diff --git a/Marlin/src/HAL/TEENSY40_41/watchdog.h b/Marlin/src/HAL/TEENSY40_41/watchdog.h
new file mode 100644
index 0000000000..03ab151b07
--- /dev/null
+++ b/Marlin/src/HAL/TEENSY40_41/watchdog.h
@@ -0,0 +1,30 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * HAL Watchdog for Teensy 4.0 (IMXRT1062DVL6A) / 4.1 (IMXRT1062DVJ6A)
+ */
+
+void watchdog_init();
+
+void HAL_watchdog_refresh();
diff --git a/Marlin/src/HAL/shared/HAL_MinSerial.cpp b/Marlin/src/HAL/shared/HAL_MinSerial.cpp
new file mode 100644
index 0000000000..9dda5fdf8c
--- /dev/null
+++ b/Marlin/src/HAL/shared/HAL_MinSerial.cpp
@@ -0,0 +1,33 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#include "HAL_MinSerial.h"
+
+#if ENABLED(POSTMORTEM_DEBUGGING)
+
+void HAL_min_serial_init_default() {}
+void HAL_min_serial_out_default(char ch) { SERIAL_CHAR(ch); }
+void (*HAL_min_serial_init)() = &HAL_min_serial_init_default;
+void (*HAL_min_serial_out)(char) = &HAL_min_serial_out_default;
+
+bool MinSerial::force_using_default_output = false;
+
+#endif
diff --git a/Marlin/src/HAL/shared/HAL_MinSerial.h b/Marlin/src/HAL/shared/HAL_MinSerial.h
new file mode 100644
index 0000000000..3089b8aa06
--- /dev/null
+++ b/Marlin/src/HAL/shared/HAL_MinSerial.h
@@ -0,0 +1,79 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "../../core/serial.h"
+#include <stdint.h>
+
+// Serial stuff here
+// Inside an exception handler, the CPU state is not safe, we can't expect the handler to resume
+// and the software to continue. UART communication can't rely on later callback/interrupt as it might never happen.
+// So, you need to provide some method to send one byte to the usual UART with the interrupts disabled
+// By default, the method uses SERIAL_CHAR but it's 100% guaranteed to break (couldn't be worse than nothing...)7
+extern void (*HAL_min_serial_init)();
+extern void (*HAL_min_serial_out)(char ch);
+
+struct MinSerial {
+  static bool force_using_default_output;
+  // Serial output
+  static void TX(char ch) {
+    if (force_using_default_output)
+      SERIAL_CHAR(ch);
+    else
+      HAL_min_serial_out(ch);
+  }
+  // Send String through UART
+  static void TX(const char *s) { while (*s) TX(*s++); }
+  // Send a digit through UART
+  static void TXDigit(uint32_t d) {
+    if (d < 10) TX((char)(d+'0'));
+    else if (d < 16) TX((char)(d+'A'-10));
+    else TX('?');
+  }
+
+  // Send Hex number through UART
+  static void TXHex(uint32_t v) {
+    TX("0x");
+    for (uint8_t i = 0; i < 8; i++, v <<= 4)
+      TXDigit((v >> 28) & 0xF);
+  }
+
+  // Send Decimal number through UART
+  static void TXDec(uint32_t v) {
+    if (!v) {
+      TX('0');
+      return;
+    }
+
+    char nbrs[14];
+    char *p = &nbrs[0];
+    while (v != 0) {
+      *p++ = '0' + (v % 10);
+      v /= 10;
+    }
+    do {
+      p--;
+      TX(*p);
+    } while (p != &nbrs[0]);
+  }
+  static void init() { if (!force_using_default_output) HAL_min_serial_init(); }
+};
diff --git a/Marlin/src/HAL/shared/HAL_spi_L6470.cpp b/Marlin/src/HAL/shared/HAL_spi_L6470.cpp
new file mode 100644
index 0000000000..bd85dbe7bd
--- /dev/null
+++ b/Marlin/src/HAL/shared/HAL_spi_L6470.cpp
@@ -0,0 +1,139 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Software L6470 SPI functions originally from Arduino Sd2Card Library
+ * Copyright (c) 2009 by William Greiman
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if HAS_L64XX
+
+#include "Delay.h"
+
+#include "../../core/serial.h"
+#include "../../libs/L64XX/L64XX_Marlin.h"
+
+// Make sure GCC optimizes this file.
+// Note that this line triggers a bug in GCC which is fixed by casting.
+// See the note below.
+#pragma GCC optimize (3)
+
+// run at ~4Mhz
+inline uint8_t L6470_SpiTransfer_Mode_0(uint8_t b) { // using Mode 0
+  for (uint8_t bits = 8; bits--;) {
+    WRITE(L6470_CHAIN_MOSI_PIN, b & 0x80);
+    b <<= 1;        // little setup time
+
+    WRITE(L6470_CHAIN_SCK_PIN, HIGH);
+    DELAY_NS(125);  // 10 cycles @ 84mhz
+
+    b |= (READ(L6470_CHAIN_MISO_PIN) != 0);
+
+    WRITE(L6470_CHAIN_SCK_PIN, LOW);
+    DELAY_NS(125);  // 10 cycles @ 84mhz
+  }
+  return b;
+}
+
+inline uint8_t L6470_SpiTransfer_Mode_3(uint8_t b) { // using Mode 3
+  for (uint8_t bits = 8; bits--;) {
+    WRITE(L6470_CHAIN_SCK_PIN, LOW);
+    WRITE(L6470_CHAIN_MOSI_PIN, b & 0x80);
+
+    DELAY_NS(125);  // 10 cycles @ 84mhz
+    WRITE(L6470_CHAIN_SCK_PIN, HIGH);
+    DELAY_NS(125);  // Need more delay for fast CPUs
+
+    b <<= 1;        // little setup time
+    b |= (READ(L6470_CHAIN_MISO_PIN) != 0);
+  }
+  DELAY_NS(125);    // 10 cycles @ 84mhz
+  return b;
+}
+
+/**
+ * L64XX methods for SPI init and transfer
+ */
+void L64XX_Marlin::spi_init() {
+  OUT_WRITE(L6470_CHAIN_SS_PIN, HIGH);
+  OUT_WRITE(L6470_CHAIN_SCK_PIN, HIGH);
+  OUT_WRITE(L6470_CHAIN_MOSI_PIN, HIGH);
+  SET_INPUT(L6470_CHAIN_MISO_PIN);
+
+  #if PIN_EXISTS(L6470_BUSY)
+    SET_INPUT(L6470_BUSY_PIN);
+  #endif
+
+  OUT_WRITE(L6470_CHAIN_MOSI_PIN, HIGH);
+}
+
+uint8_t L64XX_Marlin::transfer_single(uint8_t data, int16_t ss_pin) {
+  // First device in chain has data sent last
+  extDigitalWrite(ss_pin, LOW);
+
+  DISABLE_ISRS(); // Disable interrupts during SPI transfer (can't allow partial command to chips)
+  const uint8_t data_out = L6470_SpiTransfer_Mode_3(data);
+  ENABLE_ISRS();  // Enable interrupts
+
+  extDigitalWrite(ss_pin, HIGH);
+  return data_out;
+}
+
+uint8_t L64XX_Marlin::transfer_chain(uint8_t data, int16_t ss_pin, uint8_t chain_position) {
+  uint8_t data_out = 0;
+
+  // first device in chain has data sent last
+  extDigitalWrite(ss_pin, LOW);
+
+  for (uint8_t i = L64XX::chain[0]; !L64xxManager.spi_abort && i >= 1; i--) {   // Send data unless aborted
+    DISABLE_ISRS();   // Disable interrupts during SPI transfer (can't allow partial command to chips)
+    const uint8_t temp = L6470_SpiTransfer_Mode_3(uint8_t(i == chain_position ? data : dSPIN_NOP));
+    ENABLE_ISRS();    // Enable interrupts
+    if (i == chain_position) data_out = temp;
+  }
+
+  extDigitalWrite(ss_pin, HIGH);
+  return data_out;
+}
+
+/**
+ * Platform-supplied L6470 buffer transfer method
+ */
+void L64XX_Marlin::transfer(uint8_t L6470_buf[], const uint8_t length) {
+  // First device in chain has its data sent last
+
+  if (spi_active) {                   // Interrupted SPI transfer so need to
+    WRITE(L6470_CHAIN_SS_PIN, HIGH);  //  guarantee min high of 650ns
+    DELAY_US(1);
+  }
+
+  WRITE(L6470_CHAIN_SS_PIN, LOW);
+  for (uint8_t i = length; i >= 1; i--)
+    L6470_SpiTransfer_Mode_3(uint8_t(L6470_buf[i]));
+  WRITE(L6470_CHAIN_SS_PIN, HIGH);
+}
+
+#pragma GCC reset_options
+
+#endif // HAS_L64XX
diff --git a/Marlin/src/MarlinCore.cpp b/Marlin/src/MarlinCore.cpp
index ef6bf6aad5..b34f5aa68f 100644
--- a/Marlin/src/MarlinCore.cpp
+++ b/Marlin/src/MarlinCore.cpp
@@ -1,4 +1,5 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
+ * updated 12/24/22
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -39,6 +40,9 @@
 #endif
 #include <math.h>
 
+#include "core/utility.h"
+#include "module/stepper/indirection.h"
+
 #include "module/endstops.h"
 #include "module/motion.h"
 #include "module/planner.h"
@@ -150,7 +154,19 @@
 #endif
 
 #if HAS_CUTTER
-  #include "feature/spindle_laser.h"
+  #include "../Marlin/src/feature/spindle_laser.h"
+#endif
+
+#if ENABLED(TG_I2C_SUPPORT) || ENABLED(EXPERIMENTAL_I2CBUS)
+  #include <src/module/TG_I2C/TG_I2CSlave.h>   //TG 5/12/22 added for I2C comm with AVR128DB28 Triac controller
+#endif
+
+#if ENABLED(USE_RPM_SENSOR)
+  #include <src/module/rpmSensor/rpmTimer.h>        //TG 12/20/22 was under "#if HAS_CUTTER"  TG 8/30/22 removed, not used for AVRTriac system
+#endif
+
+#if ENABLED(VFD_CONTROLLER)                     // TG 12/15/22 added this new to use LCD_SERIAL_PORT as UART3 for RS485
+   #include <src/module/vfd.h>
 #endif
 
 #if ENABLED(SDSUPPORT)
@@ -257,6 +273,7 @@
 PGMSTR(M112_KILL_STR, "M112 Shutdown");
 
 MarlinState marlin_state = MF_INITIALIZING;
+uint16_t _loopcount = 0;    //TG used to blink LED2 as running main loop indicator
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 bool wait_for_heatup = true;
@@ -433,7 +450,9 @@ inline void manage_inactivity(const bool no_stepper_sleep=false) {
     if (gcode.stepper_inactive_time) {
 
       static bool already_shutdown_steppers; // = false
-
+    
+    // Any moves in the planner? Resets both the M18/M84
+    // activity timeout and the M85 max 'kill' timeout
       if (!has_blocks && !do_reset_timeout && gcode.stepper_inactive_timeout()) {
         if (!already_shutdown_steppers) {
           already_shutdown_steppers = true;
@@ -738,7 +757,7 @@ inline void manage_inactivity(const bool no_stepper_sleep=false) {
   // Limit check_axes_activity frequency to 10Hz
   static millis_t next_check_axes_ms = 0;
   if (ELAPSED(ms, next_check_axes_ms)) {
-    planner.check_axes_activity();
+    planner.check_axes_activity();  //TG this call executes planner and FAN is set on/off in planner->block
     next_check_axes_ms = ms + 100UL;
   }
 
@@ -791,7 +810,7 @@ void idle(bool no_stepper_sleep/*=false*/) {
   // Core Marlin activities
   manage_inactivity(no_stepper_sleep);
 
-  // Manage Heaters (and Watchdog)
+  // Manage Heaters (and Watchdog)  //TG 2/22/21 may be able to eventually remove this?
   thermalManager.task();
 
   // Max7219 heartbeat, animation, etc
@@ -868,6 +887,10 @@ void idle(bool no_stepper_sleep/*=false*/) {
       TERN_(BUFFER_MONITORING, queue.auto_report_buffer_statistics());
     }
   #endif
+  
+  #if ENABLED(VFD_CONTROLLER)   //TG 12/22/22 added to periodically check VFD status, getVFDStatus() has an elapsed
+    getVFDStatus();             //time check and will only run every 2 sec. no matter how fast we call it here
+  #endif
 
   // Update the PrÅ¯Å¡a MMU2
   TERN_(HAS_PRUSA_MMU2, mmu2.mmu_loop());
@@ -1143,7 +1166,9 @@ void setup() {
   #ifdef BOARD_PREINIT
     BOARD_PREINIT(); // Low-level init (before serial init)
   #endif
-
+  SET_DIR_OUTPUT(P4_28);  //TG for testing
+  SET_DIR_OUTPUT(P2_12);  //TG for testing
+  OUT_WRITE(P2_12,0);
   tmc_standby_setup();  // TMC Low Power Standby pins must be set early or they're not usable
 
   // Check startup - does nothing if bootloader sets MCUSR to 0
@@ -1162,6 +1187,21 @@ void setup() {
   #endif
   #define SETUP_RUN(C) do{ SETUP_LOG(STRINGIFY(C)); C; }while(0)
 
+  #if HAS_CUTTER  //TG 2/15/21 moved this up here to insure spindle is off early in startup
+    SETUP_RUN(cutter.init());
+  #endif
+
+  #if ENABLED(USE_RPM_SENSOR)                   //TG 12/20/22 put back in with conditional compile
+    SETUP_RUN(RPM_timer_init(MF_TIMER_RPM));    //TG removed 5/12/22, RPM handled by AVR Triac controller via I2C now
+  #endif
+
+  #if ENABLED(TG_I2C_SUPPORT) && I2C_SLAVE_ADDRESS > 0
+    SETUP_RUN(I2C_begin(I2C_SLAVE_MODE, I2C_SLAVE_ADDRESS, I2C_CLOCK, true)); //TG added 5/12/22 to support AVR Triac controller via I2C
+  #endif
+  #if ENABLED(TG_I2C_SUPPORT) && I2C_SLAVE_ADDRESS == 0
+    SETUP_RUN(I2C_begin(I2C_MASTER_MODE, I2C_SLAVE_ADDRESS,I2C_CLOCK, true)); //TG added 5/12/22, not supported yet
+  #endif
+
   MYSERIAL1.begin(BAUDRATE);
   millis_t serial_connect_timeout = millis() + 1000UL;
   while (!MYSERIAL1.connected() && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
@@ -1182,6 +1222,13 @@ void setup() {
       while (!MYSERIAL3.connected() && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
+
+  #ifdef LCD_SERIAL_PORT    // TG 12/15/22 added this new to use LCD_SERIAL_PORT as UART3 for RS485
+    LCD_SERIAL.begin(LCD_BAUDRATE);
+    serial_connect_timeout = millis() + 1000UL;
+    while (!LCD_SERIAL.connected() && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
+    LCD_SERIAL.flush();  
+  #endif
   SERIAL_ECHOLNPGM("start");
 
   // Set up these pins early to prevent suicide
@@ -1228,6 +1275,10 @@ void setup() {
 
   SETUP_RUN(hal.init());
 
+  #if ENABLED(VFD_CONTROLLER)   //TG 12/22/22 added to retreive VFD decimal point setting before all else
+    //initialReadVFD(true);     //TG 2/16/23 no longer needed, this is done every call to getVFDStatus() in idle() loop
+  #endif
+
   // Init and disable SPI thermocouples; this is still needed
   #if TEMP_SENSOR_IS_MAX_TC(0) || (TEMP_SENSOR_IS_MAX_TC(REDUNDANT) && REDUNDANT_TEMP_MATCH(SOURCE, E0))
     OUT_WRITE(TEMP_0_CS_PIN, HIGH);  // Disable
@@ -1534,8 +1585,10 @@ void setup() {
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     SETUP_LOG("i2c...");
-    i2c.onReceive(i2c_on_receive);
-    i2c.onRequest(i2c_on_request);
+    //Wire.onReceive(slaveReceive);
+    //i2c.onReceive(i2c_on_receive);
+    //i2c.onRequest(i2c_on_request);
+    //Wire.onRequest(slaveRequest);
   #endif
 
   #if DO_SWITCH_EXTRUDER
@@ -1563,8 +1616,9 @@ void setup() {
     SETUP_RUN(est_init());
   #endif
 
-  #if ENABLED(USE_WATCHDOG)
-    SETUP_RUN(hal.watchdog_init());   // Reinit watchdog after hal.get_reset_source call
+  //TG 1/30/21 disable watchdog if DEBUG defined in platformio.ini build_flags
+  #if ENABLED(USE_WATCHDOG) && DISABLED(DEBUG)
+    SETUP_RUN(hal.watchdog_init());       // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
@@ -1648,6 +1702,9 @@ void setup() {
   marlin_state = MF_RUNNING;
 
   SETUP_LOG("setup() completed.");
+  #if PIN_EXISTS(LED)  //TG 2/2/21 added to indicate setup complete
+    WRITE(LED_PIN,1);
+  #endif
 
   TERN_(MARLIN_TEST_BUILD, runStartupTests());
 }
@@ -1666,6 +1723,9 @@ void setup() {
  *    as long as idle() or manage_inactivity() are being called.
  */
 void loop() {
+  uint8_t _bp = 0;
+  static uint8_t leftover;
+
   do {
     idle();
 
@@ -1681,10 +1741,15 @@ void loop() {
     #endif
 
     endstops.event_handler();
-
+    
     TERN_(HAS_TFT_LVGL_UI, printer_state_polling());
-
+    
     TERN_(MARLIN_TEST_BUILD, runPeriodicTests());
 
+    #if PIN_EXISTS(LED2)      //TG 2/2/21 added to indicate idle loop activity, approx 1 sec ON 1 sec OFF
+      if (_loopcount++ == 0) 
+        {TOGGLE(LED2_PIN);}   // toggle LED when 16-bit _loopcount overflows, period=65535 counts
+    #endif
+
   } while (ENABLED(__AVR__)); // Loop forever on slower (AVR) boards
 }
diff --git a/Marlin/src/MarlinCore.h b/Marlin/src/MarlinCore.h
index f80405a302..37de469553 100644
--- a/Marlin/src/MarlinCore.h
+++ b/Marlin/src/MarlinCore.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -84,3 +84,6 @@ bool pin_is_protected(const pin_t pin);
 #endif
 
 extern const char M112_KILL_STR[];
+
+extern uint16_t _loopcount; //TG added
+#define NOP asm("nop");     //TG added
diff --git a/Marlin/src/core/boards.h b/Marlin/src/core/boards.h
index bdf86392c9..f74feffba9 100644
--- a/Marlin/src/core/boards.h
+++ b/Marlin/src/core/boards.h
@@ -229,34 +229,34 @@
 #define BOARD_RAMPS_14_RE_ARM_EFF     2002  // Re-ARM with RAMPS 1.4 (Power outputs: Hotend, Fan0, Fan1)
 #define BOARD_RAMPS_14_RE_ARM_EEF     2003  // Re-ARM with RAMPS 1.4 (Power outputs: Hotend0, Hotend1, Fan)
 #define BOARD_RAMPS_14_RE_ARM_SF      2004  // Re-ARM with RAMPS 1.4 (Power outputs: Spindle, Controller Fan)
-#define BOARD_MKS_SBASE               2005  // MKS-Sbase
+#define BOARD_MKS_SBASE               2005  // MKS-Sbase (Power outputs: Hotend0, Hotend1, Bed, Fan)
 #define BOARD_AZSMZ_MINI              2006  // AZSMZ Mini
-#define BOARD_BIQU_BQ111_A4           2007  // BIQU BQ111-A4
-#define BOARD_SELENA_COMPACT          2008  // Selena Compact
-#define BOARD_BIQU_B300_V1_0          2009  // BIQU B300_V1.0
-#define BOARD_MKS_SGEN_L              2010  // MKS-SGen-L
+#define BOARD_BIQU_BQ111_A4           2007  // BIQU BQ111-A4 (Power outputs: Hotend, Fan, Bed)
+#define BOARD_SELENA_COMPACT          2008  // Selena Compact (Power outputs: Hotend0, Hotend1, Bed0, Bed1, Fan0, Fan1)
+#define BOARD_BIQU_B300_V1_0          2009  // BIQU B300_V1.0 (Power outputs: Hotend0, Fan, Bed, SPI Driver)
+#define BOARD_MKS_SGEN_L              2010  // MKS-SGen-L (Power outputs: Hotend0, Hotend1, Bed, Fan)
 #define BOARD_GMARSH_X6_REV1          2011  // GMARSH X6, revision 1 prototype
-#define BOARD_BTT_SKR_V1_1            2012  // BigTreeTech SKR v1.1
-#define BOARD_BTT_SKR_V1_3            2013  // BigTreeTech SKR v1.3
-#define BOARD_BTT_SKR_V1_4            2014  // BigTreeTech SKR v1.4
+#define BOARD_BTT_SKR_V1_1            2012  // BigTreeTech SKR v1.1 (Power outputs: Hotend0, Hotend1, Fan, Bed)
+#define BOARD_BTT_SKR_V1_3            2013  // BigTreeTech SKR v1.3 (Power outputs: Hotend0, Hotend1, Fan, Bed)
+#define BOARD_BTT_SKR_V1_4            2014  // BigTreeTech SKR v1.4 (Power outputs: Hotend0, Hotend1, Fan, Bed)
 #define BOARD_EMOTRONIC               2015  // eMotion-Tech eMotronic
 
 //
 // LPC1769 ARM Cortex-M3
 //
 
-#define BOARD_MKS_SGEN                2500  // MKS-SGen
-#define BOARD_AZTEEG_X5_GT            2501  // Azteeg X5 GT
-#define BOARD_AZTEEG_X5_MINI          2502  // Azteeg X5 Mini
-#define BOARD_AZTEEG_X5_MINI_WIFI     2503  // Azteeg X5 Mini Wifi
+#define BOARD_MKS_SGEN                2500  // MKS-SGen (Power outputs: Hotend0, Hotend1, Bed, Fan)
+#define BOARD_AZTEEG_X5_GT            2501  // Azteeg X5 GT (Power outputs: Hotend0, Hotend1, Bed, Fan)
+#define BOARD_AZTEEG_X5_MINI          2502  // Azteeg X5 Mini (Power outputs: Hotend0, Bed, Fan)
+#define BOARD_AZTEEG_X5_MINI_WIFI     2503  // Azteeg X5 Mini Wifi (Power outputs: Hotend0, Bed, Fan)
 #define BOARD_COHESION3D_REMIX        2504  // Cohesion3D ReMix
 #define BOARD_COHESION3D_MINI         2505  // Cohesion3D Mini
 #define BOARD_SMOOTHIEBOARD           2506  // Smoothieboard
 #define BOARD_TH3D_EZBOARD            2507  // TH3D EZBoard v1.0
-#define BOARD_BTT_SKR_V1_4_TURBO      2508  // BigTreeTech SKR v1.4 TURBO
-#define BOARD_MKS_SGEN_L_V2           2509  // MKS SGEN_L V2
-#define BOARD_BTT_SKR_E3_TURBO        2510  // BigTreeTech SKR E3 Turbo
-#define BOARD_FLY_CDY                 2511  // FLYmaker FLY CDY
+#define BOARD_BTT_SKR_V1_4_TURBO      2508  // BigTreeTech SKR v1.4 TURBO (Power outputs: Hotend0, Hotend1, Fan, Bed)
+#define BOARD_MKS_SGEN_L_V2           2509  // MKS SGEN_L V2 (Power outputs: Hotend0, Hotend1, Bed, Fan)
+#define BOARD_BTT_SKR_E3_TURBO        2510  // BigTreeTech SKR E3 Turbo (Power outputs: Hotend0, Hotend1, Bed, Fan0, Fan1)
+#define BOARD_FLY_CDY                 2511  // FLYmaker FLY CDY (Power outputs: Hotend0, Hotend1, Hotend2, Bed, Fan0, Fan1, Fan2)
 
 //
 // SAM3X8E ARM Cortex-M3
@@ -282,8 +282,8 @@
 #define BOARD_RAMPS4DUE_EFF           3017  // RAMPS4DUE (Power outputs: Hotend, Fan0, Fan1)
 #define BOARD_RAMPS4DUE_EEF           3018  // RAMPS4DUE (Power outputs: Hotend0, Hotend1, Fan)
 #define BOARD_RAMPS4DUE_SF            3019  // RAMPS4DUE (Power outputs: Spindle, Controller Fan)
-#define BOARD_RURAMPS4D_11            3020  // RuRAMPS4Duo v1.1
-#define BOARD_RURAMPS4D_13            3021  // RuRAMPS4Duo v1.3
+#define BOARD_RURAMPS4D_11            3020  // RuRAMPS4Duo v1.1 (Power outputs: Hotend0, Hotend1, Hotend2, Fan0, Fan1, Bed)
+#define BOARD_RURAMPS4D_13            3021  // RuRAMPS4Duo v1.3 (Power outputs: Hotend0, Hotend1, Hotend2, Fan0, Fan1, Bed)
 #define BOARD_ULTRATRONICS_PRO        3022  // ReprapWorld Ultratronics Pro V1.0
 #define BOARD_ARCHIM1                 3023  // UltiMachine Archim1 (with DRV8825 drivers)
 #define BOARD_ARCHIM2                 3024  // UltiMachine Archim2 (with TMC2130 drivers)
diff --git a/Marlin/src/core/macros.h b/Marlin/src/core/macros.h
index fec390b64b..8080b46456 100644
--- a/Marlin/src/core/macros.h
+++ b/Marlin/src/core/macros.h
@@ -377,6 +377,7 @@
 
 #define LOOP_S_LE_N(VAR, S, N) for (uint8_t VAR=(S); VAR<=(N); VAR++)
 #define LOOP_S_L_N(VAR, S, N) for (uint8_t VAR=(S); VAR<(N); VAR++)
+#define LOOP_INT_S_L_N(VAR, S, N) for (int8_t VAR=(S); VAR<(N); VAR++)    //TG 10/2/22 - added to allow loop with negative index
 #define LOOP_LE_N(VAR, N) LOOP_S_LE_N(VAR, 0, N)
 #define LOOP_L_N(VAR, N) LOOP_S_L_N(VAR, 0, N)
 
diff --git a/Marlin/src/core/serial_hook.h b/Marlin/src/core/serial_hook.h
index 65c553c702..39a20827a4 100644
--- a/Marlin/src/core/serial_hook.h
+++ b/Marlin/src/core/serial_hook.h
@@ -118,6 +118,7 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
 
   SerialT & out;
   NO_INLINE size_t write(uint8_t c) { return out.write(c); }
+  size_t write(char* src, size_t length) { return out.write(src, length);}  //TG 3/9/23 added back - bugfix-2.1.x had removed it
   void flush()            { out.flush();  }
   void begin(long br)     { out.begin(br); }
   void end()              { out.end(); }
@@ -131,6 +132,7 @@ struct ForwardSerial : public SerialBase< ForwardSerial<SerialT> > {
   int read(serial_index_t)      { return (int)out.read(); }
   int available()               { return (int)out.available(); }
   int read()                    { return (int)out.read(); }
+  bool TXbufferEmpty()          { return (int)out.TXbufferEmpty();}   //TG 12/16/22-returns 0 if TX empty
   SerialFeature features(serial_index_t index) const  { return CALL_IF_EXISTS(SerialFeature, &out, features, index);  }
 
   ForwardSerial(const bool e, SerialT & out) : BaseClassT(e), out(out) {}
diff --git a/Marlin/src/core/types.h b/Marlin/src/core/types.h
index 4e3d7f0782..3d9dc01dd6 100644
--- a/Marlin/src/core/types.h
+++ b/Marlin/src/core/types.h
@@ -93,10 +93,12 @@ template <class L, class R> struct IF<true, L, R> { typedef L type; };
 template<size_t N>
 struct Flags {
   typedef value_t(N) flagbits_t;
+  typedef typename IF<(N>8), uint16_t, uint8_t>::type bits_t;
   typedef struct { bool b0:1, b1:1, b2:1, b3:1, b4:1, b5:1, b6:1, b7:1; } N8;
   typedef struct { bool b0:1, b1:1, b2:1, b3:1, b4:1, b5:1, b6:1, b7:1, b8:1, b9:1, b10:1, b11:1, b12:1, b13:1, b14:1, b15:1; } N16;
   typedef struct { bool b0:1,  b1:1,  b2:1,  b3:1,  b4:1,  b5:1,  b6:1,  b7:1,  b8:1,  b9:1, b10:1, b11:1, b12:1, b13:1, b14:1, b15:1,
                        b16:1, b17:1, b18:1, b19:1, b20:1, b21:1, b22:1, b23:1, b24:1, b25:1, b26:1, b27:1, b28:1, b29:1, b30:1, b31:1; } N32;
+
   union {
     flagbits_t b;
     typename IF<(N>16), N32, typename IF<(N>8), N16, N8>::type>::type flag;
diff --git a/Marlin/src/core/utility.h b/Marlin/src/core/utility.h
index c4bb3c2a8a..9be3e56f33 100644
--- a/Marlin/src/core/utility.h
+++ b/Marlin/src/core/utility.h
@@ -59,11 +59,12 @@ void safe_delay(millis_t ms);           // Delay ensuring that temperatures are
   #define log_machine_info() NOOP
 #endif
 
-/**
- * A restorer instance remembers a variable's value before setting a
- * new value, then restores the old value when it goes out of scope.
- * Put operator= on your type to get extended behavior on value change.
- */
+//TG this class saves the original val_ to ref_ , then sets ref_ to temp_val
+// the class destroys when it goes out of scope (i.e. function that created it ends)
+// upon being destroyed, it restores the ref_ to it's original value it had
+// A restorer instance remembers a variable's value before setting a
+// new value, then restores the old value when it goes out of scope.
+// Put operator= on your type to get extended behavior on value change.
 template<typename T>
 class restorer {
   T& ref_;
diff --git a/Marlin/src/feature/bedlevel/abl/x_twist.cpp b/Marlin/src/feature/bedlevel/abl/x_twist.cpp
new file mode 100644
index 0000000000..c4a62c3595
--- /dev/null
+++ b/Marlin/src/feature/bedlevel/abl/x_twist.cpp
@@ -0,0 +1,59 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#include "../../../inc/MarlinConfig.h"
+
+#if ENABLED(X_AXIS_TWIST_COMPENSATION)
+
+#include "../bedlevel.h"
+
+XATC xatc;
+
+float XATC::spacing, XATC::start;
+xatc_points_t XATC::z_values;
+
+void XATC::print_points() {
+  SERIAL_ECHOLNPGM(" X-Twist Correction:");
+  LOOP_L_N(x, XATC_MAX_POINTS) {
+    SERIAL_CHAR(' ');
+    if (!isnan(z_values[x])) {
+      if (z_values[x] >= 0) SERIAL_CHAR('+');
+      SERIAL_ECHO_F(z_values[x], 3);
+    }
+    else {
+      LOOP_L_N(i, 6)
+        SERIAL_CHAR(i ? '=' : ' ');
+    }
+  }
+  SERIAL_EOL();
+}
+
+float lerp(const_float_t t, const_float_t a, const_float_t b) { return a + t * (b - a); }
+
+float XATC::compensation(const xy_pos_t &raw) {
+  float t = (raw.x - start) / spacing;
+  int i = FLOOR(t);
+  LIMIT(i, 0, XATC_MAX_POINTS - 2);
+  t -= i;
+  return lerp(t, z_values[i], z_values[i + 1]);
+}
+
+#endif // X_AXIS_TWIST_COMPENSATION
diff --git a/Marlin/src/feature/bedlevel/abl/x_twist.h b/Marlin/src/feature/bedlevel/abl/x_twist.h
new file mode 100644
index 0000000000..bbad9e73ef
--- /dev/null
+++ b/Marlin/src/feature/bedlevel/abl/x_twist.h
@@ -0,0 +1,37 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "../../../inc/MarlinConfigPre.h"
+
+typedef float xatc_points_t[XATC_MAX_POINTS];
+
+class XATC {
+public:
+  static float spacing, start;
+  static xatc_points_t z_values;
+
+  static float compensation(const xy_pos_t &raw);
+  static void print_points();
+};
+
+extern XATC xatc;
diff --git a/Marlin/src/feature/spindle_laser.cpp b/Marlin/src/feature/spindle_laser.cpp
index c0635c7220..d4a9473afe 100644
--- a/Marlin/src/feature/spindle_laser.cpp
+++ b/Marlin/src/feature/spindle_laser.cpp
@@ -1,4 +1,14 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
+ * 
+ * NOTE: As of 7/15/22, a new AVR Triac Controller board is used, which handles PID speed control of the spindle motor.
+ *       It requires a TARGET_RPM from Marlin and will send the ACTUAL_RPM back to Marlin via I2C. The AVR Triac
+ *       Controller measures Spindle RPM and performs all speed regulation.
+ *       Additional information can also be exchanged like PID flag, PID tuning data, etc.
+ *       
+ *       Marlin still controls the Spindle ON/OFF Enable and Vacuum Enable relays, as well as Spindle Direction signal.
+ *       However, the PWM output from Marlin for spindle speed is not used, and Marlin RPM measurement is not used.
+ *       Therefore Timer3 can be returned to softPWM service and Timer2 can be released.
+ * 
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -38,11 +48,10 @@
   #include "../feature/ammeter.h"
 #endif
 
-SpindleLaser cutter;
+SpindleLaser cutter = {};
+uint16_t SpindleLaser::power;                                         //TG 9/30/21 changed to uint16_t for more resolution
 bool SpindleLaser::enable_state;                                      // Virtual enable state, controls enable pin if present and or apply power if > 0
-uint8_t SpindleLaser::power,                                          // Actual power output 0-255 ocr or "0 = off" > 0 = "on"
-        SpindleLaser::last_power_applied; // = 0                      // Basic power state tracking
-
+uint16_t SpindleLaser::last_power_applied; // = 0                      // Basic power state tracking
 #if ENABLED(LASER_FEATURE)
   cutter_test_pulse_t SpindleLaser::testPulse = 50;                   // (ms) Test fire pulse default duration
   uint8_t SpindleLaser::last_block_power; // = 0                      // Track power changes for dynamic inline power
@@ -50,6 +59,7 @@ uint8_t SpindleLaser::power,                                          // Actual
              SpindleLaser::last_feedrate_mm_m; // = 0                 // (mm/min) Track feedrate changes for dynamic power
 #endif
 
+bool SpindleLaser::spindle_use_pid;                                   //TG - 9/17/21 flag to use PID speed control for spindle or not
 bool SpindleLaser::isReadyForUI = false;                              // Ready to apply power setting from the UI to OCR
 CutterMode SpindleLaser::cutter_mode = CUTTER_MODE_STANDARD;          // Default is standard mode
 
@@ -71,14 +81,15 @@ void SpindleLaser::init() {
     OUT_WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ACTIVE_STATE);    // Init spindle to off
   #endif
   #if ENABLED(SPINDLE_CHANGE_DIR)
-    OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR);                   // Init rotation to clockwise (M3)
+    //TG 8/4/22 UNCOMMENT BEFORE RELEASE!!
+//    OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR);       // Init rotation to clockwise (M3)
   #endif
   #if ENABLED(HAL_CAN_SET_PWM_FREQ) && SPINDLE_LASER_FREQUENCY
     frequency = SPINDLE_LASER_FREQUENCY;
     hal.set_pwm_frequency(pin_t(SPINDLE_LASER_PWM_PIN), SPINDLE_LASER_FREQUENCY);
   #endif
   #if ENABLED(SPINDLE_LASER_USE_PWM)
-    SET_PWM(SPINDLE_LASER_PWM_PIN);
+    SET_PWM(SPINDLE_LASER_PWM_PIN);                                   //TG set PWM pin to output mode, 7/15/22 - PWM no longer used with AVR Triac Controller
     hal.set_pwm_duty(pin_t(SPINDLE_LASER_PWM_PIN), SPINDLE_LASER_PWM_OFF); // Set to lowest speed
   #endif
   #if ENABLED(AIR_EVACUATION)
@@ -96,63 +107,72 @@ void SpindleLaser::init() {
    *
    * @param ocr Power value
    */
-  void SpindleLaser::_set_ocr(const uint8_t ocr) {
+  //TG - 9/30/21 customized the 3 functions below to get higher resolution 16-bit PWM
+  void SpindleLaser::_set_ocr16 (const uint16_t ocr16){
     #if ENABLED(HAL_CAN_SET_PWM_FREQ) && SPINDLE_LASER_FREQUENCY
       hal.set_pwm_frequency(pin_t(SPINDLE_LASER_PWM_PIN), frequency);
     #endif
-    hal.set_pwm_duty(pin_t(SPINDLE_LASER_PWM_PIN), ocr ^ SPINDLE_LASER_PWM_OFF);
+    hal.set_pwm_duty(pin_t(SPINDLE_LASER_PWM_PIN), ocr16 ^ SPINDLE_LASER_PWM_OFF);
   }
-
-  void SpindleLaser::set_ocr(const uint8_t ocr) {
+  
+  void SpindleLaser::set_ocr16(const uint16_t ocr16) {
     #if PIN_EXISTS(SPINDLE_LASER_ENA)
-      WRITE(SPINDLE_LASER_ENA_PIN,  SPINDLE_LASER_ACTIVE_STATE); // Cutter ON
-    #endif
-    _set_ocr(ocr);
+        WRITE(SPINDLE_LASER_ENA_PIN,  SPINDLE_LASER_ACTIVE_STATE); // Cutter ON
+	#endif
+    _set_ocr16(ocr16);
   }
-
-  void SpindleLaser::ocr_off() {
-    #if PIN_EXISTS(SPINDLE_LASER_ENA)
-      WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ACTIVE_STATE); // Cutter OFF
-    #endif
-    _set_ocr(0);
+  
+  void SpindleLaser::ocr16_off() {
+	#if PIN_EXISTS(SPINDLE_LASER_ENA)
+    	WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ACTIVE_STATE); // Cutter OFF
+	#endif
+    _set_ocr16(0);
   }
-#endif // SPINDLE_LASER_USE_PWM
+#endif	// SPINDLE_LASER_USE_PWM  
+//TG - 9/30/21 end of customized functions
 
 /**
- * Apply power for Laser or Spindle
+ * Apply power for laser/spindle
  *
  * Apply cutter power value for PWM, Servo, and on/off pin.
  *
- * @param opwr Power value. Range 0 to MAX.
+ * @param opwr Power value. Range 0 to MAX. When 0 disable spindle/laser.
  */
-void SpindleLaser::apply_power(const uint8_t opwr) {
+// Set cutter ON/OFF state (and PWM) to the given cutter power value, customized 9/30/21 for higher resolution 16-bit PWM
+void SpindleLaser::apply_power(const uint16_t opwr) {   //TG - 9/30/21 changed to 16-bit for hires PWM > 8 bit
+  static uint16_t last_power_applied = 0;               //TG - 9/30/21 changed to 16-bit for hires PWM > 8 bit
   if (enabled() || opwr == 0) {                                   // 0 check allows us to disable where no ENA pin exists
     // Test and set the last power used to improve performance
-    if (opwr == last_power_applied) return;
-    last_power_applied = opwr;
-    // Handle PWM driven or just simple on/off
-    #if ENABLED(SPINDLE_LASER_USE_PWM)
-      if (CUTTER_UNIT_IS(RPM) && unitPower == 0)
-        ocr_off();
-      else if (ENABLED(CUTTER_POWER_RELATIVE) || enabled() || opwr == 0) {
-        set_ocr(opwr);
-        isReadyForUI = true;
-      }
-      else
-        ocr_off();
-    #elif ENABLED(SPINDLE_SERVO)
-      servo[SPINDLE_SERVO_NR].move(opwr);
-    #else
-      WRITE(SPINDLE_LASER_ENA_PIN, enabled() ? SPINDLE_LASER_ACTIVE_STATE : !SPINDLE_LASER_ACTIVE_STATE);
+  	if (opwr == last_power_applied) return;
+  	last_power_applied = opwr;
+  	power = opwr;
+  // Handle PWM driven or just simple on/off
+  #if ENABLED(SPINDLE_LASER_USE_PWM)
+    if (cutter.unitPower == 0 && CUTTER_UNIT_IS(RPM)) {
+      ocr16_off();
+      isReadyForUI = false;
+    }
+    else if (ENABLED(CUTTER_POWER_RELATIVE) || enabled() || opwr == 0) {
+      set_ocr16(power);                                 //TG - 9/30/21 changed to 16-bit for hires PWM > 8 bit
       isReadyForUI = true;
-    #endif
+    }
+    else {
+      ocr16_off();
+      isReadyForUI = false;
+    }
+  #elif ENABLED(SPINDLE_SERVO)
+    MOVE_SERVO(SPINDLE_SERVO_NR, power);
+  #else
+    WRITE(SPINDLE_LASER_ENA_PIN, enabled() ? SPINDLE_LASER_ACTIVE_STATE : !SPINDLE_LASER_ACTIVE_STATE);
+    isReadyForUI = true;
+  #endif
   }
   else {
     #if PIN_EXISTS(SPINDLE_LASER_ENA)
       WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ACTIVE_STATE);
     #endif
     isReadyForUI = false; // Only used for UI display updates.
-    TERN_(SPINDLE_LASER_USE_PWM, ocr_off());
+    TERN_(SPINDLE_LASER_USE_PWM, ocr16_off());
   }
 }
 
@@ -163,8 +183,9 @@ void SpindleLaser::apply_power(const uint8_t opwr) {
    */
   void SpindleLaser::set_reverse(const bool reverse) {
     const bool dir_state = (reverse == SPINDLE_INVERT_DIR); // Forward (M3) HIGH when not inverted
-    if (TERN0(SPINDLE_STOP_ON_DIR_CHANGE, enabled()) && READ(SPINDLE_DIR_PIN) != dir_state) disable();
-    WRITE(SPINDLE_DIR_PIN, dir_state);
+//TG 8/4/22 UNCOMMENT BEFORE RELEASE if you need spindle dir control line for motor!!
+//    if (TERN0(SPINDLE_STOP_ON_DIR_CHANGE, enabled()) && READ(SPINDLE_DIR_PIN) != dir_state) disable();
+//    WRITE(SPINDLE_DIR_PIN, dir_state);
   }
 #endif
 
@@ -177,8 +198,8 @@ void SpindleLaser::apply_power(const uint8_t opwr) {
 
 #if ENABLED(AIR_ASSIST)
   // Enable / disable air assist
-  void SpindleLaser::air_assist_enable()  { WRITE(AIR_ASSIST_PIN,  AIR_ASSIST_ACTIVE); } // Turn ON
-  void SpindleLaser::air_assist_disable() { WRITE(AIR_ASSIST_PIN, !AIR_ASSIST_ACTIVE); } // Turn OFF
+  void SpindleLaser::air_assist_enable()  { WRITE(AIR_ASSIST_PIN,  AIR_ASSIST_PIN); } // Turn ON
+  void SpindleLaser::air_assist_disable() { WRITE(AIR_ASSIST_PIN, !AIR_ASSIST_PIN); } // Turn OFF
   void SpindleLaser::air_assist_toggle()  { TOGGLE(AIR_ASSIST_PIN); } // Toggle state
 #endif
 
diff --git a/Marlin/src/feature/spindle_laser.h b/Marlin/src/feature/spindle_laser.h
index a49e5611a4..71487a73ba 100644
--- a/Marlin/src/feature/spindle_laser.h
+++ b/Marlin/src/feature/spindle_laser.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -25,7 +25,7 @@
  * feature/spindle_laser.h
  * Support for Laser Power or Spindle Power & Direction
  */
-
+#include "math.h"
 #include "../inc/MarlinConfig.h"
 
 #include "spindle_laser_types.h"
@@ -35,10 +35,14 @@
 // Inline laser power
 #include "../module/planner.h"
 
-#define PCT_TO_PWM(X) ((X) * 255 / 100)
+#define PCT_TO_PWM(X) ((X) * (float)SPINDLE_LASER_PWM_RES / 100.0f + 0.5f)  //TG 10/3/21 fixed this to return correct value by using (float)
 #define PCT_TO_SERVO(X) ((X) * 180 / 100)
 
+#ifndef SPEED_POWER_INTERCEPT
+  #define SPEED_POWER_INTERCEPT 0
+#endif
 
+// #define _MAP(N,S1,S2,D1,D2) ((N)*_MAX((D2)-(D1),0)/_MAX((S2)-(S1),1)+(D1))
 // Laser/Cutter operation mode
 enum CutterMode : int8_t {
   CUTTER_MODE_ERROR = -1,
@@ -51,46 +55,50 @@ class SpindleLaser {
 public:
   static CutterMode cutter_mode;
 
-  static constexpr uint8_t pct_to_ocr(const_float_t pct) { return uint8_t(PCT_TO_PWM(pct)); }
-
+  //TG - takes a float as percent and returns 0 to SPINDLE_LASER_PWM_RES, minimum resolution is 1 count
+  static constexpr uint16_t pct_to_ocr(const_float_t pct) { return uint16_t(PCT_TO_PWM(pct)); }  //TG 9/30/21 changed to uint16_t for more resolution
   // cpower = configured values (e.g., SPEED_POWER_MAX)
+
   // Convert configured power range to a percentage
+  //TG - !!!!warning returned an int8_t so inputs under 1% get lost (returns 0)!!!!
+  //TG - 9/30/21 Changed this sub to return a float to allow percentages under 1%
   static constexpr cutter_cpower_t power_floor = TERN(CUTTER_POWER_RELATIVE, SPEED_POWER_MIN, 0);
-  static constexpr uint8_t cpwr_to_pct(const cutter_cpower_t cpwr) {
-    return cpwr ? round(100.0f * (cpwr - power_floor) / (SPEED_POWER_MAX - power_floor)) : 0;
+  static constexpr float cpwr_to_pct(const cutter_cpower_t cpwr) {
+    return cpwr ? (100.0f * (cpwr - power_floor) / (SPEED_POWER_MAX - power_floor)) : 0;
   }
 
   // Convert config defines from RPM to %, angle or PWM when in Spindle mode
   // and convert from PERCENT to PWM when in Laser mode
   static constexpr cutter_power_t cpwr_to_upwr(const cutter_cpower_t cpwr) { // STARTUP power to Unit power
-    return (
+  	return (
       #if ENABLED(SPINDLE_FEATURE)
-        // Spindle configured define values are in RPM
+        // Spindle configured values are in RPM
         #if CUTTER_UNIT_IS(RPM)
-          cpwr                            // to same
-        #elif CUTTER_UNIT_IS(PERCENT)
-          cpwr_to_pct(cpwr)               // to Percent
-        #elif CUTTER_UNIT_IS(SERVO)
-          PCT_TO_SERVO(cpwr_to_pct(cpwr)) // to SERVO angle
-        #else
-          PCT_TO_PWM(cpwr_to_pct(cpwr))   // to PWM
+          cpwr                            // to same (RPM)
+        #elif CUTTER_UNIT_IS(PERCENT)     // to PCT
+          cpwr_to_pct(cpwr)
+        #elif CUTTER_UNIT_IS(SERVO)       // to SERVO angle
+          PCT_TO_SERVO(cpwr_to_pct(cpwr))
+        #else                             // to PWM
+          PCT_TO_PWM(cpwr_to_pct(cpwr))
         #endif
       #else
-        // Laser configured define values are in Percent
+        // Laser configured define values are in PCT
         #if CUTTER_UNIT_IS(PWM255)
-          PCT_TO_PWM(cpwr)                // to PWM
+          PCT_TO_PWM(cpwr)				  // to PWM
         #else
-          cpwr                            // to same
+          cpwr                            // to same (PCT)
         #endif
       #endif
     );
+
   }
 
   static constexpr cutter_power_t mpower_min() { return cpwr_to_upwr(SPEED_POWER_MIN); }
   static constexpr cutter_power_t mpower_max() { return cpwr_to_upwr(SPEED_POWER_MAX); }
 
   #if ENABLED(LASER_FEATURE)
-    static cutter_test_pulse_t testPulse;                 // (ms) Test fire pulse duration
+    static cutter_test_pulse_t testPulse; // Test fire Pulse ms value
     static uint8_t last_block_power;                      // Track power changes for dynamic power
 
     static feedRate_t feedrate_mm_m, last_feedrate_mm_m;  // (mm/min) Track feedrate changes for dynamic power
@@ -101,12 +109,15 @@ public:
     }
   #endif
 
+  
+  volatile uint16_t TARGET_RPM = 0;       // made these two variables part of the SpindleLaser class so there always available
+  volatile uint16_t ACTUAL_RPM = 0;
   static bool isReadyForUI;               // Ready to apply power setting from the UI to OCR
+  static uint16_t power;                  //TG - the current power(always in PWM counts) to apply (in OCR) //TG 9/30/21 changed to uint16_t for more resolution
+  static uint16_t last_power_applied;     // Basic power state tracking
+  static bool spindle_use_pid;            //TG 9/27/21 added to control whether PID speed control is used or not
   static bool enable_state;
-  static uint8_t power,
-                 last_power_applied;      // Basic power state tracking
-
-  static cutter_frequency_t frequency;  // Set PWM frequency; range: 2K-50K
+  static cutter_frequency_t frequency;    // Set PWM frequency; range: 2K-50K
 
   static cutter_power_t menuPower,        // Power as set via LCD menu in PWM, Percentage or RPM
                         unitPower;        // Power as displayed status in PWM, Percentage or RPM
@@ -121,41 +132,42 @@ public:
   static bool enabled(const cutter_power_t opwr) { return opwr > 0; }
   static bool enabled() { return enable_state; }
 
-  static void apply_power(const uint8_t inpow);
+  static void apply_power(const uint16_t inpow);              //TG - 9/30/21 changed to 16-bit for hires PWM > 8 bit
 
   FORCE_INLINE static void refresh() { apply_power(power); }
+  FORCE_INLINE static void set_power(const uint16_t upwr) { power = upwr; refresh(); }  //TG - 9/30/21 changed to 16-bit for hires PWM > 8 bit
 
   #if ENABLED(SPINDLE_LASER_USE_PWM)
 
     private:
 
-    static void _set_ocr(const uint8_t ocr);
+    static void _set_ocr16(const uint16_t ocr16);         //TG - 9/30/21 customized for hires PWM 16-bit
 
     public:
 
-    static void set_ocr(const uint8_t ocr);
-    static void ocr_off();
+    static void set_ocr16(const uint16_t ocr16);          //TG - 9/30/21 customized for hires PWM 16-bit
+    static inline void set_hires_ocr_power(const uint16_t ocr) { power = ocr; set_ocr16(ocr); }  //TG - 9/30/21 customized for hires PWM 16-bit
+    static void ocr16_off();                              //TG - 9/30/21 customized for hires PWM 16-bit
 
-    /**
-     * Update output for power->OCR translation
-     */
-    static uint8_t upower_to_ocr(const cutter_power_t upwr) {
-      return uint8_t(
+    // Used to update output for power->OCR translation
+    //TG 9/30/21 changed to return 16-bit OCR. The called cpwr_to_pct() now returns a true float 
+    static inline uint16_t upower_to_ocr(const cutter_power_t upwr) {  //TG 9/30/21 changed to uint16_t for more resolution
+      return (
         #if CUTTER_UNIT_IS(PWM255)
-          upwr
+          uint16_t(upwr)
         #elif CUTTER_UNIT_IS(PERCENT)
           pct_to_ocr(upwr)
         #else
-          pct_to_ocr(cpwr_to_pct(upwr))
-        #endif
+          uint16_t(pct_to_ocr(cpwr_to_pct(upwr))) //TG - 9/30/21 both called functions have been modified to handle floats now!
+        #endif                                   
       );
     }
 
   #endif // SPINDLE_LASER_USE_PWM
 
-  /**
-   * Correct power to configured range
-   */
+    /**
+     * Correct power to configured range
+     */
   static cutter_power_t power_to_range(const cutter_power_t pwr, const uint8_t pwrUnit=_CUTTER_POWER(CUTTER_POWER_UNIT)) {
     static constexpr float
       min_pct = TERN(CUTTER_POWER_RELATIVE, 0, TERN(SPINDLE_FEATURE, round(100.0f * (SPEED_POWER_MIN) / (SPEED_POWER_MAX)), SPEED_POWER_MIN)),
@@ -164,7 +176,7 @@ public:
     cutter_power_t upwr;
     switch (pwrUnit) {
       case _CUTTER_POWER_PWM255: {  // PWM
-        const uint8_t pmin = pct_to_ocr(min_pct), pmax = pct_to_ocr(max_pct);
+        const uint16_t pmin = pct_to_ocr(min_pct), pmax = pct_to_ocr(max_pct);
         upwr = cutter_power_t(constrain(pwr, pmin, pmax));
       } break;
       case _CUTTER_POWER_PERCENT:   // Percent
@@ -178,6 +190,7 @@ public:
     return upwr;
   }
 
+
   /**
    * Enable Laser or Spindle output.
    * It's important to prevent changing the power output value during inline cutter operation.
@@ -198,7 +211,7 @@ public:
   static void set_enabled(bool enable) {
     switch (cutter_mode) {
       case CUTTER_MODE_STANDARD:
-        apply_power(enable ? TERN(SPINDLE_LASER_USE_PWM, (power ?: (unitPower ? upower_to_ocr(cpwr_to_upwr(SPEED_POWER_STARTUP)) : 0)), 255) : 0);
+        apply_power(enable ? TERN(SPINDLE_LASER_USE_PWM, (power ?: (unitPower ? upower_to_ocr(cpwr_to_upwr(SPEED_POWER_STARTUP)) : 0)), SPINDLE_LASER_PWM_RES) : 0);
         break;
       case CUTTER_MODE_CONTINUOUS:
         TERN_(LASER_FEATURE, set_inline_enabled(enable));
@@ -249,12 +262,12 @@ public:
     }
   #endif
 
-  #if HAS_MARLINUI_MENU
+  #if HAS_MARLINUI_MENU		// for Marlin Menu, not TFT screen
 
     #if ENABLED(SPINDLE_FEATURE)
       static void enable_with_dir(const bool reverse) {
         isReadyForUI = true;
-        const uint8_t ocr = TERN(SPINDLE_LASER_USE_PWM, upower_to_ocr(menuPower), 255);
+        const uint8_t ocr = TERN(SPINDLE_LASER_USE_PWM, upower_to_ocr(menuPower), SPINDLE_LASER_PWM_RES);
         if (menuPower)
           power = ocr;
         else
@@ -307,7 +320,7 @@ public:
 
     // Dynamic mode rate calculation
     static uint8_t calc_dynamic_power() {
-      if (feedrate_mm_m > 65535) return 255;    // Too fast, go always on
+      if (feedrate_mm_m > 65535) return SPINDLE_LASER_PWM_RES;    // Too fast, go always on
       uint16_t rate = uint16_t(feedrate_mm_m);  // 16 bits from the G-code parser float input
       rate >>= 8;                               // Take the G-code input e.g. F40000 and shift off the lower bits to get an OCR value from 1-255
       return uint8_t(rate);
@@ -318,7 +331,7 @@ public:
 
     // Set the power for subsequent movement blocks
     static void inline_power(const cutter_power_t cpwr) {
-      TERN(SPINDLE_LASER_USE_PWM, power = planner.laser_inline.power = cpwr, planner.laser_inline.power = cpwr > 0 ? 255 : 0);
+      TERN(SPINDLE_LASER_USE_PWM, power = planner.laser_inline.power = cpwr, planner.laser_inline.power = cpwr > 0 ? SPINDLE_LASER_PWM_RES : 0);
     }
 
   #endif // LASER_FEATURE
diff --git a/Marlin/src/feature/twibus.cpp b/Marlin/src/feature/twibus.cpp
index 9aec6b0305..fa284b598f 100644
--- a/Marlin/src/feature/twibus.cpp
+++ b/Marlin/src/feature/twibus.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -27,12 +27,12 @@
 #include "twibus.h"
 
 #include <Wire.h>
-
+#include <lpc17xx_i2c.h>
 #include "../libs/hex_print.h"
 
 TWIBus i2c;
 
-TWIBus::TWIBus() {
+TWIBus::TWIBus() {                                  //TG- gets instantiated at startup
   #if I2C_SLAVE_ADDRESS == 0
 
     #if PINS_EXIST(I2C_SCL, I2C_SDA) && DISABLED(SOFT_I2C_EEPROM)
@@ -55,7 +55,7 @@ void TWIBus::reset() {
   buffer[0] = 0x00;
 }
 
-void TWIBus::address(const uint8_t adr) {
+void TWIBus::address(const uint8_t adr) {       //TG- checks valid address, sets variable for send()
   if (!WITHIN(adr, 8, 127))
     SERIAL_ECHO_MSG("Bad I2C address (8-127)");
 
@@ -64,7 +64,7 @@ void TWIBus::address(const uint8_t adr) {
   debug(F("address"), adr);
 }
 
-void TWIBus::addbyte(const char c) {
+void TWIBus::addbyte(const char c) {            //TG- simply adds data byte to TWI::buffer, 32 bytes MAX
   if (buffer_s >= COUNT(buffer)) return;
   buffer[buffer_s++] = c;
   debug(F("addbyte"), c);
@@ -80,10 +80,9 @@ void TWIBus::addstring(char str[]) {
   while (char c = *str++) addbyte(c);
 }
 
-void TWIBus::send() {
+void TWIBus::send() {   // send as Master??
   debug(F("send"), addr);
-
-  Wire.beginTransmission(I2C_ADDRESS(addr));
+  Wire.beginTransmission(I2C_ADDRESS(addr));        //TG- sets flags in Wire.cpp
   Wire.write(buffer, buffer_s);
   Wire.endTransmission();
 
@@ -149,13 +148,14 @@ void TWIBus::echobuffer(FSTR_P const prefix, uint8_t adr) {
   SERIAL_EOL();
 }
 
+//TG- Master request data from Slave
 bool TWIBus::request(const uint8_t bytes) {
   if (!addr) return false;
 
   debug(F("request"), bytes);
 
   // requestFrom() is a blocking function
-  if (Wire.requestFrom(I2C_ADDRESS(addr), bytes) == 0) {
+  if (Wire.requestFrom(I2C_ADDRESS(addr), bytes) == 0) {    // gets Slave data by Master receive
     debug(F("request fail"), I2C_ADDRESS(addr));
     return false;
   }
@@ -163,13 +163,15 @@ bool TWIBus::request(const uint8_t bytes) {
   return true;
 }
 
-void TWIBus::relay(const uint8_t bytes, const uint8_t style/*=0*/) {
+//TG- Master request data from Slave and echo bytes to serial
+void TWIBus::relay(const uint8_t bytes, const uint8_t style/*=0*/) {  // Read as Master??
   debug(F("relay"), bytes);
 
   if (request(bytes))
     echodata(bytes, F("i2c-reply"), addr, style);
 }
 
+//TG- take bytes available from rxBuffer
 uint8_t TWIBus::capture(char *dst, const uint8_t bytes) {
   reset();
   uint8_t count = 0;
diff --git a/Marlin/src/gcode/calibrate/G28.cpp b/Marlin/src/gcode/calibrate/G28.cpp
index 6f0f27cb9d..0b6548a3e3 100644
--- a/Marlin/src/gcode/calibrate/G28.cpp
+++ b/Marlin/src/gcode/calibrate/G28.cpp
@@ -86,7 +86,7 @@
         NUM_AXIS_LIST(
           TERN0(X_SENSORLESS, tmc_enable_stallguard(stepperX)),
           TERN0(Y_SENSORLESS, tmc_enable_stallguard(stepperY)),
-          false, false, false, false, false, false, false
+          false, false, false, false
         )
         , TERN0(X2_SENSORLESS, tmc_enable_stallguard(stepperX2))
         , TERN0(Y2_SENSORLESS, tmc_enable_stallguard(stepperY2))
diff --git a/Marlin/src/gcode/config/M304.cpp b/Marlin/src/gcode/config/M304.cpp
index a71a34c6de..856bf2804c 100644
--- a/Marlin/src/gcode/config/M304.cpp
+++ b/Marlin/src/gcode/config/M304.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfig.h"
 
-#if ENABLED(PIDTEMPBED)
+#if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
 
 #include "../gcode.h"
 #include "../../module/temperature.h"
diff --git a/Marlin/src/gcode/config/M7979.cpp b/Marlin/src/gcode/config/M7979.cpp
new file mode 100644
index 0000000000..868ac45c97
--- /dev/null
+++ b/Marlin/src/gcode/config/M7979.cpp
@@ -0,0 +1,292 @@
+/** //TG MODIFIED BY T.GIOIOSA  - adds many M79xx codes for Spindle control and VFD/AVR support
+ * original 10/3/21
+ * updated  12/24/22, 2/16/23
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * M codes for data exchange between Marlin and TFT35 screen over UART
+ * The direction is from the TFT point of view
+ * 
+ *  gcode   function            TFT SEND to Marlin         Marlin RETURN to TFT       Description                                             If CMD issued from REMOTE USB host
+ * -------  --------------    ---------------------      ------------------------     ------------------------------------                    -------------------------------------------------
+ * M7900    AVRBlockInfo(-PID) use M7900 F....                    M7900 R             receive/send AVRInfoBlock.PIDFLAG, 
+ *                                                                                    AVRInfoBlock.Reset_Flag, AVRInfoBlock.Display_Page, 
+ *                                                                                    AVRInfoBlock.PID_Speed,  AVRInfoBlock.Update_EEPROM,
+ *                                                                                    AVRInfoBlock.EE_chksum, AVRInfoBlock.dummy_pad_byte     *will echo to REMOTE SERIAL
+ * M7979    PID flag           use M7979 Sx                       M7900 (blockinfo)   spindle_use_pid flag, pid on/off                        *also echoes to REMOTE SERIAL
+ * M7980    RESET AVR flag     use M7980                          none                send reset AVR cmd to Marlin                            *will reset the AVR, echo ok only
+ * M7981    PID Kp,Ki,Kd       use M7981 Px Ix Dx                 M7981 R             receive/send P,I,D constants Kp, Ki, Kd                 *also echoes to REMOTE SERIAL
+ * M7982    AVR Display Page   use M7982 Px                       M7900 (blockinfo)   send AVR LCD display page # to Marlin                   *will change page, echo ok only
+ * M7983    AVR PID speed      use M7983 Sx (0, 1, 2)             M7900 (blockinfo)   change the selected AVR PID speed                       *will change preset, echo ok only
+ * M7984    AVR PID Reload     use M7984 Sx (1=current 2=default) M7900 (blockinfo)   reload a pid speed - TFT never needs to read back       *will reload, echo ok only
+ * M7985    Vacuum Enable      happens via M42 P122               see M42()           Vacuum Enable state changed in Marlin                   *no response (must use M42 cmd)
+ * M7986    Stock Top Z-axis   from printing M7986 Rx             M7986 Tx Zx         Sent during Printing Stock Top Z-axis value             *instructs Marlin to:
+ *                                                                                        R=Get Stock_Top from current Z and subtract probe plate thickess(value after R)
+ *                                                                                        S=Get Stock_Top from print gcode (val after S)(already corrected for probe thickness)
+ *                                                                                        *Results are echoed only to the TFT SERIAL_PORT!
+ * M7987    VFD Input Registers nothing	                    >>>>> auto-sent           Marlin sends every 2s (10s when printing)(see vfd.cpp)    
+ * M7988    VFD sw and comm     nothing	                          M7988 R             returns VFD sw_ver, cpu_ver, baudrate, format         
+ * M7989    TFT print state     M7990 Px 		                      M7990 ok            TFT print state sent to Marlin (0=printing,1=printing)
+ *
+ *
+ *
+ * The info sent from TFT to Marlin is stored in Marlin's AVRInfoBlock struct and avrpid[]
+ * which can be exchanged with the AVR Triac controller via I2C commands.
+ *  
+ * The main `loop()` gets the command at the front the G-code queue (if any) and runs it. Each G-code command blocks the main loop, preventing the queue
+ * from advancing until it returns. To keep essential tasks and the UI running, any commands that run a long process need to call `idle()` frequently.
+ * Don't use idle(); in loops waiting on I2C comm, it's not necessary and may actually hurt I2C comm. Use a NOP to insure while() allows CPU some time.
+ * REMEMBER - Whenever the G-code processor is busy processing a command, the G-code queue cannot advance.
+ */
+
+#include <src/MarlinCore.h>
+#include "../gcode.h"
+#include "../../inc/MarlinConfig.h"
+#include "M7979.h"
+#include "../../module/vfd.h"
+#include "../../feature/spindle_laser.h"
+#include "../../module/motion.h"
+
+char Msg[92];   //TG 12/27/22 increased from 60, for use in some of the code below that needs a buffer
+
+#if ENABLED(AVR_TRIAC_CONTROLLER) //TG 12/16/22 only if using AVR Triac Controller
+AVRINFOTYPE AVRInfoBlock;
+volatile uint8_t RecvAVRBlockComplete = 0;
+volatile uint8_t sendAVRBlockComplete = 0;
+
+// The functions below are called from gcode.cpp function process_parsed_command()
+
+
+//************************  UART CODES for TFT/MARLIN AVRBlockInfo DATA ONLY *********************************
+//M7900  - Msg from TFT to update AVR InfoBlock 
+void GcodeSuite::M7900() {    // includes data for all flags and checksum in one message (not including PID values) 
+  sendAVRBlockComplete = 0;
+  if (parser.seenval('F'))    // TFT is sending AVRInfoBlock update to us
+  {                           AVRInfoBlock.PIDFLAG = parser.value_byte();
+    if (parser.seenval('R'))  AVRInfoBlock.Reset_Flag = parser.value_byte();
+    if (parser.seenval('N'))  AVRInfoBlock.Display_Page = parser.value_byte();  
+    if (parser.seenval('S'))  AVRInfoBlock.PID_Speed = parser.value_byte();  
+    if (parser.seenval('U'))  AVRInfoBlock.Update_EEPROM = parser.value_byte();
+    if (parser.seenval('C'))  AVRInfoBlock.EE_chksum = parser.value_int();
+    if (parser.seenval('B'))  AVRInfoBlock.Reload_Preset = parser.value_byte();
+    if (parser.seenval('D'))  AVRInfoBlock.Data_Interval = parser.value_byte();
+    if (parser.seenval('P'))  AVRInfoBlock.PID_Interval = parser.value_byte();
+    cutter.spindle_use_pid =  AVRInfoBlock.PIDFLAG;   // update Marlin's internal pid flag   
+    while(sendAVRBlockComplete == 0){NOP};            // wait till AVR has picked up the new data block via I2C
+    
+    /* no other response to wait for with this command */
+    
+    sprintf(Msg,"M7900 OK\n");                        // respond back to TFT that AVRInfoBlock update is completed
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();
+  }
+    
+  if (parser.seen('R'))       // TFT requesting we send AVRInfoBlock to it
+  {
+    uint16_t chksum = get_chksum();
+    sprintf(Msg,"M7900 F%d R%d N%d S%d U%d C%u B%d D%d P%d\n", AVRInfoBlock.PIDFLAG, AVRInfoBlock.Reset_Flag, 
+                  AVRInfoBlock.Display_Page, AVRInfoBlock.PID_Speed, AVRInfoBlock.Update_EEPROM, AVRInfoBlock.EE_chksum,
+                  AVRInfoBlock.Reload_Preset, AVRInfoBlock.Data_Interval, AVRInfoBlock.PID_Interval);
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();
+  }
+}
+
+//**************************************************************************************************
+//M7979  - UART send from TFT the PID_FLAG for Marlin & AVR - TFT reads this in M7900 request
+void GcodeSuite::M7979() {            // and AVR I2C Master reads when requesting AVRInfoBlock
+  if (parser.seen('S')) 
+  {  
+    cutter.spindle_use_pid = parser.value_byte()==1 ? true : false;
+    AVRInfoBlock.PIDFLAG = cutter.spindle_use_pid;
+  }
+  else // no parameters - just emit a message to the serial port
+    SERIAL_ECHOLNPGM("Spindle Use PID: M7979: ", cutter.spindle_use_pid);
+
+  sendAVRBlockComplete = 0;
+  while(sendAVRBlockComplete == 0){NOP};        // wait till AVR has picked up the new data block via I2C
+  
+  /* no other response to wait for with this command */
+
+  sprintf(Msg,"M7979 OK\n");                    // signal TFT that PIDFLAG update is completed
+  SERIAL_ECHOPGM(Msg);
+  SERIAL_EOL();
+}
+
+//************************  UART CODES for TFT SENDING DATA ONLY ***********************************
+//M7980  - UART send from TFT reset flag to AVR   - the TFT will never request this value  
+void GcodeSuite::M7980() {    
+  
+  AVRInfoBlock.Reset_Flag = 1;        // AVR I2C Master will see flag via AVRInfoBlock
+  
+  /* don't wait for (sendAVRBlockComplete == 0) it will never come, instead wait for (RecvAVRBlockComplete == 0) since
+     the AVR sends I2C RCV_AVR_INFO_BLOCK on restart. This delays the M7980 OK to the TFT until the restart is completed */
+  RecvAVRBlockComplete = 0;
+  while(RecvAVRBlockComplete == 0){NOP};  // AVR asks us to receive only on startup(reset) & PID_Speed change
+  
+  sprintf(Msg,"M7980 OK\n");          // signal TFT AVR Reset is completed
+  SERIAL_ECHOPGM(Msg);
+  SERIAL_EOL();
+}
+
+//************************  UART CODES for TFT SENDING & RECEIVING DATA ****************************
+//M7981  - UART send from TFT / Read back to TFT for P,I,D updates
+/**SEND AND RECEIVE PID** constants to/from the TFT LCD and Marlin's buffer array avr_pid[] (source for I2C data exchange with AVR Controller*/
+void GcodeSuite::M7981() {    
+  if (parser.seenval('P'))    // TFT is sending us PID constants from TFT avrTriac menu to update Marlin's copies 
+  {                           AVRInfoBlock.KP = parser.value_float();  // receive data from TFT into array buffer
+    if (parser.seenval('I'))  AVRInfoBlock.KI = parser.value_float();
+    if (parser.seenval('D'))  AVRInfoBlock.KD = parser.value_float();
+    
+    sendAVRBlockComplete = 0;
+    while(sendAVRBlockComplete == 0){NOP};    // wait till AVR has picked up the new data block via I2C
+    
+    /* no other response to wait for with this command */
+
+    sprintf(Msg,"M7981 OK\n");        // signal TFT that KP,KI,KD update is completed
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();
+  }
+  
+  if (parser.seen('R'))       // TFT requesting PID constants, we  will send Marlin's current copies
+  {
+    sprintf(Msg,"M7981 P%3.4f I%3.4f D%3.4f\n", AVRInfoBlock.KP, AVRInfoBlock.KI, AVRInfoBlock.KD);
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();
+  }
+}
+//**************************************************************************************************
+
+//M7982  - UART send from TFT to cycle AVR LCD display   - TFT reads this in M7900 request
+void GcodeSuite::M7982() {    
+  if (parser.seenval('P'))  // TFT sending us page number for AVR display
+  {
+    AVRInfoBlock.Display_Page = parser.value_byte();// get page 0,1,2 gets read when Master requests AVRBlockInfo
+    sendAVRBlockComplete = 0;
+    while(sendAVRBlockComplete == 0){NOP};// wait till AVR has picked up the new data block
+    
+    /* no response to wait for with this command */
+
+    sprintf(Msg,"M7982 OK\n");          // signal TFT page change is completed
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();  
+  }
+}
+
+//M7983  - UART send  from TFT to update AVR pid speed - TFT reads this in M7900 request
+void GcodeSuite::M7983() {     
+  if (parser.seenval('S'))  // TFT sending us PID Speed preset number
+  {
+    AVRInfoBlock.PID_Speed = parser.value_byte();   // get speed 0,1,2
+    while(sendAVRBlockComplete == 0){NOP};          // wait till it's been sent over I2C 
+
+    RecvAVRBlockComplete = 0;
+    while(RecvAVRBlockComplete == 0){NOP};          // Wait for AVR's response (only on startup & PID_Speed change)    
+    
+    sprintf(Msg,"M7983 OK\n");                      // signal TFT change is completed
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();
+  }
+}
+
+//M7984  - UART send  from TFT to reload a pid speed - TFT should never need to read this back
+void GcodeSuite::M7984() {     
+    if(parser.seenval('S'))   //TFT sending S1=reload pidSpeed or S2=reload default 
+      AVRInfoBlock.Reload_Preset = parser.value_byte();
+    
+    // pass AVRInfoBlock.Reload_Preset command to AVR on next I2C ExchangeMarlinData pass
+    sendAVRBlockComplete = 0;
+    RecvAVRBlockComplete = 0;
+    while(sendAVRBlockComplete == 0){NOP};    // wait till it's been sent over I2C 
+    
+    
+    while(RecvAVRBlockComplete == 0){NOP}     // Wait for AVR's response (only on startup & PID_Speed change)
+    
+    AVRInfoBlock.Reload_Preset = 0;     // be sure to reset it to avoid multiple sends
+    sprintf(Msg,"M7984 OK\n");          // signal the TFT that reload is completed
+    SERIAL_ECHOPGM(Msg);
+    SERIAL_EOL();
+}
+
+uint16_t get_chksum()
+{	
+	// create a unique checksum, some byte values can be ambiguous (i.e. suppose PIDFLAG=1 and
+	// Reset_Flag=0, if they each toggled state there's no change to a simple summing checksum)
+	// therefore we multiply each item by different amounts to make them unique.
+	uint8_t i;
+	uint16_t cs = 0;
+	uint8_t * ifb = &AVRInfoBlock.PIDFLAG;
+
+	uint8_t max = sizeof(AVRInfoBlock) - 2;		// don't include cs word, last 2 bytes
+	for (i=0; i<max; i++)
+	{
+		cs += (*ifb++) * (max-i);				// give each item a different "weight"
+	}
+	return cs;
+}
+
+#endif // #if ENABLED(AVR_TRIAC_CONTROLLER)
+
+
+/*M7986  - This Gcode sent during Printing - the Z-Axis value of the Stock Top - TFT can read this back
+  NOTE: The gcode parser always replies to the source of a gcode command, which is fine most of the time.
+  However, since M7986 is expected to come from a print file, the source may not always be the SD Card on
+  the TFT, it could be the SD on the SGEN board, OctoPrint, USB port, etc. We have to send the message below
+  always to the TFT no matter what source sent the M7986 Rx. The PORT_REDIRECT macro let's us temporarily
+  switch where the serial output will be directed.
+*/
+void GcodeSuite::M7986() {     
+    if(parser.seenval('S')){   // S=Stock_Top from print gcode (already corrected for probe thickness)
+    // echo printer-sent value as Stock_Top and native machine Zmax to TFT immediately, TFT will not ask
+    sprintf(Msg,"M7986 T%3.2f Z%3.2f ok\n", parser.value_float(), (float)Z_MAX_POS);
+    PORT_REDIRECT(SERIAL_PORTMASK(SERIAL_PORT));  // ensure we send to the TFT (in case source was not the TFT)
+    SERIAL_ECHOPGM(Msg);
+    }
+    if(parser.seenval('R')){   // R=Get Stock_Top from current Z pos plus probe thickess(value after R)
+    // echo current Z position as Stock_Top and native machine Zmax to TFT immediately, TFT will not ask
+    sprintf(Msg,"M7986 T%3.2f Z%3.2f ok\n", (float)current_position.z + parser.value_float(), (float)Z_MAX_POS);
+    PORT_REDIRECT(SERIAL_PORTMASK(SERIAL_PORT));  // ensure we send to the TFT (in case source was not the TFT)
+    SERIAL_ECHOPGM(Msg);
+    }  
+}
+
+#if ENABLED(VFD_CONTROLLER)			 //TG 12/16/22 only if using VFD controller
+
+//***** THIS IS NOT IMPLEMENTED HERE ***********************************************
+// M7987 used to auto-report VFD Input Register values to TFT - handled in vfd.cpp *
+//**********************************************************************************
+
+void GcodeSuite::M7988() {       //TG 12/23/22 added 
+    if(parser.seen('R')){
+      uint16_t baudrate, format, swver, cpuver;
+
+      baudrate=format=swver=cpuver=0;
+      if (VFDpresent==true)							// if VFD connected
+      {
+        statusPollingAllowed = false;   // halt status polling so we don't have collision
+        bool status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, 164, 0x0001);
+        if (status==true)
+          baudrate = mbResponseMsg[4];
+        status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, 165, 0x0001);
+        if (status==true)
+          format = mbResponseMsg[4];
+        statusPollingAllowed = true;    // allow status polling, we're done
+      }
+      sprintf(Msg,"M7988 SW%d CP%d BR%d FT%d ok\n",sw_ver, cpu_ver, baudrate, format);
+      PORT_REDIRECT(SERIAL_PORTMASK(SERIAL_PORT));  // ensure we send to the TFT (in case source was not the TFT)
+      SERIAL_ECHOPGM(Msg);
+      PORT_RESTORE(); 
+    }
+}
+
+void  GcodeSuite::M7989() {   //TG 2/13/23 added - receive TFT printing state from TFT
+    if (parser.seen('P')) 
+    {  
+      tftPrinting = parser.value_byte()==1 ? true : false;  //get TFT SD printing state
+      SERIAL_ECHOLNPGM("M7989 ok");                         // acknowledge receipt
+    }
+
+}
+
+
+#endif // #if ENABLED(VFD_CONTROLLER)	
\ No newline at end of file
diff --git a/Marlin/src/gcode/config/M7979.h b/Marlin/src/gcode/config/M7979.h
new file mode 100644
index 0000000000..f70507a22e
--- /dev/null
+++ b/Marlin/src/gcode/config/M7979.h
@@ -0,0 +1,42 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * Support for Custom G Code additions for CNC and AVR Triac Controller
+ * 
+ * 7/23/22 - 10/4/22
+ */
+
+#ifndef M7979_H_
+#define M7979_H_
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(AVR_TRIAC_CONTROLLER) //TG 12/16/22
+#include "../gcode.h"
+#include "../../feature/spindle_laser.h"
+
+// this struct must be the same alignment and total size in all three project modules
+// BigTree TFT35, Marlin, and AVR CNC Control
+typedef struct 
+{
+  uint8_t PIDFLAG;
+  uint8_t Reset_Flag;
+  uint8_t Display_Page;
+  uint8_t PID_Speed;
+  uint8_t Data_Interval;
+  uint8_t PID_Interval;
+  float KP;
+  float KI;
+  float KD;
+  uint8_t Update_EEPROM;
+  uint8_t Reload_Preset;
+  uint16_t EE_chksum;
+} __attribute__ ((packed)) AVRINFOTYPE;   //TG packed attribute forces smallest size for structure 
+extern AVRINFOTYPE AVRInfoBlock;
+
+uint16_t get_chksum();
+
+extern volatile uint8_t RecvAVRBlockComplete;
+extern volatile uint8_t sendAVRBlockComplete;
+
+#endif // #if ENABLED(AVR_TRIAC_CONTROLLER)
+
+#endif // #ifndef M7979_H_
\ No newline at end of file
diff --git a/Marlin/src/gcode/control/M3-M5.cpp b/Marlin/src/gcode/control/M3-M5.cpp
index 5d5d44e8bf..8020e4b63b 100644
--- a/Marlin/src/gcode/control/M3-M5.cpp
+++ b/Marlin/src/gcode/control/M3-M5.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -18,6 +18,8 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
+ *
+ * Updated: 12/16/22
  */
 
 #include "../../inc/MarlinConfig.h"
@@ -25,8 +27,19 @@
 #if HAS_CUTTER
 
 #include "../gcode.h"
+#include "../../module/temperature.h"           //TG 9/21/21 added
 #include "../../feature/spindle_laser.h"
+#include "../../module/stepper.h"
 #include "../../module/planner.h"
+#if ENABLED(TG_I2C_SUPPORT)	//TG 12/16/22
+  #include "../../module/TG_I2C/TG_I2CSlave.h"    //TG 5/12/22 added for I2C comm with AVR Triac Controller board.
+#endif
+#if ENABLED(USE_RPM_SENSOR)
+  #include "../../module/rpmSensor/RPMTimer.h"  //TG 12/20/22 put #if clause
+#endif 
+#if ENABLED(VFD_CONTROLLER)	//TG 12/16/22
+  #include "../../module/vfd.h"
+#endif
 
 /**
  * Laser:
@@ -49,7 +62,8 @@
  *  M5 - Spindle OFF
  *
  * Parameters:
- *  S<power> - Set power. S0 will turn the spindle/laser off.
+ *  S<power> - Set power. S0 will turn the spindle/laser off, except in relative mode.
+ *  O<ocr>   - Set power and OCR (oscillator count register)
  *
  *  If no PWM pin is defined then M3/M4 just turns it on or off.
  *
@@ -75,14 +89,26 @@
  *
  *  PWM duty cycle goes from 0 (off) to 255 (always on).
  */
-void GcodeSuite::M3_M4(const bool is_M4) {
+
+/****************************************************************************************************************************
+*TG ***** NOTE: With the new AVR Triac Controller board, the actual spindle speed is controlled there, and Marlin PWM pin P1_23
+* is no longer used for speed control. The following code needs only to read the speed from M3 and M4 commands and forward
+* it to the AVR Triac Controller via TARGET_RPM variable over I2C comm.
+*
+* This is changing as of 12/16/22, the code will now have to handle different options:
+* 1= original Marlin Spindle with SPINDLE_LASER_USE_PWM enabled  to control speed
+* 2= AVR_TRIAC_CONTROLLER used for speed control and PID, RPM sensor is handled there
+* 3= VFD_CONTROLLER used for speed control, RPM sensor handled by Marlin
+*************************************************************************************************************************/
+
+void GcodeSuite::M3_M4(const bool is_M4) {      //TG set cutter.unitPower from 'S' parameter or default SPEED_POWER_STARTUP
   #if LASER_SAFETY_TIMEOUT_MS > 0
     reset_stepper_timeout(); // Reset timeout to allow subsequent G-code to power the laser (imm.)
   #endif
-
+  
   if (cutter.cutter_mode == CUTTER_MODE_STANDARD)
     planner.synchronize();   // Wait for previous movement commands (G0/G1/G2/G3) to complete before changing power
-
+  
   #if ENABLED(LASER_FEATURE)
     if (parser.seen_test('I')) {
       cutter.cutter_mode = is_M4 ? CUTTER_MODE_DYNAMIC : CUTTER_MODE_CONTINUOUS;
@@ -90,20 +116,20 @@ void GcodeSuite::M3_M4(const bool is_M4) {
       cutter.set_enabled(true);
     }
   #endif
-
-  auto get_s_power = [] {
-    float u;
-    if (parser.seenval('S')) {
-      const float v = parser.value_float();
+  //WRITE(P4_28,1);
+  auto get_s_power = [] {  //TG this lambda function inside a function gets the SXXXXX value, i.e. 7000 for S7000, and sets unitPower
+    float u = 0;
+    if (parser.seenval('S')) {								// speed was given
+      const float v = parser.value_float();					// v is the RPM or PWM or % Target Value from the LCD display
       u = TERN(LASER_POWER_TRAP, v, cutter.power_to_range(v));
-    }
-    else if (cutter.cutter_mode == CUTTER_MODE_STANDARD)
+	  }
+    else if (cutter.cutter_mode == CUTTER_MODE_STANDARD) 	// if no S value given, use SPEED_POWER_STARTUP
       u = cutter.cpwr_to_upwr(SPEED_POWER_STARTUP);
 
-    cutter.menuPower = cutter.unitPower = u;
+	cutter.menuPower = cutter.unitPower = u;				// update menuPower for display, unitPower is RPM or PWM or %
 
     // PWM not implied, power converted to OCR from unit definition and on/off if not PWM.
-    cutter.power = TERN(SPINDLE_LASER_USE_PWM, cutter.upower_to_ocr(u), u > 0 ? 255 : 0);
+    cutter.power = TERN(SPINDLE_LASER_USE_PWM, cutter.upower_to_ocr(u), u > 0 ? SPINDLE_LASER_PWM_RES : 0);
     return u;
   };
 
@@ -115,25 +141,56 @@ void GcodeSuite::M3_M4(const bool is_M4) {
         // With power sync we only set power so it does not effect queued inline power sets
         planner.buffer_sync_block(BLOCK_BIT_LASER_PWR);                                            // Send the flag, queueing inline power
       #else
-        planner.synchronize();
+        planner.synchronize();		// Wait for previous movement commands (G0/G0/G2/G3) to complete before changing power
         cutter.inline_power(cutter.power);
       #endif
     #endif
   }
   else {
-    cutter.set_enabled(true);
+    cutter.set_enabled(true);		// turn on ENABLE signal
     get_s_power();
-    cutter.apply_power(
-      #if ENABLED(SPINDLE_SERVO)
-        cutter.unitPower
-      #elif ENABLED(SPINDLE_LASER_USE_PWM)
-        cutter.upower_to_ocr(cutter.unitPower)
-      #else
-        cutter.unitPower > 0 ? 255 : 0
-      #endif
-    );
+    if (cutter.spindle_use_pid == false)  //TG 9/15/21 if using classic PID algorithm in RPMTimer.cpp, it will set the power, so skip below
+    {
+      cutter.apply_power(
+        #if ENABLED(SPINDLE_SERVO)
+          cutter.unitPower
+        #elif ENABLED(SPINDLE_LASER_USE_PWM)
+          cutter.upower_to_ocr(cutter.unitPower)				// set a PWM value
+        #else
+          cutter.unitPower > 0 ? SPINDLE_LASER_PWM_RES : 0	// set on=1023 or off=0
+        #endif
+      );
+    }
     TERN_(SPINDLE_CHANGE_DIR, cutter.set_reverse(is_M4));
   }
+
+  SpindleLaser::isReadyForUI = true;
+    
+  //TG added 5/12/22 - update TARGET_RPM variable used for I2C reply to AVR Controller request or Serial/RS485 send to VFD Controller
+  cutter.TARGET_RPM = cutter.menuPower;               
+  //TG added 9/21/21 to also set value in spindle_speed array, index 0 (there's only 1 spindle), this also echoes the Target/Actual to serial ports
+  Temperature::set_spindle_speed(0,cutter.unitPower);   
+  
+  #if ENABLED(VFD_CONTROLLER)   //TG 12/16/22 - VFD Controller needs to be sent the TARGET_RPM value and set to RUN
+          
+    uint16_t data = (10 * cutter.TARGET_RPM)/60;  // Vevor frequency specified 1 dec point so * 10
+    if (VFDpresent==true)							            // if VFD connected
+    { 
+      statusPollingAllowed = false;               // stop status polling we need the RS485 port
+      // First, set target frequency cmd to serial port to VFD and get success or fail response  
+      bool status = writeVevorVFD(VFDnum, MODBUS_WRITE_FUNC_REG, VEVOR_FREQUENCY, data);
+
+      // check is_M4 and RUN REVERSE to VFD if needed, otherwise RUN FORWARD
+      // if all good then run forward SEND TO SERIAL PORT AND OPTIONAL WAIT FOR RESPONSE
+      if (status==true) {
+        status = writeVevorVFD(VFDnum, MODBUS_WRITE_FUNC_REG, VEVOR_MAIN_CONTROL_BITS, (is_M4 ? sRUN_REV : sRUN_FWD));
+      }
+      statusPollingAllowed = true;                // allow status polling, we're done
+    }
+  
+  #endif
+
+  //WRITE(P4_28,0);
 }
 
 /**
@@ -142,15 +199,39 @@ void GcodeSuite::M3_M4(const bool is_M4) {
 void GcodeSuite::M5() {
   planner.synchronize();
   cutter.power = 0;
-  cutter.apply_power(0);                          // M5 just kills power, leaving inline mode unchanged
+  cutter.apply_power(0);                // M5 just kills power, leaving inline mode unchanged
+  cutter.set_enabled(false);            // also sets power to zero (but not unitPower!)
+  cutter.unitPower = 0;                 //TG make sure to zero the unitPower, otherwise it holds last target
+  cutter.menuPower = 0;                 //update menuPower for display, unitPower is RPM or PWM or %
+  
   if (cutter.cutter_mode != CUTTER_MODE_STANDARD) {
     if (parser.seen_test('I')) {
       TERN_(LASER_FEATURE, cutter.inline_power(cutter.power));
       cutter.set_enabled(false);                  // Needs to happen while we are in inline mode to clear inline power.
       cutter.cutter_mode = CUTTER_MODE_STANDARD;  // Switch from inline to standard mode.
     }
-  }
+  } 
   cutter.set_enabled(false);                      // Disable enable output setting
+  
+  //TG added 5/12/22 - update TARGET_RPM for I2C to reply to AVR Controller request or Serial/RS485 send to VFD Controller
+  cutter.TARGET_RPM = 0;                              
+  Temperature::set_spindle_speed(0,0);  //TG added 9/24/21 to set value in spindle_speed array, index 0, 
+                                        //this also echoes the Target/Actual to serial ports
+ 
+ #if ENABLED(VFD_CONTROLLER)            //TG 12/16/22 - VFD Controller needs to be sent the TARGET_RPM value and set to STOP
+  if (VFDpresent==true)                 // if VFD connected
+  {							            
+    statusPollingAllowed = false;       // stop status polling we need the RS485 port
+    // Send STOP command to VFD 
+    bool status = writeVevorVFD(VFDnum, MODBUS_WRITE_FUNC_REG, VEVOR_MAIN_CONTROL_BITS, sRUN_STOP);
+  
+    // if not successful, send one more time
+    if (status == false)
+      status = writeVevorVFD(VFDnum, MODBUS_WRITE_FUNC_REG, VEVOR_MAIN_CONTROL_BITS, sRUN_STOP);
+    statusPollingAllowed = true;        // allow status polling, we're done
+  }
+ #endif // ENABLED(VFD_CONTROLLER)  
+
 }
 
 #endif // HAS_CUTTER
diff --git a/Marlin/src/gcode/control/M42.cpp b/Marlin/src/gcode/control/M42.cpp
index 1b3a29d100..0fc48de0cc 100644
--- a/Marlin/src/gcode/control/M42.cpp
+++ b/Marlin/src/gcode/control/M42.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -22,6 +22,8 @@
 
 #include "../../inc/MarlinConfig.h"
 
+#include <pwm.h>    //TG 6/27/21 needed for TG-modified code below
+
 #if ENABLED(DIRECT_PIN_CONTROL)
 
 #include "../gcode.h"
@@ -117,16 +119,56 @@ void GcodeSuite::M42() {
     SERIAL_ECHOLNPGM("?Cannot write to INPUT");
     return;
   }
-
+  //TG - 10/7/21 this is old version of below
+  //pinMode(pin, OUTPUT);
+  //extDigitalWrite(pin, pin_status);
+  //analogWrite(pin, pin_status);
+  
+  //***************************************************************************************************************
+  //TG 6/27/21 Modified the original code (3 lines above) with new code. Added new parameter 'A' to specify
+  //if pin should be treated as analog PWM, example: "M42 P123 S127 A1" where A1 specifies analog PWM. If the
+  //'A1' is left off, pin will default to GPIO digital output pin. The '1' after 'A' can be any number, just
+  //needs to be at least one digit. In PWM mode, S=0 to 255. In Digital mode S=0 is OFF, S=1 to 255 is ON.
+  //The analog mode can write to Hardware or Software PWM. If the pin is not a Hardware PWM pin on the LPC,
+  //then the Software PWM will be used. Both PWM frequencies are 50Hz by default (in pwm.h), but the Hardware
+  //PWM(LPC_PWM1) freq is set higher to (SPINDLE_LASER_FREQUENCY) if SPINDLE_FEATURE or LASER_FEATURE is enabled.
+  //To change Software PWM frequency, make a call to SoftwarePWM::set_frequency(frequency) or change pwm.h.
+  if (parser.seenval('A'))    
+  {                           
+    LPC176x::pwm_attach_pin(pin, pin_status); // re-attach pin as PWM (when pin was set to GPIO by extDigitalWrite)
+    analogWrite(pin, pin_status);             // treat as PWM (hardware or software)
+  }
+  else
+  {  
+    //if (LPC176x::HardwarePWM::active(pin) || LPC176x::SoftwarePWM::active(pin))
+    LPC176x::pwm_detach_pin(pin);             // if previously mapped as a PWM pin, detach it first 
   // An OUTPUT_OPEN_DRAIN should not be changed to normal OUTPUT (STM32)
   // Use M42 Px M1/5 S0/1 to set the output type and then set value
   #ifndef OUTPUT_OPEN_DRAIN
     pinMode(pin, OUTPUT);
   #endif
-  extDigitalWrite(pin, pin_status);
+    extDigitalWrite(pin, pin_status);         // treat as GPIO pin
+  }
+
+  //TG 9/25/22 - added this to update TFT whenever Marlin sets vacuum on or off during an SD print or Remote Terminal
+  // M42 command. Otherwise without this, the TFT would only know the vacuum state if changed on the TFT screen itself.
+  if(pin == VACUUM_ENA_PIN)
+  {
+    SERIAL_ECHOPGM("M7985 S", pin_status);    // signal the TFT that vacuum changed state
+    SERIAL_EOL();
+  }
+ 
+  //TG 6/27/21 this line was useful for debugging to see the Function mode of the pin
+  //LPC176x::Function pf = (LPC176x::Function)LPC176x::pin_type{pin}.function();
+
+  //TG 6/26/21 ALSO ! Be sure to use modified versions of SoftwarePWM.cpp and SoftwarePWM.h
+  //from "C:\Users\tony\.platformio\packages\framework-arduino-lpc176x\system\lpc176x\"
+  //They are modified to use Timer2 for SoftPWM (instead of Timer3 as in the original files) !
+  //Timer3 has been reassigned for use as RPM sensor capture.
+  //***************************************************************************************************************
 
   #ifdef ARDUINO_ARCH_STM32
-    // A simple I/O will be set to 0 by hal.set_pwm_duty()
+    // A simple I/O will be set to 0 by set_pwm_duty()
     if (pin_status <= 1 && !PWM_PIN(pin)) return;
   #endif
   hal.set_pwm_duty(pin, pin_status);
diff --git a/Marlin/src/gcode/feature/L6470/M122.cpp b/Marlin/src/gcode/feature/L6470/M122.cpp
new file mode 100644
index 0000000000..4a5629b049
--- /dev/null
+++ b/Marlin/src/gcode/feature/L6470/M122.cpp
@@ -0,0 +1,151 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if HAS_L64XX
+
+#include "../../gcode.h"
+#include "../../../libs/L64XX/L64XX_Marlin.h"
+#include "../../../module/stepper/indirection.h"
+
+void echo_yes_no(const bool yes);
+
+inline void L6470_say_status(const L64XX_axis_t axis) {
+  if (L64xxManager.spi_abort) return;
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
+  L64xxManager.get_status(axis);
+  L64xxManager.say_axis(axis);
+  #if ENABLED(L6470_CHITCHAT)
+    char temp_buf[20];
+    sprintf_P(temp_buf, PSTR("   status: %4x   "), sh.STATUS_AXIS_RAW);
+    SERIAL_ECHO(temp_buf);
+    print_bin(sh.STATUS_AXIS_RAW);
+    switch (sh.STATUS_AXIS_LAYOUT) {
+      case L6470_STATUS_LAYOUT: SERIAL_ECHOPGM("   L6470"); break;
+      case L6474_STATUS_LAYOUT: SERIAL_ECHOPGM("   L6474"); break;
+      case L6480_STATUS_LAYOUT: SERIAL_ECHOPGM("   L6480/powerSTEP01"); break;
+    }
+  #endif
+  SERIAL_ECHOPGM("\n...OUTPUT: ");
+  SERIAL_ECHOF(sh.STATUS_AXIS & STATUS_HIZ ? F("OFF") : F("ON "));
+  SERIAL_ECHOPGM("   BUSY: "); echo_yes_no((sh.STATUS_AXIS & STATUS_BUSY) == 0);
+  SERIAL_ECHOPGM("   DIR: ");
+  SERIAL_ECHOF((((sh.STATUS_AXIS & STATUS_DIR) >> 4) ^ L64xxManager.index_to_dir[axis]) ? F("FORWARD") : F("REVERSE"));
+  if (sh.STATUS_AXIS_LAYOUT == L6480_STATUS_LAYOUT) {
+    SERIAL_ECHOPGM("   Last Command: ");
+    if (sh.STATUS_AXIS & sh.STATUS_AXIS_WRONG_CMD) SERIAL_ECHOPGM("VALID");
+    else                                           SERIAL_ECHOPGM("ERROR");
+    SERIAL_ECHOPGM("\n...THERMAL: ");
+    switch ((sh.STATUS_AXIS & (sh.STATUS_AXIS_TH_SD | sh.STATUS_AXIS_TH_WRN)) >> 11) {
+      case 0: SERIAL_ECHOPGM("DEVICE SHUTDOWN"); break;
+      case 1: SERIAL_ECHOPGM("BRIDGE SHUTDOWN"); break;
+      case 2: SERIAL_ECHOPGM("WARNING        "); break;
+      case 3: SERIAL_ECHOPGM("OK             "); break;
+    }
+  }
+  else {
+    SERIAL_ECHOPGM("   Last Command: ");
+    if (!(sh.STATUS_AXIS & sh.STATUS_AXIS_WRONG_CMD)) SERIAL_ECHOPGM("IN");
+    SERIAL_ECHOPGM("VALID    ");
+    SERIAL_ECHOF(sh.STATUS_AXIS & sh.STATUS_AXIS_NOTPERF_CMD ?  F("COMPLETED    ") : F("Not PERFORMED"));
+    SERIAL_ECHOPGM("\n...THERMAL: ", !(sh.STATUS_AXIS & sh.STATUS_AXIS_TH_SD) ? "SHUTDOWN       " : !(sh.STATUS_AXIS & sh.STATUS_AXIS_TH_WRN) ? "WARNING        " : "OK             ");
+  }
+  SERIAL_ECHOPGM("   OVERCURRENT:"); echo_yes_no((sh.STATUS_AXIS & sh.STATUS_AXIS_OCD) == 0);
+  if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) {
+    SERIAL_ECHOPGM("   STALL:"); echo_yes_no((sh.STATUS_AXIS & sh.STATUS_AXIS_STEP_LOSS_A) == 0 || (sh.STATUS_AXIS & sh.STATUS_AXIS_STEP_LOSS_B) == 0);
+    SERIAL_ECHOPGM("   STEP-CLOCK MODE:"); echo_yes_no((sh.STATUS_AXIS & sh.STATUS_AXIS_SCK_MOD) != 0);
+  }
+  else {
+    SERIAL_ECHOPGM("   STALL: NA "
+                   "   STEP-CLOCK MODE: NA"
+                   "   UNDER VOLTAGE LOCKOUT: "); echo_yes_no((sh.STATUS_AXIS & sh.STATUS_AXIS_UVLO) == 0);
+  }
+  SERIAL_EOL();
+}
+
+/**
+ * M122: Debug L6470 drivers
+ */
+void GcodeSuite::M122() {
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+  L64xxManager.spi_active = true;   // Tell set_directions() a series of SPI transfers is underway
+
+  //if (parser.seen('S'))
+  //  tmc_set_report_interval(parser.value_bool());
+  //else
+
+  #if AXIS_IS_L64XX(X)
+    L6470_say_status(X);
+  #endif
+  #if AXIS_IS_L64XX(X2)
+    L6470_say_status(X2);
+  #endif
+  #if AXIS_IS_L64XX(Y)
+    L6470_say_status(Y);
+  #endif
+  #if AXIS_IS_L64XX(Y2)
+    L6470_say_status(Y2);
+  #endif
+  #if AXIS_IS_L64XX(Z)
+    L6470_say_status(Z);
+  #endif
+  #if AXIS_IS_L64XX(Z2)
+    L6470_say_status(Z2);
+  #endif
+  #if AXIS_IS_L64XX(Z3)
+    L6470_say_status(Z3);
+  #endif
+  #if AXIS_IS_L64XX(Z4)
+    L6470_say_status(Z4);
+  #endif
+  #if AXIS_IS_L64XX(E0)
+    L6470_say_status(E0);
+  #endif
+  #if AXIS_IS_L64XX(E1)
+    L6470_say_status(E1);
+  #endif
+  #if AXIS_IS_L64XX(E2)
+    L6470_say_status(E2);
+  #endif
+  #if AXIS_IS_L64XX(E3)
+    L6470_say_status(E3);
+  #endif
+  #if AXIS_IS_L64XX(E4)
+    L6470_say_status(E4);
+  #endif
+  #if AXIS_IS_L64XX(E5)
+    L6470_say_status(E5);
+  #endif
+  #if AXIS_IS_L64XX(E6)
+    L6470_say_status(E6);
+  #endif
+  #if AXIS_IS_L64XX(E7)
+    L6470_say_status(E7);
+  #endif
+
+  L64xxManager.spi_active = false;   // done with all SPI transfers - clear handshake flags
+  L64xxManager.spi_abort = false;
+  L64xxManager.pause_monitor(false);
+}
+
+#endif // HAS_L64XX
diff --git a/Marlin/src/gcode/feature/L6470/M906.cpp b/Marlin/src/gcode/feature/L6470/M906.cpp
new file mode 100644
index 0000000000..f55405b798
--- /dev/null
+++ b/Marlin/src/gcode/feature/L6470/M906.cpp
@@ -0,0 +1,380 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if HAS_L64XX
+
+#if AXIS_COLLISION('I')
+  #error "M906 parameter collision with axis name."
+#endif
+
+#include "../../gcode.h"
+#include "../../../libs/L64XX/L64XX_Marlin.h"
+#include "../../../module/stepper/indirection.h"
+#include "../../../module/planner.h"
+
+#define DEBUG_OUT ENABLED(L6470_CHITCHAT)
+#include "../../../core/debug_out.h"
+
+/**
+ * MACRO to fetch information on the items associated with current limiting
+ * and maximum voltage output.
+ *
+ * L6470 can be setup to shutdown if either current threshold is exceeded.
+ *
+ * L6470 output current can not be set directly.  It is set indirectly by
+ * setting the maximum effective output voltage.
+ *
+ *  Effective output voltage is set by PWM duty cycle.
+ *
+ *  Maximum effective output voltage is affected by MANY variables.  The main ones are:
+ *    KVAL_HOLD
+ *    KVAL_RUN
+ *    KVAL_ACC
+ *    KVAL_DEC
+ *    Vs compensation (if enabled)
+ */
+void L64XX_report_current(L64XX &motor, const L64XX_axis_t axis) {
+
+  if (L64xxManager.spi_abort) return;  // don't do anything if set_directions() has occurred
+
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
+  const uint16_t status = L64xxManager.get_status(axis);    //also populates shadow structure
+  const uint8_t OverCurrent_Threshold = uint8_t(motor.GetParam(L6470_OCD_TH));
+
+  auto say_axis_status = [](const L64XX_axis_t axis, const uint16_t status) {
+    L64xxManager.say_axis(axis);
+    #if ENABLED(L6470_CHITCHAT)
+      char tmp[10];
+      sprintf_P(tmp, PSTR("%4x   "), status);
+      DEBUG_ECHOPGM("   status: ", tmp);
+      print_bin(status);
+    #else
+      UNUSED(status);
+    #endif
+    SERIAL_EOL();
+  };
+
+  char temp_buf[10];
+
+  switch (sh.STATUS_AXIS_LAYOUT) {
+    case L6470_STATUS_LAYOUT:       // L6470
+    case L6480_STATUS_LAYOUT: {     // L6480 & powerstep01
+      const uint16_t Stall_Threshold = (uint8_t)motor.GetParam(L6470_STALL_TH),
+                     motor_status = (status & (STATUS_MOT_STATUS)) >> 5,
+                     L6470_ADC_out = motor.GetParam(L6470_ADC_OUT),
+                     L6470_ADC_out_limited = constrain(L6470_ADC_out, 8, 24);
+      const float comp_coef = 1600.0f / L6470_ADC_out_limited;
+      const uint16_t MicroSteps = _BV(motor.GetParam(L6470_STEP_MODE) & 0x07);
+
+      say_axis_status(axis, sh.STATUS_AXIS_RAW);
+
+      SERIAL_ECHOPGM("...OverCurrent Threshold: ");
+      sprintf_P(temp_buf, PSTR("%2d ("), OverCurrent_Threshold);
+      SERIAL_ECHO(temp_buf);
+      SERIAL_ECHO((OverCurrent_Threshold + 1) * motor.OCD_CURRENT_CONSTANT_INV);
+      SERIAL_ECHOPGM(" mA)");
+      SERIAL_ECHOPGM("   Stall Threshold: ");
+      sprintf_P(temp_buf, PSTR("%2d ("), Stall_Threshold);
+      SERIAL_ECHO(temp_buf);
+      SERIAL_ECHO((Stall_Threshold + 1) * motor.STALL_CURRENT_CONSTANT_INV);
+      SERIAL_ECHOPGM(" mA)");
+      SERIAL_ECHOPGM("   Motor Status: ");
+      switch (motor_status) {
+        case 0: SERIAL_ECHOPGM("stopped"); break;
+        case 1: SERIAL_ECHOPGM("accelerating"); break;
+        case 2: SERIAL_ECHOPGM("decelerating"); break;
+        case 3: SERIAL_ECHOPGM("at constant speed"); break;
+      }
+      SERIAL_EOL();
+
+      SERIAL_ECHOPGM("...MicroSteps: ", MicroSteps,
+                      "   ADC_OUT: ", L6470_ADC_out);
+      SERIAL_ECHOPGM("   Vs_compensation: ");
+      SERIAL_ECHOF((motor.GetParam(sh.L6470_AXIS_CONFIG) & CONFIG_EN_VSCOMP) ? F("ENABLED ") : F("DISABLED"));
+      SERIAL_ECHOLNPGM("   Compensation coefficient: ~", comp_coef * 0.01f);
+
+      SERIAL_ECHOPGM("...KVAL_HOLD: ", motor.GetParam(L6470_KVAL_HOLD),
+                      "   KVAL_RUN : ", motor.GetParam(L6470_KVAL_RUN),
+                      "   KVAL_ACC: ", motor.GetParam(L6470_KVAL_ACC),
+                      "   KVAL_DEC: ", motor.GetParam(L6470_KVAL_DEC),
+                      "   V motor max = ");
+      switch (motor_status) {
+        case 0: SERIAL_ECHO(motor.GetParam(L6470_KVAL_HOLD) * 100 / 256); SERIAL_ECHOPGM("% (KVAL_HOLD)"); break;
+        case 1: SERIAL_ECHO(motor.GetParam(L6470_KVAL_RUN)  * 100 / 256); SERIAL_ECHOPGM("% (KVAL_RUN)"); break;
+        case 2: SERIAL_ECHO(motor.GetParam(L6470_KVAL_ACC)  * 100 / 256); SERIAL_ECHOPGM("% (KVAL_ACC)"); break;
+        case 3: SERIAL_ECHO(motor.GetParam(L6470_KVAL_DEC)  * 100 / 256); SERIAL_ECHOPGM("% (KVAL_HOLD)"); break;
+      }
+      SERIAL_EOL();
+
+      #if ENABLED(L6470_CHITCHAT)
+        DEBUG_ECHOPGM("...SLEW RATE: ");
+        switch (sh.STATUS_AXIS_LAYOUT) {
+          case L6470_STATUS_LAYOUT: {
+            switch ((motor.GetParam(sh.L6470_AXIS_CONFIG) & CONFIG_POW_SR) >> CONFIG_POW_SR_BIT) {
+              case 0: { DEBUG_ECHOLNPGM("320V/uS") ; break; }
+              case 1: { DEBUG_ECHOLNPGM("75V/uS")  ; break; }
+              case 2: { DEBUG_ECHOLNPGM("110V/uS") ; break; }
+              case 3: { DEBUG_ECHOLNPGM("260V/uS") ; break; }
+            }
+            break;
+          }
+        case L6480_STATUS_LAYOUT: {
+            switch (motor.GetParam(L6470_GATECFG1) & CONFIG1_SR ) {
+              case CONFIG1_SR_220V_us: { DEBUG_ECHOLNPGM("220V/uS") ; break; }
+              case CONFIG1_SR_400V_us: { DEBUG_ECHOLNPGM("400V/uS") ; break; }
+              case CONFIG1_SR_520V_us: { DEBUG_ECHOLNPGM("520V/uS") ; break; }
+              case CONFIG1_SR_980V_us: { DEBUG_ECHOLNPGM("980V/uS") ; break; }
+              default: { DEBUG_ECHOLNPGM("unknown") ; break; }
+            }
+          }
+        }
+      #endif
+      SERIAL_EOL();
+      break;
+    }
+
+    case L6474_STATUS_LAYOUT: {  // L6474
+      const uint16_t L6470_ADC_out = motor.GetParam(L6470_ADC_OUT) & 0x1F,
+                     L6474_TVAL_val = motor.GetParam(L6474_TVAL) & 0x7F;
+
+      say_axis_status(axis, sh.STATUS_AXIS_RAW);
+
+      SERIAL_ECHOPGM("...OverCurrent Threshold: ");
+      sprintf_P(temp_buf, PSTR("%2d ("), OverCurrent_Threshold);
+      SERIAL_ECHO(temp_buf);
+      SERIAL_ECHO((OverCurrent_Threshold + 1) * motor.OCD_CURRENT_CONSTANT_INV);
+      SERIAL_ECHOPGM(" mA)");
+      SERIAL_ECHOPGM("   TVAL: ");
+      sprintf_P(temp_buf, PSTR("%2d ("), L6474_TVAL_val);
+      SERIAL_ECHO(temp_buf);
+      SERIAL_ECHO((L6474_TVAL_val + 1) * motor.STALL_CURRENT_CONSTANT_INV);
+      SERIAL_ECHOLNPGM(" mA)   Motor Status: NA");
+
+      const uint16_t MicroSteps = _BV(motor.GetParam(L6470_STEP_MODE) & 0x07); //NOMORE(MicroSteps, 16);
+      SERIAL_ECHOPGM("...MicroSteps: ", MicroSteps,
+                      "   ADC_OUT: ", L6470_ADC_out);
+
+      SERIAL_ECHOLNPGM("   Vs_compensation: NA\n");
+      SERIAL_ECHOLNPGM("...KVAL_HOLD: NA"
+                       "   KVAL_RUN : NA"
+                       "   KVAL_ACC: NA"
+                       "   KVAL_DEC: NA"
+                       "   V motor max =  NA");
+
+      #if ENABLED(L6470_CHITCHAT)
+        DEBUG_ECHOPGM("...SLEW RATE: ");
+        switch ((motor.GetParam(sh.L6470_AXIS_CONFIG) & CONFIG_POW_SR) >> CONFIG_POW_SR_BIT) {
+          case 0:  DEBUG_ECHOLNPGM("320V/uS") ; break;
+          case 1:  DEBUG_ECHOLNPGM("75V/uS")  ; break;
+          case 2:  DEBUG_ECHOLNPGM("110V/uS") ; break;
+          case 3:  DEBUG_ECHOLNPGM("260V/uS") ; break;
+          default: DEBUG_ECHOLNPGM("slew rate: ", (motor.GetParam(sh.L6470_AXIS_CONFIG) & CONFIG_POW_SR) >> CONFIG_POW_SR_BIT); break;
+        }
+      #endif
+      SERIAL_EOL();
+      SERIAL_EOL();
+      break;
+    }
+  }
+}
+
+/**
+ * M906: report or set KVAL_HOLD which sets the maximum effective voltage provided by the
+ *       PWMs to the steppers
+ *
+ * On L6474 this sets the TVAL register (same address).
+ *
+ * I - select which driver(s) to change on multi-driver axis
+ *         (default) all drivers on the axis
+ *     0 - monitor only the first XYZ... driver
+ *     1 - monitor only X2, Y2, Z2
+ *     2 - monitor only Z3
+ *     3 - monitor only Z4
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to change (optional)
+ *     L6474 - current in mA (4A max)
+ *     All others - 0-255
+ *
+ * Sets KVAL_HOLD which affects the current being driven through the stepper.
+ *
+ * L6470 is used in the STEP-CLOCK mode.  KVAL_HOLD is the only KVAL_xxx
+ * that affects the effective voltage seen by the stepper.
+ */
+void GcodeSuite::M906() {
+
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  #define L6470_SET_KVAL_HOLD(Q) (AXIS_IS_L64XX(Q) ? stepper##Q.setTVALCurrent(value) : stepper##Q.SetParam(L6470_KVAL_HOLD, uint8_t(value)))
+
+  DEBUG_ECHOLNPGM("M906");
+
+  uint8_t report_current = true;
+
+  #if AXIS_IS_L64XX(X2) || AXIS_IS_L64XX(Y2) || AXIS_IS_L64XX(Z2) || AXIS_IS_L64XX(Z3) || AXIS_IS_L64XX(Z4)
+    const int8_t index = parser.byteval('I', -1);
+  #else
+    constexpr int8_t index = -1;
+  #endif
+
+  LOOP_LOGICAL_AXES(i) if (uint16_t value = parser.intval(axis_codes[i])) {
+
+    report_current = false;
+
+    if (planner.has_blocks_queued() || planner.cleaning_buffer_counter) {
+      SERIAL_ECHOLNPGM("Test aborted. Can't set KVAL_HOLD while steppers are moving.");
+      return;
+    }
+
+    switch (i) {
+      #if AXIS_IS_L64XX(X) || AXIS_IS_L64XX(X2)
+        case X_AXIS:
+          #if AXIS_IS_L64XX(X)
+            if (index < 0 || index == 0) L6470_SET_KVAL_HOLD(X);
+          #endif
+          #if AXIS_IS_L64XX(X2)
+            if (index < 0 || index == 1) L6470_SET_KVAL_HOLD(X2);
+          #endif
+          break;
+      #endif
+
+      #if AXIS_IS_L64XX(Y) || AXIS_IS_L64XX(Y2)
+        case Y_AXIS:
+          #if AXIS_IS_L64XX(Y)
+            if (index < 0 || index == 0) L6470_SET_KVAL_HOLD(Y);
+          #endif
+          #if AXIS_IS_L64XX(Y2)
+            if (index < 0 || index == 1) L6470_SET_KVAL_HOLD(Y2);
+          #endif
+          break;
+      #endif
+
+      #if AXIS_IS_L64XX(Z) || AXIS_IS_L64XX(Z2) || AXIS_IS_L64XX(Z3) || AXIS_IS_L64XX(Z4)
+        case Z_AXIS:
+          #if AXIS_IS_L64XX(Z)
+            if (index < 0 || index == 0) L6470_SET_KVAL_HOLD(Z);
+          #endif
+          #if AXIS_IS_L64XX(Z2)
+            if (index < 0 || index == 1) L6470_SET_KVAL_HOLD(Z2);
+          #endif
+          #if AXIS_IS_L64XX(Z3)
+            if (index < 0 || index == 2) L6470_SET_KVAL_HOLD(Z3);
+          #endif
+          #if AXIS_IS_L64XX(Z4)
+            if (index < 0 || index == 3) L6470_SET_KVAL_HOLD(Z4);
+          #endif
+          break;
+      #endif
+
+      #if AXIS_IS_L64XX(E0) || AXIS_IS_L64XX(E1) || AXIS_IS_L64XX(E2) || AXIS_IS_L64XX(E3) || AXIS_IS_L64XX(E4) || AXIS_IS_L64XX(E5) || AXIS_IS_L64XX(E6) || AXIS_IS_L64XX(E7)
+        case E_AXIS: {
+          const int8_t eindex = get_target_e_stepper_from_command(-2);
+          #if AXIS_IS_L64XX(E0)
+            if (eindex < 0 || eindex == 0) L6470_SET_KVAL_HOLD(E0);
+          #endif
+          #if AXIS_IS_L64XX(E1)
+            if (eindex < 0 || eindex == 1) L6470_SET_KVAL_HOLD(E1);
+          #endif
+          #if AXIS_IS_L64XX(E2)
+            if (eindex < 0 || eindex == 2) L6470_SET_KVAL_HOLD(E2);
+          #endif
+          #if AXIS_IS_L64XX(E3)
+            if (eindex < 0 || eindex == 3) L6470_SET_KVAL_HOLD(E3);
+          #endif
+          #if AXIS_IS_L64XX(E4)
+            if (eindex < 0 || eindex == 4) L6470_SET_KVAL_HOLD(E4);
+          #endif
+          #if AXIS_IS_L64XX(E5)
+            if (eindex < 0 || eindex == 5) L6470_SET_KVAL_HOLD(E5);
+          #endif
+          #if AXIS_IS_L64XX(E6)
+            if (eindex < 0 || eindex == 6) L6470_SET_KVAL_HOLD(E6);
+          #endif
+          #if AXIS_IS_L64XX(E7)
+            if (eindex < 0 || eindex == 7) L6470_SET_KVAL_HOLD(E7);
+          #endif
+        } break;
+      #endif
+    }
+  }
+
+  if (report_current) {
+    #define L64XX_REPORT_CURRENT(Q) L64XX_report_current(stepper##Q, Q)
+
+    L64xxManager.spi_active = true; // Tell set_directions() a series of SPI transfers is underway
+
+    #if AXIS_IS_L64XX(X)
+      L64XX_REPORT_CURRENT(X);
+    #endif
+    #if AXIS_IS_L64XX(X2)
+      L64XX_REPORT_CURRENT(X2);
+    #endif
+    #if AXIS_IS_L64XX(Y)
+      L64XX_REPORT_CURRENT(Y);
+    #endif
+    #if AXIS_IS_L64XX(Y2)
+      L64XX_REPORT_CURRENT(Y2);
+    #endif
+    #if AXIS_IS_L64XX(Z)
+      L64XX_REPORT_CURRENT(Z);
+    #endif
+    #if AXIS_IS_L64XX(Z2)
+      L64XX_REPORT_CURRENT(Z2);
+    #endif
+    #if AXIS_IS_L64XX(Z3)
+      L64XX_REPORT_CURRENT(Z3);
+    #endif
+    #if AXIS_IS_L64XX(Z4)
+      L64XX_REPORT_CURRENT(Z4);
+    #endif
+    #if AXIS_IS_L64XX(E0)
+      L64XX_REPORT_CURRENT(E0);
+    #endif
+    #if AXIS_IS_L64XX(E1)
+      L64XX_REPORT_CURRENT(E1);
+    #endif
+    #if AXIS_IS_L64XX(E2)
+      L64XX_REPORT_CURRENT(E2);
+    #endif
+    #if AXIS_IS_L64XX(E3)
+      L64XX_REPORT_CURRENT(E3);
+    #endif
+    #if AXIS_IS_L64XX(E4)
+      L64XX_REPORT_CURRENT(E4);
+    #endif
+    #if AXIS_IS_L64XX(E5)
+      L64XX_REPORT_CURRENT(E5);
+    #endif
+    #if AXIS_IS_L64XX(E6)
+      L64XX_REPORT_CURRENT(E6);
+    #endif
+    #if AXIS_IS_L64XX(E7)
+      L64XX_REPORT_CURRENT(E7);
+    #endif
+
+    L64xxManager.spi_active = false;   // done with all SPI transfers - clear handshake flags
+    L64xxManager.spi_abort = false;
+    L64xxManager.pause_monitor(false);
+  }
+}
+
+#endif // HAS_L64XX
diff --git a/Marlin/src/gcode/feature/L6470/M916-M918.cpp b/Marlin/src/gcode/feature/L6470/M916-M918.cpp
new file mode 100644
index 0000000000..8d614603ed
--- /dev/null
+++ b/Marlin/src/gcode/feature/L6470/M916-M918.cpp
@@ -0,0 +1,651 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+//
+// NOTE: All tests assume each axis uses matching driver chips.
+//
+
+#include "../../../inc/MarlinConfig.h"
+
+#if HAS_L64XX
+
+#include "../../gcode.h"
+#include "../../../module/stepper/indirection.h"
+#include "../../../module/planner.h"
+#include "../../../libs/L64XX/L64XX_Marlin.h"
+
+#define DEBUG_OUT ENABLED(L6470_CHITCHAT)
+#include "../../../core/debug_out.h"
+
+/**
+ * M916: increase KVAL_HOLD until get thermal warning
+ *       NOTE - on L6474 it is TVAL that is used
+ *
+ * J - select which driver(s) to monitor on multi-driver axis
+ *     0 - (default) monitor all drivers on the axis or E0
+ *     1 - monitor only X, Y, Z, E1
+ *     2 - monitor only X2, Y2, Z2, E2
+ *     3 - monitor only Z3, E3
+ *     4 - monitor only Z4, E4
+ *
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
+ *     xxx (1-255) is distance moved on either side of current position
+ *
+ * F - feedrate
+ *     optional - will use default max feedrate from configuration.h if not specified
+ *
+ * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
+ *     optional - will report current value from driver if not specified
+ *
+ * D - time (in seconds) to run each setting of KVAL_HOLD/TVAL
+ *     optional - defaults to zero (runs each setting once)
+ */
+
+/**
+ * This routine is also useful for determining the approximate KVAL_HOLD
+ * where the stepper stops losing steps. The sound will get noticeably quieter
+ * as it stops losing steps.
+ */
+
+void GcodeSuite::M916() {
+
+  DEBUG_ECHOLNPGM("M916");
+
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  // Variables used by L64xxManager.get_user_input function - some may not be used
+  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
+  L64XX_axis_t axis_index[3];
+  uint16_t axis_status[3];
+  uint8_t driver_count = 1;
+  float position_max;
+  float position_min;
+  float final_feedrate;
+  uint8_t kval_hold;
+  uint8_t OCD_TH_val = 0;
+  uint8_t STALL_TH_val = 0;
+  uint16_t over_current_threshold;
+  constexpr uint8_t over_current_flag = false;  // M916 doesn't play with the overcurrent thresholds
+
+  #define DRIVER_TYPE_L6474(Q) AXIS_DRIVER_TYPE_##Q(L6474)
+
+  uint8_t j;   // general purpose counter
+
+  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
+    return;  // quit if invalid user input
+
+  DEBUG_ECHOLNPGM("feedrate = ", final_feedrate);
+
+  planner.synchronize();                             // wait for all current movement commands to complete
+
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
+  for (j = 0; j < driver_count; j++)
+    L64xxManager.get_status(axis_index[j]);  // clear out any pre-existing error flags
+
+  char temp_axis_string[] = " ";
+  temp_axis_string[0] = axis_mon[0][0];  // need to have a string for use within sprintf format section
+  char gcode_string[80];
+  uint16_t status_composite = 0;
+
+  uint16_t M91x_counter = kval_hold;
+  uint16_t M91x_counter_max;
+  if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {
+    M91x_counter_max = 128;  // TVAL is 7 bits
+    LIMIT(M91x_counter, 0U, 127U);
+  }
+  else
+    M91x_counter_max = 256;  // KVAL_HOLD is 8 bits
+
+  uint8_t M91x_delay_s = parser.byteval('D');   // get delay in seconds
+  millis_t M91x_delay_ms = SEC_TO_MS(M91x_delay_s * 60);
+  millis_t M91x_delay_end;
+
+  DEBUG_ECHOLNPGM(".\n.");
+
+  do {
+
+    if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
+      DEBUG_ECHOLNPGM("TVAL current (mA) = ", (M91x_counter + 1) * sh.AXIS_STALL_CURRENT_CONSTANT_INV);        // report TVAL current for this run
+    else
+      DEBUG_ECHOLNPGM("kval_hold = ", M91x_counter);                                   // report KVAL_HOLD for this run
+
+    for (j = 0; j < driver_count; j++)
+      L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, M91x_counter);  //set KVAL_HOLD or TVAL (same register address)
+
+    M91x_delay_end = millis() + M91x_delay_ms;
+    do {
+      // turn the motor(s) both directions
+      sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
+      process_subcommands_now(gcode_string);
+
+      sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
+      process_subcommands_now(gcode_string);
+
+      // get the status after the motors have stopped
+      planner.synchronize();
+
+      status_composite = 0;    // clear out the old bits
+
+      for (j = 0; j < driver_count; j++) {
+        axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
+        status_composite |= axis_status[j] ;
+      }
+
+      if (status_composite) break;
+    } while (millis() < M91x_delay_end);
+
+    if (status_composite) break;
+
+    M91x_counter++;
+
+  } while (!(status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)) && (M91x_counter < M91x_counter_max));
+
+  DEBUG_ECHOLNPGM(".");
+
+  #if ENABLED(L6470_CHITCHAT)
+    if (status_composite) {
+      L64xxManager.error_status_decode(status_composite, axis_index[0],
+        sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+        sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+        sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+      DEBUG_ECHOLNPGM(".");
+    }
+  #endif
+
+  if ((status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)))
+    DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Thermal warning/shutdown has occurred");
+  else if (status_composite)
+    DEBUG_ECHOLNPGM(".\n.\nTest completed abnormally - non-thermal error has occurred");
+  else
+    DEBUG_ECHOLNPGM(".\n.\nTest completed normally - Unable to get to thermal warning/shutdown");
+
+  L64xxManager.pause_monitor(false);
+}
+
+/**
+ * M917: Find minimum current thresholds
+ *
+ *   Decrease OCD current until overcurrent error
+ *   Increase OCD until overcurrent error goes away
+ *   Decrease stall threshold until stall (not done on L6474)
+ *   Increase stall until stall error goes away (not done on L6474)
+ *
+ * J - select which driver(s) to monitor on multi-driver axis
+ *     0 - (default) monitor all drivers on the axis or E0
+ *     1 - monitor only X, Y, Z, E1
+ *     2 - monitor only X2, Y2, Z2, E2
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
+ *     xxx (1-255) is distance moved on either side of current position
+ *
+ * F - feedrate
+ *     optional - will use default max feedrate from Configuration.h if not specified
+ *
+ * I - starting over-current threshold
+ *     optional - will report current value from driver if not specified
+ *     if there are multiple drivers on the axis then all will be set the same
+ *
+ * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
+ *     optional - will report current value from driver if not specified
+ */
+void GcodeSuite::M917() {
+
+  DEBUG_ECHOLNPGM("M917");
+
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
+  L64XX_axis_t axis_index[3];
+  uint16_t axis_status[3];
+  uint8_t driver_count = 1;
+  float position_max;
+  float position_min;
+  float final_feedrate;
+  uint8_t kval_hold;
+  uint8_t OCD_TH_val = 0;
+  uint8_t STALL_TH_val = 0;
+  uint16_t over_current_threshold;
+  constexpr uint8_t over_current_flag = true;
+
+  uint8_t j;   // general purpose counter
+
+  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
+    return;  // quit if invalid user input
+
+  DEBUG_ECHOLNPGM("feedrate = ", final_feedrate);
+
+  planner.synchronize();                             // wait for all current movement commands to complete
+
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
+  for (j = 0; j < driver_count; j++)
+    L64xxManager.get_status(axis_index[j]);  // clear error flags
+  char temp_axis_string[] = " ";
+  temp_axis_string[0] = axis_mon[0][0];   // need a sprintf format string
+  char gcode_string[80];
+  uint16_t status_composite = 0;
+  uint8_t test_phase = 0;                 // 0 - decreasing OCD - exit when OCD warning occurs (ignore STALL)
+                                          // 1 - increasing OCD - exit when OCD warning stops (ignore STALL)
+                                          // 2 - OCD finalized - decreasing STALL - exit when STALL warning happens
+                                          // 3 - OCD finalized - increasing STALL - exit when STALL warning stop
+                                          // 4 - all testing completed
+  DEBUG_ECHOPGM(".\n.\n.\nover_current threshold : ", (OCD_TH_val + 1) * 375);   // first status display
+  DEBUG_ECHOPGM("  (OCD_TH:  : ", OCD_TH_val);
+  if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) {
+    DEBUG_ECHOPGM(")   Stall threshold: ", (STALL_TH_val + 1) * 31.25);
+    DEBUG_ECHOPGM("  (STALL_TH: ", STALL_TH_val);
+  }
+  DEBUG_ECHOLNPGM(")");
+
+  do {
+
+    if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) DEBUG_ECHOPGM("STALL threshold : ", (STALL_TH_val + 1) * 31.25);
+    DEBUG_ECHOLNPGM("   OCD threshold : ", (OCD_TH_val + 1) * 375);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(final_feedrate));
+    process_subcommands_now(gcode_string);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(final_feedrate));
+    process_subcommands_now(gcode_string);
+
+    planner.synchronize();
+
+    status_composite = 0;    // clear out the old bits
+
+    for (j = 0; j < driver_count; j++) {
+      axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
+      status_composite |= axis_status[j];
+    }
+
+    if (status_composite && (status_composite & sh.STATUS_AXIS_UVLO)) {
+      DEBUG_ECHOLNPGM("Test aborted (Undervoltage lockout active)");
+      #if ENABLED(L6470_CHITCHAT)
+        for (j = 0; j < driver_count; j++) {
+          if (j) DEBUG_ECHOPGM("...");
+          L64xxManager.error_status_decode(axis_status[j], axis_index[j],
+            sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+            sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+            sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+        }
+      #endif
+      return;
+    }
+
+    if (status_composite & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD)) {
+      DEBUG_ECHOLNPGM("thermal problem - waiting for chip(s) to cool down ");
+      uint16_t status_composite_temp = 0;
+      uint8_t k = 0;
+      do {
+        k++;
+        if (!(k % 4)) {
+          kval_hold *= 0.95;
+          DEBUG_EOL();
+          DEBUG_ECHOLNPGM("Lowering KVAL_HOLD by about 5% to ", kval_hold);
+          for (j = 0; j < driver_count; j++)
+            L64xxManager.set_param(axis_index[j], L6470_KVAL_HOLD, kval_hold);
+        }
+        DEBUG_ECHOLNPGM(".");
+        reset_stepper_timeout(); // keep steppers powered
+        watchdog_refresh();
+        safe_delay(5000);
+        status_composite_temp = 0;
+        for (j = 0; j < driver_count; j++) {
+          axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & sh.L6470_ERROR_MASK;    // bits of interest are all active low
+          status_composite_temp |= axis_status[j];
+        }
+      }
+      while (status_composite_temp & (sh.STATUS_AXIS_TH_WRN | sh.STATUS_AXIS_TH_SD));
+      DEBUG_EOL();
+    }
+    if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B | sh.STATUS_AXIS_OCD)) {
+      switch (test_phase) {
+
+        case 0: {
+          if (status_composite & sh.STATUS_AXIS_OCD) {
+            // phase 0 with OCD warning - time to go to next phase
+            if (OCD_TH_val >= sh.AXIS_OCD_TH_MAX) {
+              OCD_TH_val = sh.AXIS_OCD_TH_MAX;           // limit to max
+              test_phase = 2;            // at highest value so skip phase 1
+              //DEBUG_ECHOLNPGM("LOGIC E0A OCD at highest - skip to 2");
+              DEBUG_ECHOLNPGM("OCD at highest - OCD finalized");
+            }
+            else {
+              OCD_TH_val++;              // normal exit to next phase
+              test_phase = 1;            // setup for first pass of phase 1
+              //DEBUG_ECHOLNPGM("LOGIC E0B - inc OCD  & go to 1");
+              DEBUG_ECHOLNPGM("inc OCD");
+            }
+          }
+          else {  // phase 0 without OCD warning - keep on decrementing if can
+            if (OCD_TH_val) {
+              OCD_TH_val--;              // try lower value
+              //DEBUG_ECHOLNPGM("LOGIC E0C - dec OCD");
+              DEBUG_ECHOLNPGM("dec OCD");
+            }
+            else {
+              test_phase = 2;            // at lowest value without warning so skip phase 1
+              //DEBUG_ECHOLNPGM("LOGIC E0D - OCD at latest - go to 2");
+              DEBUG_ECHOLNPGM("OCD finalized");
+            }
+          }
+        } break;
+
+        case 1: {
+          if (status_composite & sh.STATUS_AXIS_OCD) {
+            // phase 1 with OCD warning - increment if can
+            if (OCD_TH_val >= sh.AXIS_OCD_TH_MAX) {
+              OCD_TH_val = sh.AXIS_OCD_TH_MAX;           // limit to max
+              test_phase = 2;            // at highest value so go to next phase
+              //DEBUG_ECHOLNPGM("LOGIC E1A - OCD at max - go to 2");
+              DEBUG_ECHOLNPGM("OCD finalized");
+            }
+            else {
+              OCD_TH_val++;              // try a higher value
+              //DEBUG_ECHOLNPGM("LOGIC E1B - inc OCD");
+              DEBUG_ECHOLNPGM("inc OCD");
+            }
+          }
+          else { // phase 1 without OCD warning - normal exit to phase 2
+            test_phase = 2;
+            //DEBUG_ECHOLNPGM("LOGIC E1C - no OCD warning - go to 1");
+            DEBUG_ECHOLNPGM("OCD finalized");
+          }
+        } break;
+
+        case 2: {
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B)) {
+            // phase 2 with stall warning - time to go to next phase
+            if (STALL_TH_val >= 127) {
+              STALL_TH_val = 127;  // limit to max
+              //DEBUG_ECHOLNPGM("LOGIC E2A - STALL warning, STALL at max, quit");
+              DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
+              test_phase = 4;
+            }
+            else {
+              test_phase = 3;              // normal exit to next phase (found failing value of STALL)
+              STALL_TH_val++;              // setup for first pass of phase 3
+              //DEBUG_ECHOLNPGM("LOGIC E2B - INC - STALL warning, inc Stall, go to 3");
+              DEBUG_ECHOLNPGM("inc Stall");
+            }
+          }
+          else {  // phase 2 without stall warning - decrement if can
+            if (STALL_TH_val) {
+              STALL_TH_val--;              // try a lower value
+              //DEBUG_ECHOLNPGM("LOGIC E2C - no STALL, dec STALL");
+              DEBUG_ECHOLNPGM("dec STALL");
+            }
+            else {
+              DEBUG_ECHOLNPGM("finished - STALL at lowest value but still do NOT have stall warning");
+              test_phase = 4;
+              //DEBUG_ECHOLNPGM("LOGIC E2D - no STALL, at lowest so quit");
+            }
+          }
+        } break;
+
+        case 3: {
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          if (status_composite & (sh.STATUS_AXIS_STEP_LOSS_A | sh.STATUS_AXIS_STEP_LOSS_B)) {
+            // phase 3 with stall warning - increment if can
+            if (STALL_TH_val >= 127) {
+              STALL_TH_val = 127; // limit to max
+              DEBUG_ECHOLNPGM("finished - STALL at maximum value but still have stall warning");
+              test_phase = 4;
+              //DEBUG_ECHOLNPGM("LOGIC E3A - STALL, at max so quit");
+            }
+            else {
+              STALL_TH_val++;              // still looking for passing value
+              //DEBUG_ECHOLNPGM("LOGIC E3B - STALL, inc stall");
+              DEBUG_ECHOLNPGM("inc stall");
+            }
+          }
+          else {  //phase 3 without stall warning  but have OCD warning
+            DEBUG_ECHOLNPGM("Hardware problem - OCD warning without STALL warning");
+            test_phase = 4;
+            //DEBUG_ECHOLNPGM("LOGIC E3C - not STALLED, hardware problem (quit)");
+          }
+        } break;
+
+      }
+
+    }
+    else {
+      switch (test_phase) {
+        case 0: { // phase 0 without OCD warning - keep on decrementing if can
+          if (OCD_TH_val) {
+            OCD_TH_val--;             // try lower value
+            //DEBUG_ECHOLNPGM("LOGIC N0A - DEC OCD");
+            DEBUG_ECHOLNPGM("DEC OCD");
+          }
+          else {
+            test_phase = 2;           // at lowest value without warning so skip phase 1
+            //DEBUG_ECHOLNPGM("LOGIC N0B - OCD at lowest (go to phase 2)");
+            DEBUG_ECHOLNPGM("OCD finalized");
+          }
+        } break;
+
+        case 1: //DEBUG_ECHOLNPGM("LOGIC N1 (go directly to 2)"); // phase 1 without OCD warning - drop directly to phase 2
+                DEBUG_ECHOLNPGM("OCD finalized");
+
+        case 2: { // phase 2 without stall warning - keep on decrementing if can
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          if (STALL_TH_val) {
+            STALL_TH_val--;              // try a lower value (stay in phase 2)
+            //DEBUG_ECHOLNPGM("LOGIC N2B - dec STALL");
+            DEBUG_ECHOLNPGM("dec STALL");
+          }
+          else {
+            DEBUG_ECHOLNPGM("finished - STALL at lowest value but still no stall warning");
+            test_phase = 4;
+            //DEBUG_ECHOLNPGM("LOGIC N2C - STALL at lowest (quit)");
+          }
+        } break;
+
+        case 3: {
+          if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT) {  // skip all STALL_TH steps if L6474
+            test_phase = 4;
+            break;
+          }
+          test_phase = 4;
+           //DEBUG_ECHOLNPGM("LOGIC N3 - finished!");
+           DEBUG_ECHOLNPGM("finished!");
+        } break;  // phase 3 without any warnings - desired exit
+      }  //
+    }  // end of status checks
+
+    if (test_phase != 4) {
+      for (j = 0; j < driver_count; j++) {                       // update threshold(s)
+        L64xxManager.set_param(axis_index[j], L6470_OCD_TH, OCD_TH_val);
+        if (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT) L64xxManager.set_param(axis_index[j], L6470_STALL_TH, STALL_TH_val);
+        if (L64xxManager.get_param(axis_index[j], L6470_OCD_TH) != OCD_TH_val) DEBUG_ECHOLNPGM("OCD mismatch");
+        if ((L64xxManager.get_param(axis_index[j], L6470_STALL_TH) != STALL_TH_val) && (sh.STATUS_AXIS_LAYOUT != L6474_STATUS_LAYOUT)) DEBUG_ECHOLNPGM("STALL mismatch");
+      }
+    }
+
+  } while (test_phase != 4);
+
+  DEBUG_ECHOLNPGM(".");
+  if (status_composite) {
+    #if ENABLED(L6470_CHITCHAT)
+      for (j = 0; j < driver_count; j++) {
+        if (j) DEBUG_ECHOPGM("...");
+        L64xxManager.error_status_decode(axis_status[j], axis_index[j],
+          sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+          sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+          sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+      }
+      DEBUG_ECHOLNPGM(".");
+    #endif
+    DEBUG_ECHOLNPGM("Completed with errors");
+  }
+  else
+    DEBUG_ECHOLNPGM("Completed with no errors");
+  DEBUG_ECHOLNPGM(".");
+
+  L64xxManager.pause_monitor(false);
+}
+
+/**
+ * M918: increase speed until error or max feedrate achieved (as shown in configuration.h))
+ *
+ * J - select which driver(s) to monitor on multi-driver axis
+ *     0 - (default) monitor all drivers on the axis or E0
+ *     1 - monitor only X, Y, Z, E1
+ *     2 - monitor only X2, Y2, Z2, E2
+ * Xxxx, Yxxx, Zxxx, Exxx - axis to be monitored with displacement
+ *     xxx (1-255) is distance moved on either side of current position
+ *
+ * I - over current threshold
+ *     optional - will report current value from driver if not specified
+ *
+ * T - current (mA) setting for TVAL (0 - 4A in 31.25mA increments, rounds down) - L6474 only
+ *     optional - will report current value from driver if not specified
+ *
+ * K - value for KVAL_HOLD (0 - 255) (ignored for L6474)
+ *     optional - will report current value from driver if not specified
+ *
+ * M - value for microsteps (1 - 128) (optional)
+ *     optional - will report current value from driver if not specified
+ */
+void GcodeSuite::M918() {
+
+  DEBUG_ECHOLNPGM("M918");
+
+  L64xxManager.pause_monitor(true); // Keep monitor_driver() from stealing status
+
+  char axis_mon[3][3] = { {"  "}, {"  "}, {"  "} };   // list of Axes to be monitored
+  L64XX_axis_t axis_index[3];
+  uint16_t axis_status[3];
+  uint8_t driver_count = 1;
+  float position_max, position_min;
+  float final_feedrate;
+  uint8_t kval_hold;
+  uint8_t OCD_TH_val = 0;
+  uint8_t STALL_TH_val = 0;
+  uint16_t over_current_threshold;
+  constexpr uint8_t over_current_flag = true;
+
+  const L64XX_Marlin::L64XX_shadow_t &sh = L64xxManager.shadow;
+
+  uint8_t j;   // general purpose counter
+
+  if (L64xxManager.get_user_input(driver_count, axis_index, axis_mon, position_max, position_min, final_feedrate, kval_hold, over_current_flag, OCD_TH_val, STALL_TH_val, over_current_threshold))
+    return;  // quit if invalid user input
+
+  L64xxManager.get_status(axis_index[0]); // populate shadow array
+
+  uint8_t m_steps = parser.byteval('M');
+
+  if (m_steps != 0) {
+    LIMIT(m_steps, 1, sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT ? 16 : 128);  // L6474
+
+    uint8_t stepVal;
+    for (stepVal = 0; stepVal < 8; stepVal++) {  // convert to L64xx register value
+      if (m_steps == 1) break;
+      m_steps >>= 1;
+    }
+
+    if (sh.STATUS_AXIS_LAYOUT == L6474_STATUS_LAYOUT)
+      stepVal |= 0x98;  // NO SYNC
+    else
+      stepVal |= (!SYNC_EN) | SYNC_SEL_1 | stepVal;
+
+    for (j = 0; j < driver_count; j++) {
+      L64xxManager.set_param(axis_index[j], dSPIN_HARD_HIZ, 0);          // can't write STEP register if stepper being powered
+                                                                         //   results in an extra NOOP being sent (data 00)
+      L64xxManager.set_param(axis_index[j], L6470_STEP_MODE, stepVal);   // set microsteps
+    }
+  }
+  m_steps = L64xxManager.get_param(axis_index[0], L6470_STEP_MODE) & 0x07;   // get microsteps
+
+  DEBUG_ECHOLNPGM("Microsteps = ", _BV(m_steps));
+  DEBUG_ECHOLNPGM("target (maximum) feedrate = ", final_feedrate);
+
+  const float feedrate_inc = final_feedrate / 10,   // Start at 1/10 of max & go up by 1/10 per step
+              fr_limit = final_feedrate * 0.99f;    // Rounding-safe comparison value
+  float current_feedrate = 0;
+
+  planner.synchronize();                            // Wait for moves to complete
+
+  for (j = 0; j < driver_count; j++)
+    L64xxManager.get_status(axis_index[j]);         // Clear error flags
+
+  char temp_axis_string[2] = " ";
+  temp_axis_string[0] = axis_mon[0][0];             // Need a sprintf format string
+  //temp_axis_string[1] = '\n';
+
+  char gcode_string[80];
+  uint16_t status_composite = 0;
+  DEBUG_ECHOLNPGM(".\n.\n.");                       // Make feedrate outputs easier to read
+
+  do {
+    current_feedrate += feedrate_inc;
+    DEBUG_ECHOLNPGM("...feedrate = ", current_feedrate);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_min), uint16_t(current_feedrate));
+    process_subcommands_now(gcode_string);
+
+    sprintf_P(gcode_string, PSTR("G0 %s%03d F%03d"), temp_axis_string, uint16_t(position_max), uint16_t(current_feedrate));
+    process_subcommands_now(gcode_string);
+
+    planner.synchronize();
+
+    for (j = 0; j < driver_count; j++) {
+      axis_status[j] = (~L64xxManager.get_status(axis_index[j])) & 0x0800;  // Bits of interest are all active LOW
+      status_composite |= axis_status[j];
+    }
+    if (status_composite) break;              // Break on any error
+  } while (current_feedrate < fr_limit);
+
+  DEBUG_ECHOPGM("Completed with ");
+  if (status_composite) {
+    DEBUG_ECHOLNPGM("errors");
+    #if ENABLED(L6470_CHITCHAT)
+      for (j = 0; j < driver_count; j++) {
+        if (j) DEBUG_ECHOPGM("...");
+        L64xxManager.error_status_decode(axis_status[j], axis_index[j],
+          sh.STATUS_AXIS_TH_SD, sh.STATUS_AXIS_TH_WRN,
+          sh.STATUS_AXIS_STEP_LOSS_A, sh.STATUS_AXIS_STEP_LOSS_B,
+          sh.STATUS_AXIS_OCD, sh.STATUS_AXIS_LAYOUT);
+      }
+    #endif
+  }
+  else
+    DEBUG_ECHOLNPGM("no errors");
+
+  L64xxManager.pause_monitor(false);
+}
+
+#endif // HAS_L64XX
diff --git a/Marlin/src/gcode/feature/i2c/M260_M261.cpp b/Marlin/src/gcode/feature/i2c/M260_M261.cpp
index cf9bb7e583..88db570df0 100644
--- a/Marlin/src/gcode/feature/i2c/M260_M261.cpp
+++ b/Marlin/src/gcode/feature/i2c/M260_M261.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
diff --git a/Marlin/src/gcode/gcode.cpp b/Marlin/src/gcode/gcode.cpp
index f08ade8c38..c87478f660 100644
--- a/Marlin/src/gcode/gcode.cpp
+++ b/Marlin/src/gcode/gcode.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -320,14 +320,14 @@ void GcodeSuite::dwell(millis_t time) {
 
 #endif // G29_RETRY_AND_RECOVER
 
-/**
+/** //TG - The main gcode dispatcher
  * Process the parsed command and dispatch it to its handler
  */
 void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
   TERN_(HAS_FANCHECK, fan_check.check_deferred_error());
 
-  KEEPALIVE_STATE(IN_HANDLER);
-
+  KEEPALIVE_STATE(IN_HANDLER);  //TG - sets gcode.busy_state to IN_HANDLER which emits "busy: processing" to serial ports, uses macro REMEMBER() to call class restorer()
+                                //to save old/set new value, class restorer() gets destroyed on exiting process_parsed_command() and resets previous gcode.busy_state.
  /**
   * Block all Gcodes except M511 Unlock Printer, if printer is locked
   * Will still block Gcodes if M511 is disabled, in which case the printer should be unlocked via LCD Menu
@@ -435,6 +435,10 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
           break;
       #endif
 
+      #if BOTH(CNC_COORDINATE_SYSTEMS, ENABLE_G39)                //TG 10/3/22 added new G code to report WCS
+        case 39: G39(); break;                                    // G39: Report WCS System values
+      #endif
+
       #if HAS_MESH
         case 42: G42(); break;                                    // G42: Coordinated move to a mesh point
       #endif
@@ -562,7 +566,7 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
       #endif
 
       #if ENABLED(SET_PROGRESS_MANUALLY)
-        case 73: M73(); break;                                    // M73: Set progress percentage
+        case 73: M73(); break;                                    // M73: Set progress percentage (for display on LCD)
       #endif
 
       case 75: M75(); break;                                      // M75: Start print timer
@@ -749,6 +753,7 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
 
       case 220: M220(); break;                                    // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
 
+      //TG 9/1/22 disable M221 if no extruders
       #if HAS_EXTRUDERS
         case 221: M221(); break;                                  // M221: Set Flow Percentage
       #endif
@@ -779,7 +784,7 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
         case 301: M301(); break;                                  // M301: Set hotend PID parameters
       #endif
 
-      #if ENABLED(PIDTEMPBED)
+      #if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
         case 304: M304(); break;                                  // M304: Set bed PID parameters
       #endif
 
@@ -869,6 +874,8 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
 
       #if HAS_LEVELING
         case 420: M420(); break;                                  // M420: Enable/Disable Bed Leveling
+      #else               //TG 2/28/23 added #else
+        case 420: break;  //break to avoid "unknown command" warning
       #endif
 
       #if HAS_MESH
@@ -1097,6 +1104,22 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
         case 3426: M3426(); break;                                // M3426: Read MCP3426 ADC (over i2c)
       #endif
 
+      #if ENABLED(AVR_TRIAC_CONTROLLER)     //TG 12/16/22                               
+        case 7900: M7900(); break;          //TG - 9/27/21 added custom gcode send flag to update AVR EEPROM
+        case 7979: M7979(); break;          //TG - 9/27/21 added custom gcode spindle_use_pid
+        case 7980: M7980(); break;          //TG - 9/27/21 added custom gcode AVR Reset requested
+        case 7981: M7981(); break;          //TG - 9/27/21 added custom gcode receive Kp, Ki, Kd
+        case 7982: M7982(); break;          //TG - 9/27/21 added custom gcode receive current AVR LCD display index
+        case 7983: M7983(); break;          //TG - 9/27/21 added custom gcode receive current AVR pid speed
+        case 7984: M7984(); break;          //TG - 9/27/21 added custom gcode receive reload AVR pid speed 
+      #endif 
+        case 7986: M7986(); break;          //TG - 9/27/21 added custom gcode receive Stock Top Z-axis from TFT and SD File 
+      
+      #if ENABLED(VFD_CONTROLLER)	          
+        case 7988: M7988(); break;          //TG 12/23/22 added returns VFD sw_ver, cpu_ver, baudrate, format to TFT                                   
+        case 7989: M7989(); break;          //TG  2/13/23 added receive TFT print state from TFT (0=printing,1=printing)
+      #endif
+      
       default: parser.unknown_command_warning(); break;
     }
     break;
@@ -1121,6 +1144,9 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
   if (!no_ok) queue.ok_to_send();
 
   SERIAL_OUT(msgDone); // Call the msgDone serial hook to signal command processing done
+
+//TG - note that the KEEPALIVE_STATE(IN_HANDLER) statement at start of this function used macro REMEMBER() to call class restorer()
+//     class restorer() will be destroyed on exit here and will reset gcode.busy_state to it's previous value (usually NOT_BUSY).
 }
 
 #if ENABLED(M100_FREE_MEMORY_DUMPER)
@@ -1134,7 +1160,7 @@ void GcodeSuite::process_parsed_command(const bool no_ok/*=false*/) {
 void GcodeSuite::process_next_command() {
   GCodeQueue::CommandLine &command = queue.ring_buffer.peek_next_command();
 
-  PORT_REDIRECT(SERIAL_PORTMASK(command.port));
+  PORT_REDIRECT(SERIAL_PORTMASK(command.port));   //TG - work only with serial port that the command came from
 
   TERN_(POWER_LOSS_RECOVERY, recovery.queue_index_r = queue.ring_buffer.index_r);
 
diff --git a/Marlin/src/gcode/gcode.h b/Marlin/src/gcode/gcode.h
index 9bb45d9a43..c538d86929 100644
--- a/Marlin/src/gcode/gcode.h
+++ b/Marlin/src/gcode/gcode.h
@@ -323,13 +323,17 @@
  * D... - Custom Development G-code. Add hooks to 'gcode_D.cpp' for developers to test features. (Requires MARLIN_DEV_MODE)
  *        D576 - Set buffer monitoring options. (Requires BUFFER_MONITORING)
  *
- *** "T" Codes ***
+ * //TG 9/27/21 T.Gioiosa added custom Gcode for Spindle PID control
+ * M7979 - Turn PID speed control on/off for Spindle
+ * 
+ * "T" Codes
  *
  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
  */
 
 #include "../inc/MarlinConfig.h"
 #include "parser.h"
+#include "../module/vfd.h"
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "../feature/encoder_i2c.h"
@@ -392,7 +396,7 @@ public:
 
   #define MAX_COORDINATE_SYSTEMS 9
   #if ENABLED(CNC_COORDINATE_SYSTEMS)
-    static int8_t active_coordinate_system;
+    static int8_t active_coordinate_system;   //TG 10/4/22 added this to make variable visible to other .cpp files
     static xyz_pos_t coordinate_system[MAX_COORDINATE_SYSTEMS];
     static bool select_coordinate_system(const int8_t _new);
   #endif
@@ -583,6 +587,9 @@ private:
     static void G57();
     static void G58();
     static void G59();
+    #ifdef ENABLE_G39
+      static void G39();  //TG 9/29/22 - added new code to report WCS table and current WCS
+    #endif
   #endif
 
   #if BOTH(PTC_PROBE, PTC_BED)
@@ -942,7 +949,7 @@ private:
     static void M303();
   #endif
 
-  #if ENABLED(PIDTEMPBED)
+  #if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
     static void M304();
     static void M304_report(const bool forReplay=true);
   #endif
@@ -1252,6 +1259,34 @@ private:
 
   static void T(const int8_t tool_index);
 
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7979();
+  #endif
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7980();
+  #endif
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7981();
+  #endif
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7982();
+  #endif
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7983();
+  #endif
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7984();
+  #endif
+    #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7986();
+  #endif
+  #if ENABLED(SPINDLE_FEATURE)    //TG - 9/27/21 added custom gcode
+    static void M7900();
+  #endif
+  #if ENABLED(VFD_CONTROLLER)	    //TG 12/23/22
+    static void M7988();
+    static void M7989();
+  #endif
 };
 
 extern GcodeSuite gcode;
diff --git a/Marlin/src/gcode/geometry/G53-G59.cpp b/Marlin/src/gcode/geometry/G53-G59.cpp
index c51c29f423..5d3777c8b0 100644
--- a/Marlin/src/gcode/geometry/G53-G59.cpp
+++ b/Marlin/src/gcode/geometry/G53-G59.cpp
@@ -32,15 +32,15 @@
  * System index -1 is used to specify machine-native.
  */
 bool GcodeSuite::select_coordinate_system(const int8_t _new) {
-  if (active_coordinate_system == _new) return false;
+  if (active_coordinate_system == _new) return false;     // no WCS system change just return
   active_coordinate_system = _new;
   xyz_float_t new_offset{0};
   if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
-    new_offset = coordinate_system[_new];
-  LOOP_NUM_AXES(i) {
+    new_offset = coordinate_system[_new];  // fetch index [_new] from WCS system array and put into new_offset[]
+  LOOP_NUM_AXES(i) { // translates to -> for(i; i<3; i++)
     if (position_shift[i] != new_offset[i]) {
       position_shift[i] = new_offset[i];
-      update_workspace_offset((AxisEnum)i);
+      update_workspace_offset((AxisEnum)i); //TG set workspace_offset[] = home_offset[] + position_shift[] (aka new_offset[])
     }
   }
   return true;
@@ -56,8 +56,8 @@ bool GcodeSuite::select_coordinate_system(const int8_t _new) {
  * Marlin also uses G53 on a line by itself to go back to native space.
  */
 void GcodeSuite::G53() {
-  const int8_t old_system = active_coordinate_system;
-  select_coordinate_system(-1);   // Always remove workspace offsets
+  const int8_t old_system = active_coordinate_system;       // save active_ptr
+  select_coordinate_system(-1); // Always remove workspace, sets workspace_offset[]=home_offset[]+new_offset[], -1 is native 
   #ifdef DEBUG_M53
     SERIAL_ECHOLNPGM("Go to native space");
     report_current_position();
@@ -67,7 +67,7 @@ void GcodeSuite::G53() {
     process_parsed_command(); // ...process the chained command
     select_coordinate_system(old_system);
     #ifdef DEBUG_M53
-      SERIAL_ECHOLNPGM("Go back to workspace ", old_system);
+      SERIAL_ECHOLNPGM("Go back to workspace ", old_system);  //Go back to workspace old_ptr (previously active_coordinate_system)
       report_current_position();
     #endif
   }
@@ -83,8 +83,8 @@ void GcodeSuite::G53() {
  * G92 is used to set the current workspace's offset.
  */
 void G54_59(uint8_t subcode=0) {
-  const int8_t _space = parser.codenum - 54 + subcode;
-  if (gcode.select_coordinate_system(_space)) {
+  const int8_t _space = parser.codenum - 54 + subcode;  // get decimal number after 'G', i.e. 54...59 for G54...G59, minus 54
+  if (gcode.select_coordinate_system(_space)) {         // set workspace_offset[] = home_offset[] + new_offset[]
     SERIAL_ECHOLNPGM("Select workspace ", _space);
     report_current_position();
   }
@@ -96,4 +96,54 @@ void GcodeSuite::G57() { G54_59(); }
 void GcodeSuite::G58() { G54_59(); }
 void GcodeSuite::G59() { G54_59(parser.subcode); }
 
+
+#ifdef ENABLE_G39
+//TG 9/29/22 - added NEW Gcode G39 here to report WCS table or current active Workspace
+// G39 alone will output Active Workspace, G39 T will output table of all workspaces,
+// G39 P reports current position in physical and logical units
+void GcodeSuite::G39(){
+  #define CUSTOM_AXES 4   // allows for "G5x" in front of X , Y , Z
+  char Msg[48];
+  xyze_pos_t lpos;
+  if(parser.seen("T")){ //TG 9/29/22 report table of all workspaces
+    SERIAL_ECHOLNPGM("All Workspaces..... ");  
+    LOOP_INT_S_L_N(i, -1, MAX_COORDINATE_SYSTEMS){
+      sprintf(Msg,"%s%d - %s","G",i+54, i == gcode.active_coordinate_system ? "*" : "  ");
+      lpos = coordinate_system[i];
+      SERIAL_ECHOPGM_P(LIST_N(DOUBLE(CUSTOM_AXES),
+        Msg," " ,
+        X_LBL, lpos.x,
+        SP_Y_LBL, lpos.y,
+        SP_Z_LBL, lpos.z,
+        SP_I_LBL, lpos.i,
+        SP_J_LBL, lpos.j,
+        SP_K_LBL, lpos.k
+      ), "\n"
+      #if HAS_EXTRUDERS
+        , SP_E_LBL, lpos.e
+      #endif
+      );
+    }
+  }
+  else if(parser.seen("P")) { //TG 2/16/23 report current position
+    // Cartesian position in native machine space
+    SERIAL_ECHOPGM("Current position:\n Logical-   ");
+    SERIAL_ECHOLNPGM(" X:", current_position.asLogical().x," Y:", current_position.asLogical().y," Z:", current_position.asLogical().z,"\n");
+    // Position as sent by G-code
+    SERIAL_ECHOPGM("\n Physical- ");
+    SERIAL_ECHOLNPGM(" X:", current_position.x," Y:", current_position.y," Z:", current_position.z,"\n");
+   }
+  else{   //TG 9/29/22 added this for G39 (no params)
+    sprintf(Msg,"Active WCS- G%d (%s):", gcode.active_coordinate_system+54, gcode.active_coordinate_system < 0 ? "*" : "0"+ gcode.active_coordinate_system );  //TG 9/29/22 added this for G39 (no params)
+    SERIAL_ECHO(Msg);
+    lpos = coordinate_system[gcode.active_coordinate_system];
+    SERIAL_ECHOLNPGM(" X:", lpos.x," Y:", lpos.y," Z:", lpos.z,"\n");
+    sprintf(Msg,"Native WCS- G53 (*):");
+    SERIAL_ECHO(Msg);
+    lpos = coordinate_system[-1];
+    SERIAL_ECHOLNPGM(" X:", lpos.x," Y:", lpos.y," Z:", lpos.z,"\n");
+  }
+}
+#endif // ENABLE_G39
+
 #endif // CNC_COORDINATE_SYSTEMS
diff --git a/Marlin/src/gcode/host/M115.cpp b/Marlin/src/gcode/host/M115.cpp
index d28d53eedd..d7a48d7a8e 100644
--- a/Marlin/src/gcode/host/M115.cpp
+++ b/Marlin/src/gcode/host/M115.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -62,18 +62,19 @@
  *       If a capability is not reported, hosts should assume
  *       the capability is not present.
  */
-void GcodeSuite::M115() {
-  SERIAL_ECHOPGM("FIRMWARE_NAME:Marlin"
-    " " DETAILED_BUILD_VERSION " (" __DATE__ " " __TIME__ ")"
-    " SOURCE_CODE_URL:" SOURCE_CODE_URL
-    " PROTOCOL_VERSION:" PROTOCOL_VERSION
-    " MACHINE_TYPE:" MACHINE_NAME
-    " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS)
+void GcodeSuite::
+M115() {
+  SERIAL_ECHOLNPGM(
+    "FIRMWARE_NAME:Marlin " DETAILED_BUILD_VERSION "   (" __DATE__ " " __TIME__ ") "  //TG 9/1/22 added 2 spaces after BUILD VERSION
+    "SOURCE_CODE_URL:" SOURCE_CODE_URL " "
+    "PROTOCOL_VERSION:" PROTOCOL_VERSION " "
+    "MACHINE_TYPE:" MACHINE_NAME " "
+    "EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " "
     #if NUM_AXES != XYZ
-      " AXIS_COUNT:" STRINGIFY(NUM_AXES)
+      "AXIS_COUNT:" STRINGIFY(NUM_AXES) " "
     #endif
     #ifdef MACHINE_UUID
-      " UUID:" MACHINE_UUID
+      "UUID:" MACHINE_UUID
     #endif
   );
 
diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c951fc6333..3f46c06a9c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -483,11 +483,13 @@ void GCodeQueue::get_serial_commands() {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
             if (strtol(apos + 1, nullptr, 10) != checksum) {
+              // In case of error on a serial port, don't prevent other serial port from making progress
               gcode_line_error(F(STR_ERR_CHECKSUM_MISMATCH), p);
               break;
             }
           }
           else {
+            // In case of error on a serial port, don't prevent other serial port from making progress
             gcode_line_error(F(STR_ERR_NO_CHECKSUM), p);
             break;
           }
diff --git a/Marlin/src/inc/Conditionals_LCD.h b/Marlin/src/inc/Conditionals_LCD.h
index 0031e17eea..0645b0b534 100644
--- a/Marlin/src/inc/Conditionals_LCD.h
+++ b/Marlin/src/inc/Conditionals_LCD.h
@@ -1037,11 +1037,12 @@
 #endif
 
 // Helper macros for extruder and hotend arrays
-#define _EXTRUDER_LOOP(E) for (int8_t E = 0; E < EXTRUDERS; E++)
-#define EXTRUDER_LOOP() _EXTRUDER_LOOP(e)
 #define _HOTEND_LOOP(H) for (int8_t H = 0; H < HOTENDS; H++)
 #define HOTEND_LOOP() _HOTEND_LOOP(e)
+#define _EXTRUDER_LOOP(E) for (int8_t E = 0; E < EXTRUDERS; E++)
+#define EXTRUDER_LOOP() _EXTRUDER_LOOP(e)
 
+#define GET_SPINDLES_LOOP() for (int8_t e = 0; e < SPINDLES; e++)    //TG 1/17/20 added for sending S0: messages
 #define ARRAY_BY_EXTRUDERS(V...) ARRAY_N(EXTRUDERS, V)
 #define ARRAY_BY_EXTRUDERS1(v1) ARRAY_N_1(EXTRUDERS, v1)
 #define ARRAY_BY_HOTENDS(V...) ARRAY_N(HOTENDS, V)
@@ -1101,7 +1102,7 @@
 #endif
 
 /**
- * Set flags for any form of bed probe
+ * Set a flag for any type of bed probe, including the paper-test
  */
 #if ANY(TOUCH_MI_PROBE, Z_PROBE_ALLEN_KEY, HAS_Z_SERVO_PROBE, SOLENOID_PROBE, Z_PROBE_SLED, RACK_AND_PINION_PROBE, SENSORLESS_PROBING, MAGLEV4, MAG_MOUNTED_PROBE)
   #define HAS_STOWABLE_PROBE 1
@@ -1459,6 +1460,95 @@
   #define HAS_ETHERNET 1
 #endif
 
+// Fallback Stepper Driver types that don't depend on Configuration_adv.h
+#ifndef X_DRIVER_TYPE
+  #define X_DRIVER_TYPE  A4988
+#endif
+#ifndef X2_DRIVER_TYPE
+  #define X2_DRIVER_TYPE A4988
+#endif
+#ifndef Y_DRIVER_TYPE
+  #define Y_DRIVER_TYPE  A4988
+#endif
+#ifndef Y2_DRIVER_TYPE
+  #define Y2_DRIVER_TYPE A4988
+#endif
+#ifndef Z_DRIVER_TYPE
+  #define Z_DRIVER_TYPE  A4988
+#endif
+#ifndef Z2_DRIVER_TYPE
+  #define Z2_DRIVER_TYPE A4988
+#endif
+#ifndef Z3_DRIVER_TYPE
+  #define Z3_DRIVER_TYPE A4988
+#endif
+#ifndef Z4_DRIVER_TYPE
+  #define Z4_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 0
+  #undef E0_DRIVER_TYPE
+#elif !defined(E0_DRIVER_TYPE)
+  #define E0_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 1
+  #undef E1_DRIVER_TYPE
+#elif !defined(E1_DRIVER_TYPE)
+  #define E1_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 2
+  #undef E2_DRIVER_TYPE
+#elif !defined(E2_DRIVER_TYPE)
+  #define E2_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 3
+  #undef E3_DRIVER_TYPE
+#elif !defined(E3_DRIVER_TYPE)
+  #define E3_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 4
+  #undef E4_DRIVER_TYPE
+#elif !defined(E4_DRIVER_TYPE)
+  #define E4_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 5
+  #undef E5_DRIVER_TYPE
+#elif !defined(E5_DRIVER_TYPE)
+  #define E5_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 6
+  #undef E6_DRIVER_TYPE
+#elif !defined(E6_DRIVER_TYPE)
+  #define E6_DRIVER_TYPE A4988
+#endif
+#if E_STEPPERS <= 7
+  #undef E7_DRIVER_TYPE
+#elif !defined(E7_DRIVER_TYPE)
+  #define E7_DRIVER_TYPE A4988
+#endif
+
+// Fallback axis inverting
+#ifndef INVERT_X_DIR
+  #define INVERT_X_DIR false
+#endif
+#if HAS_Y_AXIS && !defined(INVERT_Y_DIR)
+  #define INVERT_Y_DIR false
+#endif
+#if HAS_Z_AXIS && !defined(INVERT_Z_DIR)
+  #define INVERT_Z_DIR false
+#endif
+#if HAS_I_AXIS && !defined(INVERT_I_DIR)
+  #define INVERT_I_DIR false
+#endif
+#if HAS_J_AXIS && !defined(INVERT_J_DIR)
+  #define INVERT_J_DIR false
+#endif
+#if HAS_K_AXIS && !defined(INVERT_K_DIR)
+  #define INVERT_K_DIR false
+#endif
+#if HAS_EXTRUDERS && !defined(INVERT_E_DIR)
+  #define INVERT_E_DIR false
+#endif
+
 /**
  * This setting is also used by M109 when trying to calculate
  * a ballpark safe margin to prevent wait-forever situation.
diff --git a/Marlin/src/inc/Conditionals_adv.h b/Marlin/src/inc/Conditionals_adv.h
index 5b303e919f..ca5596db2e 100644
--- a/Marlin/src/inc/Conditionals_adv.h
+++ b/Marlin/src/inc/Conditionals_adv.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -865,6 +865,7 @@
   #define _CUTTER_POWER_PWM255  1
   #define _CUTTER_POWER_PERCENT 2
   #define _CUTTER_POWER_RPM     3
+  #define _CUTTER_POWER_SERVO   4   //TG 9/3/21 added this
   #define _CUTTER_POWER(V)      _CAT(_CUTTER_POWER_, V)
   #define CUTTER_UNIT_IS(V)    (_CUTTER_POWER(CUTTER_POWER_UNIT) == _CUTTER_POWER(V))
 #endif
@@ -1108,6 +1109,53 @@
   #define HAS_SAFE_BED_LEVELING 1
 #endif
 
+// Remove unused STEALTHCHOP flags
+#if NUM_AXES < 9
+  #undef STEALTHCHOP_W
+  #undef CALIBRATION_MEASURE_WMIN
+  #undef CALIBRATION_MEASURE_WMAX
+  #if NUM_AXES < 8
+    #undef STEALTHCHOP_V
+    #undef CALIBRATION_MEASURE_VMIN
+    #undef CALIBRATION_MEASURE_VMAX
+    #if NUM_AXES < 7
+      #undef STEALTHCHOP_U
+      #undef CALIBRATION_MEASURE_UMIN
+      #undef CALIBRATION_MEASURE_UMAX
+      #if NUM_AXES < 6
+        #undef STEALTHCHOP_K
+        #undef CALIBRATION_MEASURE_KMIN
+        #undef CALIBRATION_MEASURE_KMAX
+        #if NUM_AXES < 5
+          #undef STEALTHCHOP_J
+          #undef CALIBRATION_MEASURE_JMIN
+          #undef CALIBRATION_MEASURE_JMAX
+          #if NUM_AXES < 4
+            #undef STEALTHCHOP_I
+            #undef CALIBRATION_MEASURE_IMIN
+            #undef CALIBRATION_MEASURE_IMAX
+            #if NUM_AXES < 3
+              #undef STEALTHCHOP_Z
+              #undef Z_IDLE_HEIGHT
+              #undef Z_PROBE_SLED
+              #undef Z_SAFE_HOMING
+              #undef HOME_Z_FIRST
+              #undef HOMING_Z_WITH_PROBE
+              #undef ENABLE_LEVELING_FADE_HEIGHT
+              #undef NUM_Z_STEPPERS
+              #undef CNC_WORKSPACE_PLANES
+              #if NUM_AXES < 2
+                #undef STEALTHCHOP_Y
+                #undef QUICK_HOME
+              #endif
+            #endif
+          #endif
+        #endif
+      #endif
+    #endif
+  #endif
+#endif
+
 //
 // SD Card connection methods
 // Defined here so pins and sanity checks can use them
@@ -1197,6 +1245,10 @@
   #define CANNOT_EMBED_CONFIGURATION defined(__AVR__)
 #endif
 
+#if ANY(DISABLE_INACTIVE_X, DISABLE_INACTIVE_Y, DISABLE_INACTIVE_Z, DISABLE_INACTIVE_I, DISABLE_INACTIVE_J, DISABLE_INACTIVE_K, DISABLE_INACTIVE_U, DISABLE_INACTIVE_V, DISABLE_INACTIVE_W, DISABLE_INACTIVE_E)
+  #define HAS_DISABLE_INACTIVE_AXIS 1
+#endif
+
 // Fan Kickstart
 #if FAN_KICKSTART_TIME && !defined(FAN_KICKSTART_POWER)
   #define FAN_KICKSTART_POWER 180
@@ -1209,6 +1261,11 @@
 #endif
 
 // Input shaping
+#if !HAS_Y_AXIS
+  #undef INPUT_SHAPING_Y
+  #undef SHAPING_FREQ_Y
+  #undef SHAPING_BUFFER_Y
+#endif
 #if EITHER(INPUT_SHAPING_X, INPUT_SHAPING_Y)
   #define HAS_SHAPING 1
 #endif
diff --git a/Marlin/src/inc/Conditionals_post.h b/Marlin/src/inc/Conditionals_post.h
index 249aa5c30e..973c2196b7 100644
--- a/Marlin/src/inc/Conditionals_post.h
+++ b/Marlin/src/inc/Conditionals_post.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
diff --git a/Marlin/src/inc/SanityCheck.h b/Marlin/src/inc/SanityCheck.h
index 7d8f404591..be86e3b2cc 100644
--- a/Marlin/src/inc/SanityCheck.h
+++ b/Marlin/src/inc/SanityCheck.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -4504,3 +4504,14 @@ static_assert(_PLUS_TEST(4), "HOMING_FEEDRATE_MM_M values must be positive.");
 #undef _TEST_PWM
 #undef _NUM_AXES_STR
 #undef _LOGICAL_AXES_STR
+
+/**
+ * //TG 5/25/21 Sanity check for valid LASER/SPINDLE pins assignment
+ */
+
+#if !SPINDLE_LASER_USE_FAN_HEATER_PINS && defined(HAS_TMC_UART)
+ #error "Spindle/Laser cannot use J8 pins already used by TMC_UART."
+#endif
+#if (HAS_HEATER_0  || EXTRUDERS || FAN_PIN) && SPINDLE_LASER_USE_FAN_HEATER_PINS
+ #error "Spindle/Laser cannot use Heater or Fan pins when Extruder, Bed, or Fans in use." 
+#endif
diff --git a/Marlin/src/inc/Version.h b/Marlin/src/inc/Version.h
index da24836a33..982955b2f7 100644
--- a/Marlin/src/inc/Version.h
+++ b/Marlin/src/inc/Version.h
@@ -85,6 +85,12 @@
   #define SOURCE_CODE_URL "github.com/MarlinFirmware/Marlin"
 #endif
 
+//TG 2/13/23 override with local SRC_FILE_NAME supplied by platformio build_flags
+#ifdef SOURCE_CODE_URL
+  #undef SOURCE_CODE_URL
+  #define SOURCE_CODE_URL SRC_FILE_NAME       
+#endif
+
 /**
  * Default generic printer UUID.
  */
diff --git a/Marlin/src/inc/Warnings.cpp b/Marlin/src/inc/Warnings.cpp
index 1d1426936f..7b6db79f23 100644
--- a/Marlin/src/inc/Warnings.cpp
+++ b/Marlin/src/inc/Warnings.cpp
@@ -51,7 +51,7 @@
   #warning "Safety Alert! Enable THERMAL_PROTECTION_HOTENDS for the final build!"
 #endif
 #if HAS_HEATED_BED && DISABLED(THERMAL_PROTECTION_BED)
-  #warning "Safety Alert! Enable THERMAL_PROTECTION_BED for the final build!"
+  //TG commented out      #warning "Safety Alert! Enable THERMAL_PROTECTION_BED for the final build!"
 #endif
 #if HAS_HEATED_CHAMBER && DISABLED(THERMAL_PROTECTION_CHAMBER)
   #warning "Safety Alert! Enable THERMAL_PROTECTION_CHAMBER for the final build!"
@@ -60,7 +60,7 @@
   #warning "Safety Alert! Enable THERMAL_PROTECTION_COOLER for the final build!"
 #endif
 #if ANY_THERMISTOR_IS(998) || ANY_THERMISTOR_IS(999)
-  #warning "Warning! Don't use dummy thermistors (998/999) for final build!"
+  //TG commented out      #warning "Warning! Don't use dummy thermistors (998/999) for final build!"
 #endif
 
 #if NONE(HAS_RESUME_CONTINUE, HOST_PROMPT_SUPPORT)
@@ -771,7 +771,7 @@
 #endif
 
 /**
- * PrÅ¯Å¡a MK3/S/+ fan pin reassignment
+ * Pruï¿½a MK3/S/+ fan pin reassignment
  */
 #if MB(BTT_BTT002_V1_0, EINSY_RAMBO) && DISABLED(NO_MK3_FAN_PINS_WARNING)
   #warning "Define MK3_FAN_PINS to swap hotend and part cooling fan pins. (Define NO_MK3_FAN_PINS_WARNING to suppress this warning.)"
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin.cpp b/Marlin/src/lcd/e3v2/enhanced/dwin.cpp
new file mode 100644
index 0000000000..20c6c73bc4
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin.cpp
@@ -0,0 +1,3792 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.9.1
+ * Date: 2021/11/21
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+
+#include "dwin.h"
+#include "dwin_popup.h"
+
+#include "../../fontutils.h"
+#include "../../marlinui.h"
+
+#include "../../../sd/cardreader.h"
+
+#include "../../../MarlinCore.h"
+#include "../../../core/serial.h"
+#include "../../../core/macros.h"
+
+#include "../../../module/temperature.h"
+#include "../../../module/printcounter.h"
+#include "../../../module/motion.h"
+#include "../../../module/planner.h"
+
+#include "../../../gcode/gcode.h"
+#include "../../../gcode/queue.h"
+
+#if HAS_FILAMENT_SENSOR
+  #include "../../../feature/runout.h"
+#endif
+
+#if ENABLED(EEPROM_SETTINGS)
+  #include "../../../module/settings.h"
+#endif
+
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "../../../feature/host_actions.h"
+#endif
+
+#if HAS_MESH || HAS_ONESTEP_LEVELING
+  #include "../../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../../module/probe.h"
+#endif
+
+#ifdef BLTOUCH_HS_MODE
+  #include "../../../feature/bltouch.h"
+#endif
+
+#if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+  #include "../../../feature/babystep.h"
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../../feature/powerloss.h"
+#endif
+
+#if HAS_ESDIAG
+  #include "endstop_diag.h"
+#endif
+
+#if HAS_MESH
+  #include "meshviewer.h"
+#endif
+
+#if ENABLED(PRINTCOUNTER)
+  #include "printstats.h"
+#endif
+
+#include <WString.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifndef MACHINE_SIZE
+  #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
+#endif
+
+#include "lockscreen.h"
+
+#ifndef CORP_WEBSITE
+  #define CORP_WEBSITE WEBSITE_URL
+#endif
+
+#define PAUSE_HEAT
+
+#define MENU_CHAR_LIMIT  24
+
+// Print speed limit
+#define MIN_PRINT_SPEED  10
+#define MAX_PRINT_SPEED 999
+
+// Print flow limit
+#define MIN_PRINT_FLOW   10
+#define MAX_PRINT_FLOW   299
+
+// Load and Unload limits
+#define MAX_LOAD_UNLOAD  500
+
+// Feedspeed limit (max feedspeed = DEFAULT_MAX_FEEDRATE * 2)
+#define MIN_MAXFEEDSPEED      1
+#define MIN_MAXACCELERATION   1
+#define MIN_MAXJERK           0.1
+#define MIN_STEP              1
+#define MAX_STEP              999.9
+
+// Extruder's temperature limits
+#define MIN_ETEMP  HEATER_0_MINTEMP
+#define MAX_ETEMP  (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+
+#define FEEDRATE_E      (60)
+
+// Minimum unit (0.1) : multiple (10)
+#define UNITFDIGITS 1
+#define MINUNITMULT POW(10, UNITFDIGITS)
+
+#define ENCODER_WAIT_MS                  20
+#define DWIN_VAR_UPDATE_INTERVAL         1024
+#define DWIN_SCROLL_UPDATE_INTERVAL      SEC_TO_MS(2)
+#define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
+
+#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, dwin_zoffset)
+
+// Structs
+HMI_value_t HMI_value;
+HMI_flag_t HMI_flag{0};
+HMI_data_t HMI_data;
+
+millis_t dwin_heat_time = 0;
+
+uint8_t checkkey = 255, last_checkkey = MainMenu;
+
+enum SelectItem : uint8_t {
+  PAGE_PRINT = 0,
+  PAGE_PREPARE,
+  PAGE_CONTROL,
+  PAGE_INFO_LEVELING,
+  PAGE_COUNT,
+
+  PRINT_SETUP = 0,
+  PRINT_PAUSE_RESUME,
+  PRINT_STOP,
+  PRINT_COUNT
+};
+
+typedef struct {
+  uint8_t now, last;
+  void set(uint8_t v) { now = last = v; }
+  void reset() { set(0); }
+  bool changed() { bool c = (now != last); if (c) last = now; return c; }
+  bool dec() { if (now) now--; return changed(); }
+  bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
+} select_t;
+
+select_t select_page{0}, select_file{0}, select_print{0};
+uint8_t index_file     = MROWS;
+
+bool dwin_abort_flag = false; // Flag to reset feedrate, return to Home
+bool hash_changed = true; // Flag to know if message status was changed
+
+constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
+constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
+
+#if HAS_CLASSIC_JERK
+  constexpr float default_max_jerk[]          = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+#endif
+
+static uint8_t _percent_done = 0;
+static uint32_t _remain_time = 0;
+
+// Additional Aux Host Support
+static bool sdprint = false;
+
+#if ENABLED(PAUSE_HEAT)
+  #if HAS_HOTEND
+    celsius_t resume_hotend_temp = 0;
+  #endif
+  #if HAS_HEATED_BED
+    celsius_t resume_bed_temp = 0;
+  #endif
+  #if HAS_FAN
+    uint16_t resume_fan = 0;
+  #endif
+#endif
+
+#if HAS_ZOFFSET_ITEM
+  float dwin_zoffset = 0, last_zoffset = 0;
+#endif
+
+#if HAS_HOTEND
+  float last_E = 0;
+#endif
+
+// New menu system pointers
+MenuClass *PrepareMenu = nullptr;
+MenuClass *TrammingMenu = nullptr;
+MenuClass *MoveMenu = nullptr;
+MenuClass *ControlMenu = nullptr;
+MenuClass *AdvancedSettings = nullptr;
+#if HAS_HOME_OFFSET
+  MenuClass *HomeOffMenu = nullptr;
+#endif
+#if HAS_BED_PROBE
+  MenuClass *ProbeSetMenu = nullptr;
+#endif
+MenuClass *FilSetMenu = nullptr;
+MenuClass *SelectColorMenu = nullptr;
+MenuClass *GetColorMenu = nullptr;
+MenuClass *TuneMenu = nullptr;
+MenuClass *MotionMenu = nullptr;
+MenuClass *FilamentMenu = nullptr;
+#if ENABLED(MESH_BED_LEVELING)
+  MenuClass *ManualMesh = nullptr;
+#endif
+#if HAS_HOTEND
+  MenuClass *PreheatMenu = nullptr;
+#endif
+MenuClass *TemperatureMenu = nullptr;
+MenuClass *MaxSpeedMenu = nullptr;
+MenuClass *MaxAccelMenu = nullptr;
+MenuClass *MaxJerkMenu = nullptr;
+MenuClass *StepsMenu = nullptr;
+MenuClass *HotendPIDMenu = nullptr;
+MenuClass *BedPIDMenu = nullptr;
+#if HAS_BED_PROBE
+  MenuClass *ZOffsetWizMenu = nullptr;
+#endif
+#if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  MenuClass *HomingMenu = nullptr;
+#endif
+
+// Updatable menuitems pointers
+MenuItemClass *HotendTargetItem = nullptr;
+MenuItemClass *BedTargetItem = nullptr;
+MenuItemClass *FanSpeedItem = nullptr;
+MenuItemClass *MMeshMoveZItem = nullptr;
+
+#define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
+                                            // BL24CXX::check() uses 0x00
+
+inline bool HMI_IsChinese() { return HMI_flag.language == DWIN_CHINESE; }
+
+void HMI_SetLanguageCache() {
+  DWIN_JPG_CacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
+}
+
+void HMI_SetLanguage() {
+  #if BOTH(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
+    BL24CXX::read(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
+  #endif
+  HMI_SetLanguageCache();
+}
+
+void HMI_ToggleLanguage() {
+  HMI_flag.language = HMI_IsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
+  HMI_SetLanguageCache();
+  #if BOTH(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
+    BL24CXX::write(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
+  #endif
+}
+
+//-----------------------------------------------------------------------------
+// Main Buttons
+//-----------------------------------------------------------------------------
+
+typedef struct { uint16_t x, y[2], w, h; } text_info_t;
+
+void ICON_Button(const bool selected, const int iconid, const frame_rect_t &ico, const text_info_t (&txt), FSTR_P caption) {
+  DWIN_ICON_Show(true, false, false, ICON, iconid + selected, ico.x, ico.y);
+  if (selected) DWINUI::Draw_Box(0, HMI_data.Highlight_Color, ico);
+  if (HMI_IsChinese()) {
+    DWIN_Frame_AreaCopy(1, txt.x, txt.y[selected], txt.x + txt.w - 1, txt.y[selected] + txt.h - 1, ico.x + (ico.w - txt.w) / 2, (ico.y + ico.h - 28) - txt.h/2);
+  }
+  else {
+    const uint16_t x = ico.x + (ico.w - strlen_P(FTOP(caption)) * DWINUI::fontWidth()) / 2,
+                   y = (ico.y + ico.h - 28) - DWINUI::fontHeight() / 2;
+    DWINUI::Draw_String(x, y, caption);
+  }
+}
+
+//
+// Main Menu: "Print"
+//
+void ICON_Print() {
+  constexpr frame_rect_t ico = { 17, 110, 110, 100 };
+  constexpr text_info_t txt = { 1, { 405, 447 }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_PRINT, ICON_Print_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PRINT));
+}
+
+//
+// Main Menu: "Prepare"
+//
+void ICON_Prepare() {
+  constexpr frame_rect_t ico = { 145, 110, 110, 100 };
+  constexpr text_info_t txt = { 31, { 405, 447 }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_PREPARE, ICON_Prepare_0, ico, txt, GET_TEXT_F(MSG_PREPARE));
+}
+
+//
+// Main Menu: "Control"
+//
+void ICON_Control() {
+  constexpr frame_rect_t ico = { 17, 226, 110, 100 };
+  constexpr text_info_t txt = { 61, { 405, 447 }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_CONTROL, ICON_Control_0, ico, txt, GET_TEXT_F(MSG_CONTROL));
+}
+
+//
+// Main Menu: "Info"
+//
+void ICON_StartInfo() {
+  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
+  constexpr text_info_t txt = { 91, { 405, 447 }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_INFO_LEVELING, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_INFO));
+}
+
+//
+// Main Menu: "Level"
+//
+void ICON_Leveling() {
+  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
+  constexpr text_info_t txt = { 211, { 405, 447 }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_INFO_LEVELING, ICON_Leveling_0, ico, txt, GET_TEXT_F(MSG_BUTTON_LEVEL));
+}
+
+//
+// Printing: "Tune"
+//
+void ICON_Tune() {
+  constexpr frame_rect_t ico = { 8, 232, 80, 100 };
+  constexpr text_info_t txt = { 121, { 405, 447 }, 27, 15 };
+  ICON_Button(select_print.now == PRINT_SETUP, ICON_Setup_0, ico, txt, GET_TEXT_F(MSG_TUNE));
+}
+
+//
+// Printing: "Pause"
+//
+void ICON_Pause() {
+  constexpr frame_rect_t ico = { 96, 232, 80, 100 };
+  constexpr text_info_t txt = { 181, { 405, 447 }, 27, 15 };
+  ICON_Button(select_print.now == PRINT_PAUSE_RESUME, ICON_Pause_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PAUSE));
+}
+
+//
+// Printing: "Resume"
+//
+void ICON_Resume() {
+  constexpr frame_rect_t ico = { 96, 232, 80, 100 };
+  constexpr text_info_t txt = {  1, { 405, 447 }, 27, 15 };
+  ICON_Button(select_print.now == PRINT_PAUSE_RESUME, ICON_Continue_0, ico, txt, GET_TEXT_F(MSG_BUTTON_RESUME));
+}
+
+//
+// Printing: "Stop"
+//
+void ICON_Stop() {
+  constexpr frame_rect_t ico = { 184, 232, 80, 100 };
+  constexpr text_info_t txt = { 151, { 405, 447 }, 27, 12 };
+  ICON_Button(select_print.now == PRINT_STOP, ICON_Stop_0, ico, txt, GET_TEXT_F(MSG_BUTTON_STOP));
+}
+
+//-----------------------------------------------------------------------------
+// Drawing routines
+//-----------------------------------------------------------------------------
+
+void Draw_Menu_Cursor(const int8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Cursor_color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+}
+
+void Erase_Menu_Cursor(const int8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+}
+
+void Move_Highlight(const int8_t from, const int8_t newline) {
+  Erase_Menu_Cursor(newline - from);
+  Draw_Menu_Cursor(newline);
+}
+
+void Add_Menu_Line() {
+  Move_Highlight(1, MROWS);
+  DWIN_Draw_Line(HMI_data.SplitLine_Color, 16, MBASE(MROWS + 1) - 20, 256, MBASE(MROWS + 1) - 19);
+}
+
+void Scroll_Menu(const uint8_t dir) {
+  DWIN_Frame_AreaMove(1, dir, MLINE, HMI_data.Background_Color, 0, 31, DWIN_WIDTH, 349);
+  switch (dir) {
+    case DWIN_SCROLL_DOWN: Move_Highlight(-1, 0); break;
+    case DWIN_SCROLL_UP:   Add_Menu_Line(); break;
+  }
+}
+
+inline uint16_t nr_sd_menu_items() {
+  return card.get_num_Files() + !card.flag.workDirIsRoot;
+}
+
+void Erase_Menu_Text(const uint8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, LBLX, MBASE(line) - 14, 271, MBASE(line) + 28);
+}
+
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon=0, const char * const label=nullptr, bool more=false) {
+  if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
+  if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
+  if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+void Draw_Chkb_Line(const uint8_t line, const bool checked) {
+  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 16, MBASE(line) - 1, checked);
+}
+
+void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const uint16_t value=0) {
+  DWINUI::Draw_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
+}
+
+// The "Back" label is always on the first line
+void Draw_Back_Label() {
+  if (HMI_IsChinese())
+    DWIN_Frame_AreaCopy(1, 129, 72, 156, 84, LBLX, MBASE(0));
+  else
+    DWIN_Frame_AreaCopy(1, 223, 179, 254, 189, LBLX, MBASE(0));
+}
+
+// Draw "Back" line at the top
+void Draw_Back_First(const bool is_sel=true) {
+  Draw_Menu_Line(0, ICON_Back);
+  Draw_Back_Label();
+  if (is_sel) Draw_Menu_Cursor(0);
+}
+
+inline EncoderState get_encoder_state() {
+  static millis_t Encoder_ms = 0;
+  const millis_t ms = millis();
+  if (PENDING(ms, Encoder_ms)) return ENCODER_DIFF_NO;
+  const EncoderState state = Encoder_ReceiveAnalyze();
+  if (state != ENCODER_DIFF_NO) Encoder_ms = ms + ENCODER_WAIT_MS;
+  return state;
+}
+
+template<typename T>
+inline bool Apply_Encoder(const EncoderState &encoder_diffState, T &valref) {
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    valref += EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    valref -= EncoderRate.encoderMoveValue;
+  return encoder_diffState == ENCODER_DIFF_ENTER;
+}
+
+//PopUps
+void Popup_window_PauseOrStop() {
+  if (HMI_IsChinese()) {
+  DWINUI::ClearMenuArea();
+    Draw_Popup_Bkgd();
+         if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
+    else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
+    DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
+    DWINUI::Draw_Icon(ICON_Confirm_C, 26, 280);
+    DWINUI::Draw_Icon(ICON_Cancel_C, 146, 280);
+    Draw_Select_Highlight(true);
+  DWIN_UpdateLCD();
+  }
+  else 
+    DWIN_Popup_ConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
+}
+
+#if HAS_HOTEND
+
+  void Popup_Window_ETempTooLow() {
+    if (HMI_IsChinese()) {
+      HMI_SaveProcessID(WaitResponse);
+      DWINUI::ClearMenuArea();
+      Draw_Popup_Bkgd();
+      DWINUI::Draw_Icon(ICON_TempTooLow, 102, 105);
+      DWIN_Frame_AreaCopy(1, 103, 371, 136, 386,  69, 240);
+      DWIN_Frame_AreaCopy(1, 170, 371, 270, 386, 102, 240);
+      DWINUI::Draw_Icon(ICON_Confirm_C, 86, 280);
+      DWIN_UpdateLCD();
+    }
+    else
+      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
+  }
+
+#endif
+
+#if HAS_HOTEND || HAS_HEATED_BED
+  void DWIN_Popup_Temperature(const bool toohigh) {
+    DWINUI::ClearMenuArea();
+    Draw_Popup_Bkgd();
+    if (HMI_IsChinese()) {
+    if (toohigh) {
+      DWINUI::Draw_Icon(ICON_TempTooHigh, 102, 165);
+        DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
+        DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
+        DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
+      }
+      else {
+        DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
+        DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
+        DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
+      }
+    }
+    else {
+      DWIN_Draw_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"));
+    }
+  }
+#endif
+
+// Draw status line
+void DWIN_DrawStatusLine(const uint16_t color, const uint16_t bgcolor, const char *text, const bool center = true) {
+  DWIN_Draw_Rectangle(1, bgcolor, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+  if (text) {
+    if (center) DWINUI::Draw_CenteredString(color, STATUS_Y + 2, text);
+    else        DWINUI::Draw_String(color, 0, STATUS_Y + 2, text);
+  }
+  DWIN_UpdateLCD();
+}
+void DWIN_DrawStatusLine(const char *text, const bool center = true) {
+  DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, text, center);
+}
+
+// Clear & reset status line
+void DWIN_ResetStatusLine() {
+  ui.status_message[0] = 0;
+  DWIN_CheckStatusMessage();
+}
+
+// Djb2 hash algorithm
+void DWIN_CheckStatusMessage() {
+  static uint32_t old_hash = 0;
+  char * str = &ui.status_message[0];
+  uint32_t hash = 5381;
+  char c;
+  while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
+  hash_changed = hash != old_hash;
+  old_hash = hash;
+};
+
+void DWIN_DrawStatusMessage() {
+  const uint8_t max_status_chars = DWIN_WIDTH / DWINUI::fontWidth();
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(ui.status_message);
+
+    // If the string fits the status line do not scroll it
+    if (slen <= max_status_chars) {
+       if (hash_changed) {
+         DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, ui.status_message);
+         hash_changed = false;
+       }
+    }
+    else {
+      // String is larger than the available line space
+
+      // Get a pointer to the next valid UTF8 character
+      // and the string remaining length
+      uint8_t rlen;
+      const char *stat = MarlinUI::status_and_len(rlen);
+      DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+      DWINUI::MoveTo(0, STATUS_Y + 2);
+      DWINUI::Draw_String(stat, max_status_chars);
+
+      // If the string doesn't completely fill the line...
+      if (rlen < max_status_chars) {
+        DWINUI::Draw_Char('.');                   // Always at 1+ spaces left, draw a dot
+        uint8_t chars = max_status_chars - rlen;  // Amount of space left in characters
+        if (--chars) {                            // Draw a second dot if there's space
+          DWINUI::Draw_Char('.');
+          if (--chars)
+            DWINUI::Draw_String(ui.status_message, chars); // Print a second copy of the message
+        }
+      }
+      MarlinUI::advance_status_scroll();
+    }
+
+  #else
+
+    if (hash_changed) {
+      ui.status_message[max_status_chars] = 0;
+      DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, ui.status_message);
+      hash_changed = false;
+    }
+
+  #endif
+}
+
+void Draw_Print_Labels() {
+  if (HMI_IsChinese()) {
+    DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
+    DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
+  }
+  else {
+    DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
+    DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
+  }
+}
+
+void Draw_Print_ProgressBar() {
+  DWINUI::Draw_Icon(ICON_Bar, 15, 93);
+  DWIN_Draw_Rectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
+  DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
+  DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
+}
+
+void Draw_Print_ProgressElapsed() {
+  char buf[10];
+  duration_t elapsed = print_job_timer.duration(); // print timer
+  sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
+  DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
+}
+
+void Draw_Print_ProgressRemain() {
+  char buf[10];
+  sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
+  DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
+}
+
+void ICON_ResumeOrPause() {
+  if (printingIsPaused() || HMI_flag.pause_flag || HMI_flag.pause_action)
+    ICON_Resume();
+  else
+    ICON_Pause();
+}
+
+void Draw_PrintProcess() {
+  if (HMI_IsChinese())
+    Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
+  else
+    Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
+  DWINUI::ClearMenuArea();
+  DWIN_Print_Header(sdprint ? card.longest_filename() : nullptr);
+  Draw_Print_Labels();
+  DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
+  DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
+  Draw_Print_ProgressBar();
+  Draw_Print_ProgressElapsed();
+  Draw_Print_ProgressRemain();
+  ICON_Tune();
+  ICON_ResumeOrPause();
+  ICON_Stop();
+  DWIN_UpdateLCD();
+}
+
+void Goto_PrintProcess() {
+  if (checkkey == PrintProcess) {
+    ICON_ResumeOrPause();
+    DWIN_UpdateLCD();
+    return;
+  }
+  checkkey = PrintProcess;
+  Draw_PrintProcess();
+}
+
+void Draw_PrintDone() {
+  // show percent bar and value
+  _percent_done = 100;
+  _remain_time = 0;
+
+  Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
+  DWINUI::ClearMenuArea();
+  DWIN_Print_Header(nullptr);
+  Draw_Print_ProgressBar();
+  Draw_Print_Labels();
+  DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
+  DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
+  Draw_Print_ProgressElapsed();
+  Draw_Print_ProgressRemain();
+  // show print done confirm
+  DWINUI::Draw_Icon(HMI_IsChinese() ? ICON_Confirm_C : ICON_Confirm_E, 86, 273);
+  DWIN_UpdateLCD();
+}
+
+void Draw_Main_Menu() {
+  DWINUI::ClearMenuArea();
+  if (HMI_IsChinese())
+    Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
+  else
+    Title.ShowCaption(MACHINE_NAME);
+  DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
+  ICON_Print();
+  ICON_Prepare();
+  ICON_Control();
+  TERN(HAS_ONESTEP_LEVELING, ICON_Leveling, ICON_StartInfo)();
+  DWIN_UpdateLCD();
+}
+
+void Goto_Main_Menu() {
+  if (checkkey == MainMenu) return;
+  checkkey = MainMenu;
+  ui.reset_status(true);
+  Draw_Main_Menu();
+}
+
+// Draw X, Y, Z and blink if in an un-homed or un-trusted state
+void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool blink, const bool force) {
+  const bool draw_qmark = axis_should_home(axis),
+             draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
+
+  // Check for a position change
+  static xyz_pos_t oldpos = { -1, -1, -1 };
+  const float p = current_position[axis];
+  const bool changed = oldpos[axis] != p;
+  if (changed) oldpos[axis] = p;
+
+  if (force || changed || draw_qmark || draw_empty) {
+    if (blink && draw_qmark)
+      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("--?--"));
+    else if (blink && draw_empty)
+      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("     "));
+    else
+      DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 1, x, y, p);
+  }
+}
+
+void _draw_xyz_position(const bool force) {
+  //SERIAL_ECHOPGM("Draw XYZ:");
+  static bool _blink = false;
+  const bool blink = !!(millis() & 0x400UL);
+  if (force || blink != _blink) {
+    _blink = blink;
+    //SERIAL_ECHOPGM(" (blink)");
+    _update_axis_value(X_AXIS,  35, 459, blink, true);
+    _update_axis_value(Y_AXIS, 120, 459, blink, true);
+    _update_axis_value(Z_AXIS, 205, 459, blink, true);
+  }
+  //SERIAL_EOL();
+}
+
+void update_variable() {
+  #if HAS_HOTEND
+    static celsius_t _hotendtemp = 0, _hotendtarget = 0;
+    const celsius_t hc = thermalManager.wholeDegHotend(0),
+                    ht = thermalManager.degTargetHotend(0);
+    const bool _new_hotend_temp = _hotendtemp != hc,
+               _new_hotend_target = _hotendtarget != ht;
+    if (_new_hotend_temp) _hotendtemp = hc;
+    if (_new_hotend_target) _hotendtarget = ht;
+  #endif
+  #if HAS_HEATED_BED
+    static celsius_t _bedtemp = 0, _bedtarget = 0;
+    const celsius_t bc = thermalManager.wholeDegBed(),
+                    bt = thermalManager.degTargetBed();
+    const bool _new_bed_temp = _bedtemp != bc,
+               _new_bed_target = _bedtarget != bt;
+    if (_new_bed_temp) _bedtemp = bc;
+    if (_new_bed_target) _bedtarget = bt;
+  #endif
+  #if HAS_FAN
+    static uint8_t _fanspeed = 0;
+    const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
+    if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
+  #endif
+
+  if (checkkey == Menu && (CurrentMenu == TuneMenu || CurrentMenu == TemperatureMenu)) {
+    // Tune page temperature update
+    #if HAS_HOTEND
+      if (_new_hotend_target)
+        HotendTargetItem->draw(CurrentMenu->line(HotendTargetItem->pos));
+    #endif
+    #if HAS_HEATED_BED
+      if (_new_bed_target)
+        BedTargetItem->draw(CurrentMenu->line(BedTargetItem->pos));
+    #endif
+    #if HAS_FAN
+      if (_new_fanspeed)
+        FanSpeedItem->draw(CurrentMenu->line(FanSpeedItem->pos));
+    #endif
+  }
+
+  // Bottom temperature update
+
+  #if HAS_HOTEND
+    if (_new_hotend_temp)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, _hotendtemp);
+    if (_new_hotend_target)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, _hotendtarget);
+
+    static int16_t _flow = planner.flow_percentage[0];
+    if (_flow != planner.flow_percentage[0]) {
+      _flow = planner.flow_percentage[0];
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, _flow);
+    }
+  #endif
+
+  #if HAS_HEATED_BED
+    if (_new_bed_temp)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, _bedtemp);
+    if (_new_bed_target)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, _bedtarget);
+  #endif
+
+  static int16_t _feedrate = 100;
+  if (_feedrate != feedrate_percentage) {
+    _feedrate = feedrate_percentage;
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
+  }
+
+  #if HAS_FAN
+    if (_new_fanspeed) {
+      _fanspeed = thermalManager.fan_speed[0];
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
+    }
+  #endif
+
+  static float _offset = 0;
+  if (BABY_Z_VAR != _offset) {
+    _offset = BABY_Z_VAR;
+    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 210, 417, _offset);
+  }
+
+  #if HAS_MESH
+    static bool _leveling_active = false;
+    if (_leveling_active != planner.leveling_active) {
+      _leveling_active = planner.leveling_active;
+      DWIN_Draw_Box(1, HMI_data.Background_Color, 186, 416, 20, 20);
+      if (_leveling_active)
+        DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
+      else
+        DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
+    }
+  #endif
+
+  _draw_xyz_position(false);
+}
+
+/**
+ * Read and cache the working directory.
+ *
+ * TODO: New code can follow the pattern of menu_media.cpp
+ * and rely on Marlin caching for performance. No need to
+ * cache files here.
+ */
+
+#ifndef strcasecmp_P
+  #define strcasecmp_P(a, b) strcasecmp((a), (b))
+#endif
+
+void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
+  size_t pos = strlen(src);  // index of ending nul
+
+  // For files, remove the extension
+  // which may be .gcode, .gco, or .g
+  if (!card.flag.filenameIsDir)
+    while (pos && src[pos] != '.') pos--; // find last '.' (stop at 0)
+
+  if (!pos) pos = strlen(src);  // pos = 0 ('.' not found) restore pos
+
+  size_t len = pos;   // nul or '.'
+  if (len > maxlen) { // Keep the name short
+    pos        = len = maxlen; // move nul down
+    dst[--pos] = '.'; // insert dots
+    dst[--pos] = '.';
+    dst[--pos] = '.';
+  }
+
+  dst[len] = '\0';    // end it
+
+  // Copy down to 0
+  while (pos--) dst[pos] = src[pos];
+}
+
+void HMI_SDCardInit() { card.cdroot(); }
+
+void MarlinUI::refresh() { /* Nothing to see here */ }
+
+#if HAS_LCD_BRIGHTNESS
+  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+#endif
+
+#define ICON_Folder ICON_More
+
+#if ENABLED(SCROLL_LONG_FILENAMES)
+
+  char shift_name[LONG_FILENAME_LENGTH + 1];
+  int8_t shift_amt; // = 0
+  millis_t shift_ms; // = 0
+
+  // Init the shift name based on the highlighted item
+  void Init_Shift_Name() {
+    const bool is_subdir = !card.flag.workDirIsRoot;
+    const int8_t filenum = select_file.now - 1 - is_subdir; // Skip "Back" and ".."
+    const uint16_t fileCnt = card.get_num_Files();
+    if (WITHIN(filenum, 0, fileCnt - 1)) {
+      card.getfilename_sorted(SD_ORDER(filenum, fileCnt));
+      char * const name = card.longest_filename();
+      make_name_without_ext(shift_name, name, 100);
+    }
+  }
+
+  void Init_SDItem_Shift() {
+    shift_amt = 0;
+    shift_ms = select_file.now > 0 && strlen(shift_name) > MENU_CHAR_LIMIT ? millis() + 750UL : 0;
+  }
+
+#endif
+
+/**
+ * Display an SD item, adding a CDUP for subfolders.
+ */
+void Draw_SDItem(const uint16_t item, int16_t row=-1) {
+  if (row < 0) row = item + 1 + MROWS - index_file;
+  const bool is_subdir = !card.flag.workDirIsRoot;
+  if (is_subdir && item == 0)
+    return Draw_Menu_Line(row, ICON_Folder, "..");
+
+  card.getfilename_sorted(SD_ORDER(item - is_subdir, card.get_num_Files()));
+  char * const name = card.longest_filename();
+
+  #if ENABLED(SCROLL_LONG_FILENAMES)
+    // Init the current selected name
+    // This is used during scroll drawing
+    if (item == select_file.now - 1) {
+      make_name_without_ext(shift_name, name, 100);
+      Init_SDItem_Shift();
+    }
+  #endif
+
+  // Draw the file/folder with name aligned left
+  char str[strlen(name) + 1];
+  make_name_without_ext(str, name);
+  Draw_Menu_Line(row, card.flag.filenameIsDir ? ICON_Folder : ICON_File, str);
+}
+
+#if ENABLED(SCROLL_LONG_FILENAMES)
+
+  void Draw_SDItem_Shifted(uint8_t &shift) {
+    // Limit to the number of chars past the cutoff
+    const size_t len = strlen(shift_name);
+    NOMORE(shift, _MAX(len - MENU_CHAR_LIMIT, 0U));
+
+    // Shorten to the available space
+    const size_t lastchar = _MIN((signed)len, shift + MENU_CHAR_LIMIT);
+
+    const char c = shift_name[lastchar];
+    shift_name[lastchar] = '\0';
+
+    const uint8_t row = select_file.now + MROWS - index_file; // skip "Back" and scroll
+    Erase_Menu_Text(row);
+    Draw_Menu_Line(row, 0, &shift_name[shift]);
+
+    shift_name[lastchar] = c;
+  }
+
+#endif
+
+// Redraw the first set of SD Files
+void Redraw_SD_List() {
+  select_file.reset();
+  index_file = MROWS;
+
+  DWINUI::ClearMenuArea(); // Leave title bar unchanged
+
+  Draw_Back_First();
+
+  if (card.isMounted()) {
+    // As many files as will fit
+    LOOP_L_N(i, _MIN(nr_sd_menu_items(), MROWS))
+      Draw_SDItem(i, i + 1);
+
+    TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
+  }
+  else {
+    DWIN_Draw_Rectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    DWINUI::Draw_CenteredString(font16x32, HMI_data.AlertTxt_Color, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
+  }
+}
+
+bool DWIN_lcd_sd_status = false;
+
+void SDCard_Up() {
+  card.cdup();
+  Redraw_SD_List();
+  DWIN_lcd_sd_status = false; // On next DWIN_Update
+}
+
+void SDCard_Folder(char * const dirname) {
+  card.cd(dirname);
+  Redraw_SD_List();
+  DWIN_lcd_sd_status = false; // On next DWIN_Update
+}
+
+//
+// Watch for media mount / unmount
+//
+void HMI_SDCardUpdate() {
+  if (HMI_flag.home_flag) return;
+  if (DWIN_lcd_sd_status != card.isMounted()) {
+    DWIN_lcd_sd_status = card.isMounted();
+    //SERIAL_ECHOLNPGM("HMI_SDCardUpdate: ", DWIN_lcd_sd_status);
+    if (DWIN_lcd_sd_status) {  // Media inserted
+      if (checkkey == SelectFile)
+        Redraw_SD_List();
+    }
+    else {    // Media removed
+      // clean file icon
+      if (checkkey == SelectFile) {
+        Redraw_SD_List();
+      }
+      else if (sdprint && card.isPrinting() && printingIsActive()) {
+        // TODO: Move card removed abort handling
+        //       to CardReader::manage_media.
+        card.abortFilePrintSoon();
+        wait_for_heatup = wait_for_user = false;
+        dwin_abort_flag = true; // Reset feedrate, return to Home
+      }
+    }
+    DWIN_UpdateLCD();
+  }
+}
+
+//
+// The status area is always on-screen, except during
+// full-screen modal dialogs. (TODO: Keep alive during dialogs)
+//
+void Draw_Status_Area(const bool with_update) {
+
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
+
+  #if HAS_HOTEND
+    DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
+    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
+
+    DWINUI::Draw_Icon(ICON_StepE, 112, 417);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+  #endif
+
+  #if HAS_HEATED_BED
+    DWINUI::Draw_Icon(ICON_BedTemp, 10, 416);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, thermalManager.wholeDegBed());
+    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+    DWINUI::Draw_Int(true, true, 0, DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
+  #endif
+
+  DWINUI::Draw_Icon(ICON_Speed, 113, 383);
+  DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+  DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+
+  #if HAS_FAN
+    DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+  #endif
+
+  #if HAS_ZOFFSET_ITEM
+    DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
+  #endif
+
+  DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 210, 417, BABY_Z_VAR);
+
+  DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
+
+  DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
+  DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
+  DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
+  _draw_xyz_position(true);
+
+  if (with_update) {
+    DWIN_UpdateLCD();
+    delay(5);
+  }
+}
+
+void HMI_StartFrame(const bool with_update) {
+  Goto_Main_Menu();
+  DWIN_DrawStatusLine(nullptr);
+  Draw_Status_Area(with_update);
+}
+
+void Draw_Info_Menu() {
+  DWINUI::ClearMenuArea();
+  Draw_Back_First();
+
+  DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
+  DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
+
+  if (HMI_IsChinese()) {
+    Title.FrameCopy(30, 17, 28, 13);                        // "Info"
+
+    DWIN_Frame_AreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
+    DWIN_Frame_AreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
+    DWIN_Frame_AreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
+  }
+  else {
+    Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
+
+    DWIN_Frame_AreaCopy(1, 120, 150, 146, 161, 124, 102);   // "Size"
+    DWIN_Frame_AreaCopy(1, 146, 151, 254, 161,  82, 175);   // "Firmware Version"
+    DWIN_Frame_AreaCopy(1,   1, 164,  96, 175,  89, 248);   // "Contact details"
+  }
+  DWINUI::Draw_CenteredString(268, F(CORP_WEBSITE));
+
+  LOOP_L_N(i, 3) {
+    DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
+    DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
+  }
+
+  DWIN_UpdateLCD();
+}
+
+void Draw_Print_File_Menu() {
+  if (HMI_IsChinese())
+    Title.FrameCopy(0, 31, 56, 14);    // "Print file"
+  else
+    Title.ShowCaption(GET_TEXT_F(MSG_MEDIA_MENU));
+  Redraw_SD_List();
+}
+
+// Main Process
+void HMI_MainMenu() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+
+  if (encoder_diffState == ENCODER_DIFF_CW) {
+    if (select_page.inc(PAGE_COUNT)) {
+      switch (select_page.now) {
+        case PAGE_PRINT: ICON_Print(); break;
+        case PAGE_PREPARE: ICON_Print(); ICON_Prepare(); break;
+        case PAGE_CONTROL: ICON_Prepare(); ICON_Control(); break;
+        case PAGE_INFO_LEVELING: ICON_Control(); TERN(HAS_ONESTEP_LEVELING, ICON_Leveling, ICON_StartInfo)(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW) {
+    if (select_page.dec()) {
+      switch (select_page.now) {
+        case PAGE_PRINT: ICON_Print(); ICON_Prepare(); break;
+        case PAGE_PREPARE: ICON_Prepare(); ICON_Control(); break;
+        case PAGE_CONTROL: ICON_Control(); TERN(HAS_ONESTEP_LEVELING, ICON_Leveling, ICON_StartInfo)(); break;
+        case PAGE_INFO_LEVELING: TERN(HAS_ONESTEP_LEVELING, ICON_Leveling, ICON_StartInfo)(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (select_page.now) {
+      case PAGE_PRINT:
+        checkkey = SelectFile;
+        Draw_Print_File_Menu();
+        break;
+
+      case PAGE_PREPARE: Draw_Prepare_Menu(); break;
+
+      case PAGE_CONTROL: Draw_Control_Menu(); break;
+
+      case PAGE_INFO_LEVELING:
+        #if HAS_ONESTEP_LEVELING
+          queue.inject(F("G28Z\nG29"));  // Force to get the current Z home position
+        #else
+          last_checkkey = MainMenu;
+          Goto_Info_Menu();
+        #endif
+        break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+// Select (and Print) File
+void HMI_SelectFile() {
+  EncoderState encoder_diffState = get_encoder_state();
+
+  const uint16_t hasUpDir = !card.flag.workDirIsRoot;
+
+  if (encoder_diffState == ENCODER_DIFF_NO) {
+    #if ENABLED(SCROLL_LONG_FILENAMES)
+      if (shift_ms && select_file.now >= 1 + hasUpDir) {
+        // Scroll selected filename every second
+        const millis_t ms = millis();
+        if (ELAPSED(ms, shift_ms)) {
+          const bool was_reset = shift_amt < 0;
+          shift_ms = ms + 375UL + was_reset * 250UL;  // ms per character
+          uint8_t shift_new = shift_amt + 1;          // Try to shift by...
+          Draw_SDItem_Shifted(shift_new);             // Draw the item
+          if (!was_reset && shift_new == 0)           // Was it limited to 0?
+            shift_ms = 0;                             // No scrolling needed
+          else if (shift_new == shift_amt)            // Scroll reached the end
+            shift_new = -1;                           // Reset
+          shift_amt = shift_new;                      // Set new scroll
+        }
+      }
+    #endif
+    return;
+  }
+
+  // First pause is long. Easy.
+  // On reset, long pause must be after 0.
+
+  const uint16_t fullCnt = nr_sd_menu_items();
+
+  if (encoder_diffState == ENCODER_DIFF_CW && fullCnt) {
+    if (select_file.inc(1 + fullCnt)) {
+      const uint8_t itemnum = select_file.now - 1;              // -1 for "Back"
+      if (TERN0(SCROLL_LONG_FILENAMES, shift_ms)) {             // If line was shifted
+        Erase_Menu_Text(itemnum + MROWS - index_file);          // Erase and
+        Draw_SDItem(itemnum - 1);                               // redraw
+      }
+      if (select_file.now > MROWS && select_file.now > index_file) { // Cursor past the bottom
+        index_file = select_file.now;                           // New bottom line
+        Scroll_Menu(DWIN_SCROLL_UP);
+        Draw_SDItem(itemnum, MROWS);                            // Draw and init the shift name
+      }
+      else {
+        Move_Highlight(1, select_file.now + MROWS - index_file); // Just move highlight
+        TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());         // ...and init the shift name
+      }
+      TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && fullCnt) {
+    if (select_file.dec()) {
+      const uint8_t itemnum = select_file.now - 1;              // -1 for "Back"
+      if (TERN0(SCROLL_LONG_FILENAMES, shift_ms)) {             // If line was shifted
+        Erase_Menu_Text(select_file.now + 1 + MROWS - index_file); // Erase and
+        Draw_SDItem(itemnum + 1);                               // redraw
+      }
+      if (select_file.now < index_file - MROWS) {               // Cursor past the top
+        index_file--;                                           // New bottom line
+        Scroll_Menu(DWIN_SCROLL_DOWN);
+        if (index_file == MROWS) {
+          Draw_Back_First();
+          TERN_(SCROLL_LONG_FILENAMES, shift_ms = 0);
+        }
+        else {
+          Draw_SDItem(itemnum, 0);                              // Draw the item (and init shift name)
+        }
+      }
+      else {
+        Move_Highlight(-1, select_file.now + MROWS - index_file); // Just move highlight
+        TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());        // ...and init the shift name
+      }
+      TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());        // Reset left. Init timer.
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    if (select_file.now == 0) { // Back
+      select_page.set(PAGE_PRINT);
+      Goto_Main_Menu();
+    }
+    else if (hasUpDir && select_file.now == 1) { // CD-Up
+      SDCard_Up();
+      goto HMI_SelectFileExit;
+    }
+    else {
+      const uint16_t filenum = select_file.now - 1 - hasUpDir;
+      card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
+
+      // Enter that folder!
+      if (card.flag.filenameIsDir) {
+        SDCard_Folder(card.filename);
+        goto HMI_SelectFileExit;
+      }
+
+      // Reset highlight for next entry
+      select_print.reset();
+      select_file.reset();
+
+      // Start choice and print SD file
+      HMI_flag.heat_flag = true;
+      HMI_flag.print_finish = false;
+
+      card.openAndPrintFile(card.filename);
+
+      #if HAS_FAN
+        // All fans on for Ender 3 v2 ?
+        // The slicer should manage this for us.
+        //for (uint8_t i = 0; i < FAN_COUNT; i++)
+        //  thermalManager.fan_speed[i] = 255;
+      #endif
+
+      DWIN_Print_Started(true);
+    }
+  }
+
+  HMI_SelectFileExit:
+  DWIN_UpdateLCD();
+}
+
+// Printing
+void HMI_Printing() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  // Avoid flicker by updating only the previous menu
+  if (encoder_diffState == ENCODER_DIFF_CW) {
+    if (select_print.inc(PRINT_COUNT)) {
+      switch (select_print.now) {
+        case PRINT_SETUP: ICON_Tune(); break;
+        case PRINT_PAUSE_RESUME: ICON_Tune(); ICON_ResumeOrPause(); break;
+        case PRINT_STOP: ICON_ResumeOrPause(); ICON_Stop(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW) {
+    if (select_print.dec()) {
+      switch (select_print.now) {
+        case PRINT_SETUP: ICON_Tune(); ICON_ResumeOrPause(); break;
+        case PRINT_PAUSE_RESUME: ICON_ResumeOrPause(); ICON_Stop(); break;
+        case PRINT_STOP: ICON_Stop(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (select_print.now) {
+      case PRINT_SETUP: Draw_Tune_Menu(); break;
+      case PRINT_PAUSE_RESUME:
+        if (HMI_flag.pause_flag) {
+          ICON_Pause();
+          #if DISABLED(ADVANCED_PAUSE_FEATURE)
+            char cmd[40];
+            cmd[0] = '\0';
+            #if BOTH(HAS_HEATED_BED, PAUSE_HEAT)
+              if (resume_bed_temp) sprintf_P(cmd, PSTR("M190 S%i\n"), resume_bed_temp);
+            #endif
+            #if BOTH(HAS_HOTEND, PAUSE_HEAT)
+              if (resume_hotend_temp) sprintf_P(&cmd[strlen(cmd)], PSTR("M109 S%i\n"), resume_hotend_temp);
+            #endif
+            #if HAS_FAN
+              if (resume_fan) thermalManager.fan_speed[0] = resume_fan;
+            #endif
+            strcat_P(cmd, M24_STR);
+            queue.inject(cmd);
+          #endif
+        }
+        else {
+          HMI_flag.select_flag = true;
+          checkkey = PauseOrStop;
+          Popup_window_PauseOrStop();
+        }
+        break;
+
+      case PRINT_STOP:
+        HMI_flag.select_flag = true;
+        checkkey = PauseOrStop;
+        Popup_window_PauseOrStop();
+        break;
+
+      default: break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+// Print done
+void HMI_PrintDone() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    dwin_abort_flag = true; // Reset feedrate, return to Home
+    Goto_Main_Menu(); // Return to Main menu after print done
+  }
+}
+
+// Pause or Stop popup
+void HMI_PauseOrStop() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    Draw_Select_Highlight(false);
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    Draw_Select_Highlight(true);
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    if (select_print.now == PRINT_PAUSE_RESUME) {
+      if (HMI_flag.select_flag) {
+        HMI_flag.pause_action = true;
+        ICON_Resume();
+        queue.inject(F("M25"));
+      }
+      else {
+        // cancel pause
+      }
+      Goto_PrintProcess();
+    }
+    else if (select_print.now == PRINT_STOP) {
+      if (HMI_flag.select_flag) {
+        checkkey = MainMenu;
+        if (HMI_flag.home_flag) planner.synchronize(); // Wait for planner moves to finish!
+        wait_for_heatup = wait_for_user = false;       // Stop waiting for heating/user
+        card.abortFilePrintSoon();                     // Let the main loop handle SD abort
+        dwin_abort_flag = true;                        // Reset feedrate, return to Home
+        #ifdef ACTION_ON_CANCEL
+          hostui.cancel();
+        #endif
+        DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_STOPPING), GET_TEXT_F(MSG_PLEASE_WAIT));
+      }
+      else
+        Goto_PrintProcess(); // cancel stop
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+#include "../../../libs/buzzer.h"
+
+void HMI_AudioFeedback(const bool success/*=true*/) {
+  #if HAS_BUZZER
+    if (success) {
+      BUZZ(100, 659);
+      BUZZ(10, 0);
+      BUZZ(100, 698);
+    }
+    else
+      BUZZ(40, 440);
+  #endif
+}
+
+void Draw_Main_Area() {
+  switch (checkkey) {
+    case MainMenu:               Draw_Main_Menu(); break;
+    case SelectFile:             Draw_Print_File_Menu(); break;
+    case PrintProcess:           Draw_PrintProcess(); break;
+    case PrintDone:              Draw_PrintDone(); break;
+    case Info:                   Draw_Info_Menu(); break;
+    #if HAS_ESDIAG
+      case ESDiagProcess:        Draw_EndStopDiag(); break;
+    #endif
+    #if ENABLED(PRINTCOUNTER)
+      case PrintStatsProcess:    Draw_PrintStats(); break;
+    #endif
+    case PauseOrStop:            Popup_window_PauseOrStop(); break;
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      case FilamentPurge:        Draw_Popup_FilamentPurge(); break;
+    #endif
+    case Locked:                 lockScreen.draw(); break;
+    case Menu:
+    case SetInt:
+    case SetPInt:
+    case SetIntNoDraw:
+    case SetFloat:
+    case SetPFloat:              CurrentMenu->draw(); break;
+    default: break;
+  }
+}
+
+void HMI_ReturnScreen() {
+  checkkey = last_checkkey;
+  wait_for_user = false;
+  Draw_Main_Area();
+  return;
+}
+
+void HMI_Popup() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    HMI_ReturnScreen();
+  }
+}
+
+void HMI_Init() {
+  HMI_SDCardInit();
+
+  for (uint16_t t = 0; t <= 100; t += 2) {
+    DWINUI::Draw_Icon(ICON_Bar, 15, 260);
+    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 15 + t * 242 / 100, 260, 257, 280);
+    DWIN_UpdateLCD();
+    delay(20);
+  }
+
+  HMI_SetLanguage();
+}
+
+void DWIN_Update() {
+  EachMomentUpdate();   // Status update
+  HMI_SDCardUpdate();   // SD card update
+  DWIN_HandleScreen();  // Rotary encoder update
+}
+
+void EachMomentUpdate() {
+  static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
+
+  const millis_t ms = millis();
+  if (ELAPSED(ms, next_var_update_ms)) {
+    next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
+    update_variable();
+    switch (checkkey) {
+      #if HAS_ESDIAG
+        case ESDiagProcess:
+          ESDiag.Update();
+          break;
+      #endif
+      default:
+        break;
+    }
+  }
+
+  if (ELAPSED(ms, next_status_update_ms)) {
+    next_status_update_ms = ms + 500;
+    DWIN_DrawStatusMessage();
+  }
+
+  if (PENDING(ms, next_rts_update_ms)) return;
+  next_rts_update_ms = ms + DWIN_SCROLL_UPDATE_INTERVAL;
+
+  if (checkkey == PrintProcess) {
+    // if print done
+    if (HMI_flag.print_finish) {
+      HMI_flag.print_finish = false;
+      TERN_(POWER_LOSS_RECOVERY, recovery.cancel());
+      planner.finish_and_disable();
+      checkkey = PrintDone;
+      Draw_PrintDone();
+    }
+    else if (HMI_flag.pause_flag != printingIsPaused()) {
+      // print status update
+      HMI_flag.pause_flag = printingIsPaused();
+      ICON_ResumeOrPause();
+    }
+  }
+
+  // pause after homing
+  if (HMI_flag.pause_action && printingIsPaused() && !planner.has_blocks_queued()) {
+    HMI_flag.pause_action = false;
+    #if ENABLED(PAUSE_HEAT)
+      TERN_(HAS_HOTEND, resume_hotend_temp = sdprint ? thermalManager.degTargetHotend(0) : thermalManager.wholeDegHotend(0));
+      TERN_(HAS_HEATED_BED, resume_bed_temp = sdprint ? thermalManager.degTargetBed() : thermalManager.wholeDegBed());
+      TERN_(HAS_FAN, resume_fan = thermalManager.fan_speed[0]);
+    #endif
+    IF_DISABLED(ADVANCED_PAUSE_FEATURE, thermalManager.disable_all_heaters());
+    IF_DISABLED(PARK_HEAD_ON_PAUSE, queue.inject(F("G1 F1200 X0 Y0")));
+  }
+
+  if (checkkey == PrintProcess) { // print process
+
+    duration_t elapsed = print_job_timer.duration(); // print timer
+
+    if (sdprint && card.isPrinting()) {
+      uint8_t percentDone = card.percentDone();
+      static uint8_t last_percentValue = 101;
+      if (last_percentValue != percentDone) { // print percent
+        last_percentValue = percentDone;
+        if (percentDone) {
+          _percent_done = percentDone;
+          Draw_Print_ProgressBar();
+        }
+      }
+
+      // Estimate remaining time every 20 seconds
+      static millis_t next_remain_time_update = 0;
+      if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag) {
+        _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
+        next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
+        Draw_Print_ProgressRemain();
+      }
+    }
+
+    // Print time so far
+    static uint16_t last_Printtime = 0;
+    const uint16_t min = (elapsed.value % 3600) / 60;
+    if (last_Printtime != min) { // 1 minute update
+      last_Printtime = min;
+      Draw_Print_ProgressElapsed();
+    }
+
+  }
+  else if (dwin_abort_flag && !HMI_flag.home_flag) { // Print Stop
+    dwin_abort_flag = false;
+    dwin_zoffset = BABY_Z_VAR;
+    select_page.set(PAGE_PRINT);
+    Goto_Main_Menu();
+  }
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
+      Goto_PowerLossRecovery();
+    }
+  #endif // POWER_LOSS_RECOVERY
+
+  DWIN_UpdateLCD();
+}
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void Popup_PowerLossRecovery() {
+    DWINUI::ClearMenuArea();
+    Draw_Popup_Bkgd();
+    if (HMI_IsChinese()) {
+      DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
+      DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
+      DWINUI::Draw_Icon(ICON_Cancel_C,    26, 280);
+      DWINUI::Draw_Icon(ICON_Continue_C, 146, 280);
+    }
+    else {
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
+      DWINUI::Draw_Icon(ICON_Cancel_E,    26, 280);
+      DWINUI::Draw_Icon(ICON_Continue_E, 146, 280);
+    }
+    SdFile *dir = nullptr;
+    const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
+    card.selectFileByName(filename);
+    DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
+    Draw_Select_Highlight(HMI_flag.select_flag);
+    DWIN_UpdateLCD();
+  }
+
+  void Goto_PowerLossRecovery() {
+    recovery.dwin_flag = false;
+    LCD_MESSAGE_F(GET_TEXT_F(MSG_CONTINUE_PRINT_JOB));
+    HMI_flag.select_flag = false;
+    Popup_PowerLossRecovery();
+    last_checkkey = MainMenu;
+    checkkey = PwrlossRec;
+  }
+
+  void HMI_PowerlossRecovery() {
+    EncoderState encoder_diffState = get_encoder_state();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    if (encoder_diffState == ENCODER_DIFF_ENTER) {
+      if (HMI_flag.select_flag) {
+        queue.inject(F("M1000C"));
+        select_page.reset();
+        Goto_Main_Menu();
+      }
+      else {
+        select_print.set(PRINT_SETUP);
+        queue.inject(F("M1000"));
+        sdprint = true;
+        Goto_PrintProcess();
+      }
+    }
+    else
+      Draw_Select_Highlight(encoder_diffState != ENCODER_DIFF_CW);
+    DWIN_UpdateLCD();
+  }
+#endif // POWER_LOSS_RECOVERY
+
+
+void DWIN_HandleScreen() {
+  switch (checkkey) {
+    case MainMenu:        HMI_MainMenu(); break;
+    case Menu:            HMI_Menu(); break;
+    case SetInt:          HMI_SetInt(); break;
+    case SetPInt:         HMI_SetPInt(); break;
+    case SetIntNoDraw:    HMI_SetIntNoDraw(); break;
+    case SetFloat:        HMI_SetFloat(); break;
+    case SetPFloat:       HMI_SetPFloat(); break;
+    case SelectFile:      HMI_SelectFile(); break;
+    case Homing:          break;
+    case Leveling:        break;
+    case PrintProcess:    HMI_Printing(); break;
+    case PrintDone:       HMI_PrintDone(); break;
+    case PauseOrStop:     HMI_PauseOrStop(); break;
+    case Info:            HMI_Popup(); break;
+    case WaitResponse:    HMI_Popup(); break;
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      case FilamentPurge: HMI_FilamentPurge(); break;
+    #endif
+    case NothingToDo:     break;
+    case Locked:          HMI_LockScreen(); break;
+    #if HAS_ESDIAG
+      case ESDiagProcess: HMI_Popup(); break;
+    #endif
+    #if ENABLED(PRINTCOUNTER)
+      case PrintStatsProcess: HMI_Popup(); break;
+    #endif
+    default: break;
+  }
+}
+
+bool IDisPopUp() {    // If ID is popup...
+  return  (checkkey == NothingToDo) ||
+          (checkkey == WaitResponse) ||
+          (checkkey == Info) ||
+          (checkkey == Homing) ||
+          (checkkey == Leveling) ||
+          TERN_(HAS_ESDIAG, (checkkey == ESDiagProcess) ||)
+          TERN_(PRINTCOUNTER, (checkkey == PrintStatsProcess) ||)
+          (checkkey == PauseOrStop) ||
+          (checkkey == FilamentPurge);
+}
+
+void HMI_SaveProcessID(const uint8_t id) {
+  if (checkkey != id) {
+    if (!IDisPopUp()) last_checkkey = checkkey; // if previous is not a popup
+    checkkey = id;
+  }
+}
+
+void DWIN_StartHoming() {
+  HMI_flag.home_flag = true;
+  HMI_SaveProcessID(Homing);
+  Title.ShowCaption(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
+  DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_LEVEL_BED_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+}
+
+void DWIN_CompletedHoming() {
+  HMI_flag.home_flag = false;
+  dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
+  if (dwin_abort_flag) {
+    planner.finish_and_disable();
+  }
+  HMI_ReturnScreen();
+}
+
+void DWIN_MeshLevelingStart() {
+  #if HAS_ONESTEP_LEVELING
+    HMI_SaveProcessID(Leveling);
+    Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
+    DWIN_Draw_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
+  #elif ENABLED(MESH_BED_LEVELING)
+    Draw_ManualMesh_Menu();
+  #endif
+}
+
+void DWIN_CompletedLeveling() { TERN_(HAS_MESH, DWIN_MeshViewer()); }
+
+#if HAS_MESH
+  void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const float zval) {
+    char msg[33] = "";
+    char str_1[6] = "";
+    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos,
+      dtostrf(zval, 1, 2, str_1));
+    ui.set_status(msg);
+  }
+#endif
+
+// PID process
+void DWIN_PidTuning(pidresult_t result) {
+  switch (result) {
+    case PID_BED_START:
+      HMI_SaveProcessID(NothingToDo);
+      DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+      break;
+    case PID_EXTR_START:
+      HMI_SaveProcessID(NothingToDo);
+      DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+      break;
+    case PID_BAD_EXTRUDER_NUM:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooLow, F("PID Autotune failed!"), F("Bad extruder"));
+      break;
+    case PID_TUNING_TIMEOUT:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooHigh, F("Error"), GET_TEXT_F(MSG_PID_TIMEOUT));
+      break;
+    case PID_TEMP_TOO_HIGH:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooHigh, F("PID Autotune failed!"), F("Temperature too high"));
+      break;
+    case PID_DONE:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
+      break;
+    default:
+      checkkey = last_checkkey;
+      break;
+  }
+}
+
+// Update filename on print
+void DWIN_Print_Header(const char *text = nullptr) {
+  static char headertxt[31] = "";  // Print header text
+
+  if (text) {
+    const int8_t size = _MIN((unsigned) 30, strlen_P(text));
+    LOOP_L_N(i, size) headertxt[i] = text[i];
+    headertxt[size] = '\0';
+  }
+  if (checkkey == PrintProcess || checkkey == PrintDone) {
+    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
+    DWINUI::Draw_CenteredString(60, headertxt);
+  }
+}
+
+void Draw_Title(TitleClass* title) {
+  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
+  if (title->frameid)
+    DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
+  else
+    DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_color, HMI_data.TitleBg_color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+}
+
+void Draw_Menu(MenuClass* menu) {
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  DWIN_Draw_Rectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
+  DWIN_ResetStatusLine();
+}
+
+// Startup routines
+void DWIN_Startup() {
+  DWINUI::init();
+  DWINUI::onCursorDraw = Draw_Menu_Cursor;
+  DWINUI::onCursorErase = Erase_Menu_Cursor;
+  DWINUI::onTitleDraw = Draw_Title;
+  DWINUI::onMenuDraw = Draw_Menu;
+  HMI_SetLanguage();
+}
+
+// Started a Print Job
+void DWIN_Print_Started(const bool sd) {
+  sdprint = card.isPrinting() || sd;
+  _percent_done = 0;
+  _remain_time = 0;
+  HMI_flag.print_finish = false;
+  Goto_PrintProcess();
+}
+
+// Ended print job
+void DWIN_Print_Finished() {
+  if (checkkey == PrintProcess || printingIsActive()) {
+    thermalManager.cooldown();
+    HMI_flag.print_finish = true;
+  }
+}
+
+// Progress Bar update
+void DWIN_Progress_Update() {
+  if (parser.seenval('P')) _percent_done = parser.byteval('P');
+  if (parser.seenval('R')) _remain_time = parser.ulongval('R') * 60;
+  if (checkkey == PrintProcess) {
+    Draw_Print_ProgressBar();
+    Draw_Print_ProgressRemain();
+    Draw_Print_ProgressElapsed();
+  }
+}
+
+#if HAS_FILAMENT_SENSOR
+  // Filament Runout process
+  void DWIN_FilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
+#endif
+
+void DWIN_SetColorDefaults() {
+  HMI_data.Background_Color = Def_Background_Color;
+  HMI_data.Cursor_color     = Def_Cursor_color;
+  HMI_data.TitleBg_color    = Def_TitleBg_color;
+  HMI_data.TitleTxt_color   = Def_TitleTxt_color;
+  HMI_data.Text_Color       = Def_Text_Color;
+  HMI_data.Selected_Color   = Def_Selected_Color;
+  HMI_data.SplitLine_Color  = Def_SplitLine_Color;
+  HMI_data.Highlight_Color  = Def_Highlight_Color;
+  HMI_data.StatusBg_Color   = Def_StatusBg_Color;
+  HMI_data.StatusTxt_Color  = Def_StatusTxt_Color;
+  HMI_data.PopupBg_color    = Def_PopupBg_color;
+  HMI_data.PopupTxt_Color   = Def_PopupTxt_Color;
+  HMI_data.AlertBg_Color    = Def_AlertBg_Color;
+  HMI_data.AlertTxt_Color   = Def_AlertTxt_Color;
+  HMI_data.PercentTxt_Color = Def_PercentTxt_Color;
+  HMI_data.Barfill_Color    = Def_Barfill_Color;
+  HMI_data.Indicator_Color  = Def_Indicator_Color;
+  HMI_data.Coordinate_Color = Def_Coordinate_Color;
+}
+
+void DWIN_SetDataDefaults() {
+  DWIN_SetColorDefaults();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  TERN_(HAS_HOTEND,             HMI_data.HotendPidT = PREHEAT_1_TEMP_HOTEND);
+  TERN_(HAS_HEATED_BED,         HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
+  TERN_(HAS_HOTEND,             HMI_data.PidCycles  = 5);
+  TERN_(PREVENT_COLD_EXTRUSION, HMI_data.ExtMinT    = EXTRUDE_MINTEMP);
+}
+
+void DWIN_StoreSettings(char *buff) {
+  memcpy(buff, &HMI_data, _MIN(sizeof(HMI_data), eeprom_data_size));
+}
+
+void DWIN_LoadSettings(const char *buff) {
+  memcpy(&HMI_data, buff, _MIN(sizeof(HMI_data), eeprom_data_size));
+  dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
+  if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
+  feedrate_percentage = 100;
+}
+
+void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
+  DWIN_Draw_Popup(ICON_BLTouch, lcd_error, lcd_component);
+  DWIN_UpdateLCD();
+}
+
+void DWIN_RebootScreen() {
+  DWIN_Frame_Clear(Color_Bg_Black);
+  DWIN_JPG_ShowAndCache(0);
+  DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
+  DWIN_UpdateLCD();
+  delay(500);
+}
+
+void DWIN_Redraw_screen() {
+  Draw_Main_Area();
+  Draw_Status_Area(false);
+}
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button = 0) {
+    HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
+    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
+    ui.reset_status(true);
+  }
+
+  void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
+    switch (message) {
+      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;
+      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;
+      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;
+      case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), ICON_Continue_E); break;
+      case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
+      case PAUSE_MESSAGE_LOAD:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
+      case PAUSE_MESSAGE_PURGE:    DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));  break;
+      case PAUSE_MESSAGE_OPTION:   DWIN_Popup_FilamentPurge(); break;
+      case PAUSE_MESSAGE_RESUME:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
+      case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), ICON_Continue_E);   break;
+      case PAUSE_MESSAGE_HEATING:  LCD_MESSAGE(MSG_FILAMENT_CHANGE_HEATING); break;
+      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;
+      default: break;
+    }
+  }
+
+  void Draw_Popup_FilamentPurge() {
+    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), F("Purge or Continue?"));
+    DWINUI::Draw_Icon(ICON_Confirm_E, 26, 280);
+    DWINUI::Draw_Icon(ICON_Continue_E, 146, 280);
+    Draw_Select_Highlight(true);
+    DWIN_UpdateLCD();
+  }
+
+  // Handle responses such as:
+  //  - Purge More, Continue
+  //  - General "Continue" response
+  void DWIN_Popup_FilamentPurge() {
+    HMI_SaveProcessID(FilamentPurge);
+    pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
+    Draw_Popup_FilamentPurge();
+  }
+
+  void HMI_FilamentPurge() {
+    EncoderState encoder_diffState = get_encoder_state();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    if (encoder_diffState == ENCODER_DIFF_CW)
+      Draw_Select_Highlight(false);
+    else if (encoder_diffState == ENCODER_DIFF_CCW)
+      Draw_Select_Highlight(true);
+    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+      if (HMI_flag.select_flag)
+        pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
+      else {
+        HMI_SaveProcessID(NothingToDo);
+        pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
+      }
+    }
+    DWIN_UpdateLCD();
+  }
+
+#endif // ADVANCED_PAUSE_FEATURE
+
+#if HAS_MESH
+  void DWIN_MeshViewer() {
+    if (!leveling_is_valid())
+      DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
+    else {
+      HMI_SaveProcessID(WaitResponse);
+      MeshViewer.Draw();
+    }
+  }
+#endif // HAS_MESH
+
+void DWIN_LockScreen() {
+  if (checkkey != Locked) {
+    lockScreen.rprocess = checkkey;
+    checkkey = Locked;
+    lockScreen.init();
+  }
+}
+
+void DWIN_UnLockScreen() {
+  if (checkkey == Locked) {
+    checkkey = lockScreen.rprocess;
+    Draw_Main_Area();
+  }
+}
+
+void HMI_LockScreen() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  lockScreen.onEncoder(encoder_diffState);
+  if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
+}
+
+#if HAS_ESDIAG
+  void Draw_EndStopDiag() {
+    HMI_SaveProcessID(ESDiagProcess);
+    ESDiag.Draw();
+  }
+#endif
+
+#if ENABLED(PRINTCOUNTER)
+  void Draw_PrintStats() {
+    HMI_SaveProcessID(PrintStatsProcess);
+    PrintStats.Draw();
+  }
+#endif
+
+//=============================================================================
+// NEW MENU SUBSYSTEM 
+//=============================================================================
+
+// On click functions
+
+// Generic onclick event without draw anything
+//  process: process id HMI destiny
+//  lo: low limit
+//  hi: high limit
+//  dp: decimal places, 0 for integers
+//  val: value / scaled value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  checkkey = process;
+  HMI_value.MinValue = lo;
+  HMI_value.MaxValue = hi;
+  HMI_value.dp = dp;
+  HMI_value.Apply = Apply;
+  HMI_value.LiveUpdate = LiveUpdate;
+  HMI_value.Value = val;
+  EncoderRate.enabled = true;
+}
+
+// Generic onclick event for integer values
+//  process: process id HMI destiny
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
+  Draw_Menu_IntValue(HMI_data.Selected_Color, CurrentMenu->line(), 4, HMI_value.Value);
+}
+
+// Generic onclick event for float values
+//  process: process id HMI destiny
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  const int32_t value =  round(val * POW(10, dp));
+  SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
+  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), val);
+}
+
+// Generic onclick event for integer values
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+inline void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  SetValueOnClick(SetInt, lo, hi, val, Apply, LiveUpdate);
+}
+
+// Generic onclick event for set pointer to 16 bit uinteger values
+//  lo: low limit
+//  hi: high limit
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  HMI_value.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  const int32_t value = *HMI_value.P_Int;
+  SetValueOnClick(SetPInt, lo, hi, value, Apply, LiveUpdate);
+}
+
+// Generic onclick event for float values
+//  process: process id HMI destiny
+//  lo: low limit
+//  hi: high limit
+//  dp: decimal places
+//  val: value
+inline void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  SetValueOnClick(SetFloat, lo, hi, dp, val, Apply, LiveUpdate);
+}
+
+// Generic onclick event for set pointer to float values
+//  lo: low limit
+//  hi: high limit
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  SetValueOnClick(SetPFloat, lo, hi, dp, *HMI_value.P_Float, Apply, LiveUpdate);
+}
+
+#if ENABLED(EEPROM_SETTINGS)
+  void WriteEeprom() {
+    const bool success = settings.save();
+    HMI_AudioFeedback(success);
+  }
+
+  void ReadEeprom() {
+    const bool success = settings.load();
+    DWIN_Redraw_screen();
+    HMI_AudioFeedback(success);
+  }
+
+  void ResetEeprom() {
+    settings.reset();
+    DWIN_Redraw_screen();
+    HMI_AudioFeedback();
+  }
+#endif
+
+// Reset Printer
+void RebootPrinter() {
+  dwin_abort_flag = true;
+  wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
+  thermalManager.disable_all_heaters();
+  planner.finish_and_disable();
+  DWIN_RebootScreen();
+  HAL_reboot();
+}
+
+void Goto_Info_Menu(){
+  HMI_SaveProcessID(Info);
+  Draw_Info_Menu();
+}
+
+void Goto_Move_Menu() {
+  #if HAS_HOTEND
+    gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
+    planner.synchronize();
+  #endif
+  Draw_Move_Menu();
+}
+
+void DisableMotors() { queue.inject(F("M84")); }
+
+void AutoLev() { queue.inject(F("G28Z\nG29")); }  // Force to get the current Z home position
+
+void AutoHome() { queue.inject_P(G28_STR); }
+
+void HomeX() { queue.inject(F("G28X")); }
+
+void HomeY() { queue.inject(F("G28Y")); }
+
+void HomeZ() { queue.inject(F("G28Z")); }
+
+void SetHome() {
+  // Apply workspace offset, making the current position 0,0,0
+  queue.inject(F("G92 X0 Y0 Z0"));
+  HMI_AudioFeedback();
+}
+
+#if HAS_ZOFFSET_ITEM
+  bool printer_busy() { return planner.movesplanned() || printingIsActive(); }
+  void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
+  void LiveZOffset() {
+    last_zoffset = dwin_zoffset;
+    dwin_zoffset = HMI_value.Value / 100.0f;
+    #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+      if (BABYSTEP_ALLOWED()) babystep.add_mm(Z_AXIS, dwin_zoffset - last_zoffset);
+    #endif
+  }
+  #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+    void SetZOffset() {
+      SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
+    }
+  #endif
+#endif
+
+#if HAS_PREHEAT
+  void DoPreheat0() { ui.preheat_all(0); }
+  void DoPreheat1() { ui.preheat_all(1); }
+  void DoPreheat2() { ui.preheat_all(2); }
+#endif
+
+void DoCoolDown() { thermalManager.cooldown(); }
+
+void SetLanguage() {
+  HMI_ToggleLanguage();
+  CurrentMenu = nullptr;  // Invalidate menu to full redraw
+  Draw_Prepare_Menu();
+}
+
+void LiveMove() {
+  *HMI_value.P_Float = HMI_value.Value / MINUNITMULT;
+  if (!planner.is_full()) {
+    planner.synchronize();
+    planner.buffer_line(current_position, homing_feedrate(HMI_value.axis));
+  }
+}
+void ApplyMoveE() {
+  last_E = HMI_value.Value / MINUNITMULT;
+  if (!planner.is_full()) {
+    planner.synchronize();
+    planner.buffer_line(current_position, MMM_TO_MMS(FEEDRATE_E));
+  }
+}
+void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+
+#if HAS_HOTEND
+  void SetMoveE() {
+    #if ENABLED(PREVENT_COLD_EXTRUSION)
+      if (thermalManager.tooColdToExtrude(0)) {
+        Popup_Window_ETempTooLow();
+        return;
+      }
+    #endif
+    SetPFloatOnClick(last_E - (EXTRUDE_MAXLENGTH), last_E + (EXTRUDE_MAXLENGTH), UNITFDIGITS, ApplyMoveE);
+  }
+#endif
+
+void SetMoveZto0() {
+  char cmd[48] = "";
+  char str_1[5] = "", str_2[5] = "";
+  sprintf_P(cmd, PSTR("G28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300"),
+    #if ENABLED(MESH_BED_LEVELING)
+      dtostrf(0, 1, 1, str_1),
+      dtostrf(0, 1, 1, str_2)
+    #else
+      dtostrf(X_CENTER, 1, 1, str_1),
+      dtostrf(Y_CENTER, 1, 1, str_2)
+    #endif
+  );
+  gcode.process_subcommands_now(cmd);
+  planner.synchronize();
+  LCD_MESSAGE_F("Now adjust Z Offset");
+  HMI_AudioFeedback(true);
+}
+
+void SetPID(celsius_t t, heater_id_t h) {
+  char cmd[48] = "";
+  char str_1[5] = "", str_2[5] = "";
+  sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84"),
+    dtostrf(X_CENTER, 1, 1, str_1),
+    dtostrf(Y_CENTER, 1, 1, str_2)
+  );
+  gcode.process_subcommands_now(cmd);
+  planner.synchronize();
+  thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
+}
+#if HAS_HOTEND
+  void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
+#endif
+#if HAS_HEATED_BED
+  void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void SetPwrLossr() {
+    recovery.enable(!recovery.enabled);
+    Draw_Chkb_Line(CurrentMenu->line(), recovery.enabled);
+    DWIN_UpdateLCD();
+  }
+#endif
+
+#if HAS_LCD_BRIGHTNESS
+  void LiveBrightness() { ui.set_brightness(HMI_value.Value); }
+  void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, nullptr, LiveBrightness); }
+#endif
+
+#if ENABLED(SOUND_MENU_ITEM)
+  void SetEnableSound() {
+    ui.buzzer_enabled = !ui.buzzer_enabled;
+    Draw_Chkb_Line(CurrentMenu->line(), ui.buzzer_enabled);
+    DWIN_UpdateLCD();
+  }
+#endif
+
+#if HAS_HOME_OFFSET
+  void ApplyHomeOffset() { set_home_offset(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+  void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
+  void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
+  void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
+#endif
+
+#if HAS_BED_PROBE
+  void SetProbeOffsetX() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
+  void SetProbeOffsetY() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
+  void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
+  void ProbeTest() {
+    LCD_MESSAGE(MSG_M48_TEST);
+    queue.inject(F("G28O\nM48 P10"));
+  }
+  void ProbeStow() { probe.stow(); }
+  void ProbeDeploy() { probe.deploy(); }
+
+  #ifdef BLTOUCH_HS_MODE
+    void SetHSMode() {
+      bltouch.high_speed_mode = !bltouch.high_speed_mode;
+      Draw_Chkb_Line(CurrentMenu->line(), bltouch.high_speed_mode);
+      DWIN_UpdateLCD();
+    }
+  #endif
+#endif
+
+#if HAS_FILAMENT_SENSOR
+  void SetRunoutEnable() {
+    runout.reset();
+    runout.enabled = !runout.enabled;
+    Draw_Chkb_Line(CurrentMenu->line(), runout.enabled);
+    DWIN_UpdateLCD();
+  }
+  #if HAS_FILAMENT_RUNOUT_DISTANCE
+    void ApplyRunoutDistance() { runout.set_runout_distance(HMI_value.Value / MINUNITMULT); }
+    void SetRunoutDistance() { SetFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), ApplyRunoutDistance); }
+  #endif
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+  void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+#endif
+
+#if ENABLED(PREVENT_COLD_EXTRUSION)
+  void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
+  void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
+#endif
+
+void RestoreDefaultsColors() {
+  DWIN_SetColorDefaults();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  DWIN_Redraw_screen();
+}
+
+void SelColor() {
+  HMI_value.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  HMI_value.Color[0] = GetRColor(*HMI_value.P_Int);  // Red
+  HMI_value.Color[1] = GetGColor(*HMI_value.P_Int);  // Green
+  HMI_value.Color[2] = GetBColor(*HMI_value.P_Int);  // Blue
+  Draw_GetColor_Menu();
+}
+
+void LiveRGBColor() {
+    HMI_value.Color[CurrentMenu->line() - 2] = HMI_value.Value;
+    uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+    DWIN_Draw_Rectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
+}
+void SetRGBColor() {
+  const uint8_t color = CurrentMenu->SelectedItem()->icon;
+  SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
+}
+
+void DWIN_ApplyColor() {
+  *HMI_value.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  Draw_Status_Area(false);
+  Draw_SelectColors_Menu();
+  LCD_MESSAGE_F(GET_TEXT_F(MSG_COLORS_APPLIED));
+}
+
+void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
+
+#if HAS_HOTEND
+  void ApplyHotendTemp() { thermalManager.setTargetHotend(HMI_value.Value, 0); }
+  void SetHotendTemp() { SetIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), ApplyHotendTemp); }
+#endif
+
+#if HAS_HEATED_BED
+  void ApplyBedTemp() { thermalManager.setTargetBed(HMI_value.Value); }
+  void SetBedTemp() { SetIntOnClick(BED_MINTEMP, BED_MAX_TARGET, thermalManager.degTargetBed(), ApplyBedTemp); }
+#endif
+
+#if HAS_FAN
+  void ApplyFanSpeed() { thermalManager.set_fan_speed(0, HMI_value.Value); }
+  void SetFanSpeed() { SetIntOnClick(0, 255, thermalManager.fan_speed[0], ApplyFanSpeed); }
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  void ChangeFilament() {
+    HMI_SaveProcessID(NothingToDo);
+    queue.inject(F("M600 B2"));
+  }
+
+  void ParkHead(){
+    LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
+    queue.inject(F("G28O\nG27"));
+  }
+
+  #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+    void UnloadFilament(){
+      LCD_MESSAGE(MSG_FILAMENTUNLOAD);
+      queue.inject(F("M702 Z20"));
+    }
+
+    void LoadFilament(){
+      LCD_MESSAGE(MSG_FILAMENTLOAD);
+      queue.inject(F("M701 Z20"));
+    }
+  #endif
+
+#endif // ADVANCED_PAUSE_FEATURE
+
+void ApplyFlow() { planner.refresh_e_factor(0); }
+void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, ApplyFlow); }
+
+// Bed Tramming
+void Tram(uint8_t point) {
+  char cmd[100] = "";
+  #if HAS_ONESTEP_LEVELING
+    static bool inLev = false;
+    if (inLev) return;
+    char str_1[6] = "", str_2[6] = "", str_3[6] = "";
+    float xpos = 0, ypos = 0, zval = 0;
+    float margin = PROBING_MARGIN;
+  #else
+    int16_t xpos = 0, ypos = 0;
+    int16_t margin = 30;
+  #endif
+
+  switch (point) {
+    case 0:
+      LCD_MESSAGE(MSG_LEVBED_FL);
+      xpos = ypos = margin;
+      break;
+    case 1:
+      LCD_MESSAGE(MSG_LEVBED_FR);
+      xpos = X_BED_SIZE - margin; ypos = margin;
+      break;
+    case 2:
+      LCD_MESSAGE(MSG_LEVBED_BR);
+      xpos = X_BED_SIZE - margin; ypos = Y_BED_SIZE - margin;
+      break;
+    case 3:
+      LCD_MESSAGE(MSG_LEVBED_BL);
+      xpos = margin; ypos = Y_BED_SIZE - margin;
+      break;
+    case 4:
+      LCD_MESSAGE(MSG_LEVBED_C);
+      xpos = X_BED_SIZE / 2; ypos = Y_BED_SIZE / 2;
+      break;
+  }
+
+  #if HAS_ONESTEP_LEVELING
+    planner.synchronize();
+    probe.stow();
+    gcode.process_subcommands_now(F("M420S0\nG28O"));
+    planner.synchronize();
+    inLev = true;
+    zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
+    sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
+      dtostrf(xpos, 1, 1, str_1),
+      dtostrf(ypos, 1, 1, str_2),
+      dtostrf(zval, 1, 2, str_3)
+    );
+    ui.set_status(cmd);
+    inLev = false;
+  #else
+    planner.synchronize();
+    sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%iY%iF5000\nG0Z0F300"), xpos, ypos);
+    queue.inject(cmd);
+  #endif
+}
+
+void TramFL() { Tram(0); }
+void TramFR() { Tram(1); }
+void TramBR() { Tram(2); }
+void TramBL() { Tram(3); }
+void TramC () { Tram(4); }
+
+#if ENABLED(MESH_BED_LEVELING)
+
+  void ManualMeshStart(){
+    LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
+    gcode.process_subcommands_now(F("G28Z\nM211S0\nG29S1"));
+    planner.synchronize();
+    #ifdef MANUAL_PROBE_START_Z
+      const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
+      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
+    #endif
+  }
+
+  void LiveMeshMoveZ() {
+    *HMI_value.P_Float = HMI_value.Value / POW(10, 2);
+    if (!planner.is_full()) {
+      planner.synchronize();
+      planner.buffer_line(current_position, homing_feedrate(Z_AXIS));
+    }
+  }
+  void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ);}
+
+  void ManualMeshContinue(){
+    gcode.process_subcommands_now(F("G29S2"));
+    planner.synchronize();
+    MMeshMoveZItem->draw(CurrentMenu->line(MMeshMoveZItem->pos));
+  }
+
+  void ManualMeshSave(){
+    LCD_MESSAGE(MSG_UBL_STORAGE_MESH_MENU);
+    queue.inject(F("M211S1\nM500"));
+  }
+
+#endif // MESH_BED_LEVELING
+
+#if HAS_PREHEAT
+  #if HAS_HOTEND
+    void SetPreheatEndTemp() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+  #endif
+  #if HAS_HEATED_BED
+    void SetPreheatBedTemp() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+  #endif
+  #if HAS_FAN
+    void SetPreheatFanSpeed() { SetPIntOnClick(0, 255); }
+  #endif
+#endif
+
+void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[X_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
+void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[Y_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
+void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[Z_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
+#if HAS_HOTEND
+  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[E_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
+#endif
+
+void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, HMI_value.Value); }
+void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[X_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
+void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[Y_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
+void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[Z_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
+#if HAS_HOTEND
+  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[E_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
+#endif
+
+#if HAS_CLASSIC_JERK
+  void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[X_AXIS] * 2, UNITFDIGITS, planner.max_jerk[X_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[Y_AXIS] * 2, UNITFDIGITS, planner.max_jerk[Y_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[Z_AXIS] * 2, UNITFDIGITS, planner.max_jerk[Z_AXIS], ApplyMaxJerk); }
+  #if HAS_HOTEND
+    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, default_max_jerk[E_AXIS] * 2, UNITFDIGITS, planner.max_jerk[E_AXIS], ApplyMaxJerk); }
+  #endif
+#endif
+
+void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+#if HAS_HOTEND
+  void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+  void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+#endif
+#if HAS_HEATED_BED
+  void SetBedPidT() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+#endif
+
+#if HAS_HOTEND || HAS_HEATED_BED
+  void SetPidCycles() { SetPIntOnClick(3, 50); }
+  void SetKp() { SetPFloatOnClick(0, 1000, 2); }
+  void ApplyPIDi() {
+    *HMI_value.P_Float = scalePID_i(HMI_value.Value / POW(10, 2));
+    thermalManager.updatePID();
+  }
+  void ApplyPIDd() {
+    *HMI_value.P_Float = scalePID_d(HMI_value.Value / POW(10, 2));
+    thermalManager.updatePID();
+  }
+  void SetKi() {
+    HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_i(*HMI_value.P_Float);
+    SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
+  }
+  void SetKd() {
+    HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_d(*HMI_value.P_Float);
+    SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
+  }
+#endif
+
+#if ENABLED(FWRETRACT)
+  void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); };
+  void SetRetractSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
+  void SetZRaise() { SetPFloatOnClick( 0, 2, 2); };
+  void SetRecoverSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
+#endif
+
+// Menuitem Drawing functions =================================================
+
+void onDrawMenuItem(MenuItemClass* menuitem, int8_t line) {
+  if (menuitem->icon) DWINUI::Draw_Icon(menuitem->icon, ICOX, MBASE(line) - 3);
+  if (menuitem->frameid)
+    DWIN_Frame_AreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
+  else if (menuitem->caption)
+    DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+void onDrawSubMenu(MenuItemClass* menuitem, int8_t line) {
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+}
+
+void onDrawIntMenu(MenuItemClass* menuitem, int8_t line, uint16_t value) {
+  onDrawMenuItem(menuitem, line);
+  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, value);
+}
+
+void onDrawPIntMenu(MenuItemClass* menuitem, int8_t line) {
+  const uint16_t value = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawPInt8Menu(MenuItemClass* menuitem, int8_t line) {
+  const uint8_t value = *(uint8_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawPInt32Menu(MenuItemClass* menuitem, int8_t line) {
+  const uint32_t value = *(uint32_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp, const float value) {
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
+}
+
+void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  const int8_t dp = UNITFDIGITS;
+  onDrawFloatMenu(menuitem, line, dp, value);
+}
+
+void onDrawPFloat2Menu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawFloatMenu(menuitem, line, 2, value);
+}
+
+void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
+  onDrawMenuItem(menuitem, line);
+  Draw_Chkb_Line(line, checked);
+}
+
+void onDrawBack(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 129, 72, 156, 84);
+  onDrawMenuItem(menuitem, line);
+}
+
+void onDrawTempSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1,  57, 104,  84, 116);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMotionSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1,  87, 104, 114, 116);
+  onDrawSubMenu(menuitem, line);
+}
+
+#if ENABLED(EEPROM_SETTINGS)
+  void onDrawWriteEeprom(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 117, 104, 172, 116);
+    onDrawMenuItem(menuitem, line);
+  }
+
+  void onDrawReadEeprom(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 103, 229, 116);
+    onDrawMenuItem(menuitem, line);
+  }
+
+  void onDrawResetEeprom(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1,   1, 118,  56, 131);
+    onDrawMenuItem(menuitem, line);
+  }
+#endif
+
+void onDrawInfoSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 231, 104, 258, 116);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMoveX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 118, 106, 132);
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMoveY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 109, 118, 157, 132);
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMoveZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 160, 118, 209, 132);
+  onDrawPFloatMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawMoveE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 212, 118, 253, 131);
+    onDrawPFloatMenu(menuitem, line);
+  }
+#endif
+
+void onDrawMoveSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 159, 70, 200, 84);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawDisableMotors(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 204, 70, 259, 82);
+  onDrawMenuItem(menuitem, line);
+}
+
+void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 0, 89, 41, 101);
+  onDrawMenuItem(menuitem, line);
+}
+
+#if HAS_ZOFFSET_ITEM
+  #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+    void onDrawZOffset(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 164, 223, 177);
+      onDrawPFloat2Menu(menuitem, line);
+    }
+  #else
+    void onDrawHomeOffset(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 43, 89, 98, 101);
+      onDrawMenuItem(menuitem, line);
+    }
+  #endif
+#endif
+
+#if HAS_HOTEND
+  void onDrawPreheat1(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 151, 101);
+    onDrawMenuItem(menuitem, line);
+  }
+  void onDrawPreheat2(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 233, 100);
+    onDrawMenuItem(menuitem, line);
+  }
+#endif
+
+#if HAS_PREHEAT
+  void onDrawCooldown(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 104,  56, 117);
+    onDrawMenuItem(menuitem, line);
+  }
+#endif
+
+void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 239, 134, 266, 146);
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_String(VALX, MBASE(line), HMI_IsChinese() ? F("CN") : F("EN"));
+}
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void onDrawPwrLossR(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, recovery.enabled); }
+#endif
+
+#if ENABLED(SOUND_MENU_ITEM)
+  void onDrawEnableSound(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, ui.buzzer_enabled); }
+#endif
+
+#ifdef BLTOUCH_HS_MODE
+  void onDrawHSMode(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, bltouch.high_speed_mode); }
+#endif
+
+void onDrawSelColorItem(MenuItemClass* menuitem, int8_t line) {
+  const uint16_t color = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
+  onDrawMenuItem(menuitem, line);
+}
+
+void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
+  const uint8_t i = menuitem->icon;
+  uint16_t color;
+  switch (i) {
+    case 0: color = RGB(31, 0, 0); break; // Red
+    case 1: color = RGB(0, 63, 0); break; // Green
+    case 2: color = RGB(0, 0, 31); break; // Blue
+    default: color = 0; break;
+  }
+  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
+  DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
+  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+#if HAS_FILAMENT_SENSOR
+  void onDrawRunoutEnable(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, runout.enabled); }
+#endif
+
+void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+
+void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
+  onDrawPIntMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawHotendTemp(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
+    onDrawPIntMenu(menuitem, line);
+  }
+#endif
+
+#if HAS_HEATED_BED
+  void onDrawBedTemp(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
+    onDrawPIntMenu(menuitem, line);
+  }
+#endif
+
+#if HAS_FAN
+  void onDrawFanSpeed(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
+    onDrawPInt8Menu(menuitem, line);
+  }
+#endif
+
+void onDrawSteps(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 153, 148, 194, 161);
+  onDrawSubMenu(menuitem, line);
+}
+
+#if ENABLED(MESH_BED_LEVELING)
+  void onDrawMMeshMoveZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 160, 118, 209, 132);
+    onDrawPFloat2Menu(menuitem, line);
+  }
+#endif
+
+#if HAS_PREHEAT
+  #if HAS_HOTEND
+    void onDrawSetPreheatHotend(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
+      onDrawPIntMenu(menuitem, line);
+    }
+  #endif
+  #if HAS_HEATED_BED
+    void onDrawSetPreheatBed(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
+      onDrawPIntMenu(menuitem, line);
+    }
+  #endif
+  #if HAS_FAN
+    void onDrawSetPreheatFan(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
+      onDrawPIntMenu(menuitem, line);
+    }
+  #endif
+  void onDrawPLAPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 178, 101);
+    onDrawSubMenu(menuitem,line);
+  }
+  void onDrawABSPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 260, 100);
+    onDrawSubMenu(menuitem,line);
+  }
+#endif // HAS_PREHEAT
+
+void onDrawSpeed(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese())
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 58, MBASE(line));      // X
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMaxSpeedY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+    DWIN_Frame_AreaCopy(1, 1, 150, 7, 160, LBLX + 58, MBASE(line));          // Y
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMaxSpeedZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+    DWIN_Frame_AreaCopy(1, 9, 150, 16, 160, LBLX + 58, MBASE(line) + 3);     // Z
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawMaxSpeedE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 228, 147);
+      DWIN_Frame_AreaCopy(1, 18, 150, 25, 160, LBLX + 58, MBASE(line));      // E
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+#endif
+
+void onDrawAcc(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1,  28, 149,  69, 161, LBLX + 27, MBASE(line) + 1); // ...Acceleration
+  }
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMaxAccelX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1, 28,  149,  69, 161, LBLX + 27, MBASE(line));
+    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 71, MBASE(line));      // X
+  }
+  onDrawPInt32Menu(menuitem, line);
+}
+
+void onDrawMaxAccelY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1,  28, 149,  69, 161, LBLX + 27, MBASE(line));
+    DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 71, MBASE(line));          // Y
+  }
+  onDrawPInt32Menu(menuitem, line);
+}
+
+void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1,  28, 149,  69, 161, LBLX + 27, MBASE(line));
+    DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 71, MBASE(line));         // Z
+  }
+  onDrawPInt32Menu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawMaxAccelE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,  28, 149,  69, 161, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 71, MBASE(line));        // E
+    }
+    onDrawPInt32Menu(menuitem, line);
+  }
+#endif
+
+#if HAS_CLASSIC_JERK
+
+  void onDrawJerk(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line) + 1);  // ...
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 54, MBASE(line));   // ...Jerk
+    }
+    onDrawSubMenu(menuitem, line);
+  }
+
+  void onDrawMaxJerkX(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 83, MBASE(line));
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+
+  void onDrawMaxJerkY(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+      DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 83, MBASE(line));
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+
+  void onDrawMaxJerkZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+      DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+
+  #if HAS_HOTEND
+    void onDrawMaxJerkE(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) {
+        menuitem->SetFrame(1, 173, 133, 200, 147);
+        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
+      }
+      onDrawPFloatMenu(menuitem, line);
+    }
+  #endif
+
+#endif // HAS_CLASSIC_JERK
+
+void onDrawStepsX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 153, 148, 194, 161);
+    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawStepsY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 153, 148, 194, 161);
+    DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 44, MBASE(line));      // Y
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 153, 148, 194, 161);
+    DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawStepsE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 153, 148, 194, 161);
+      DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+#endif
+
+// HMI Control functions ======================================================
+
+// Generic menu control using the encoder
+void HMI_Menu() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (CurrentMenu) {
+    if (encoder_diffState == ENCODER_DIFF_ENTER)
+      CurrentMenu->onClick();
+    else
+      CurrentMenu->onScroll(encoder_diffState == ENCODER_DIFF_CW);
+  }
+}
+
+// Get an integer value using the encoder without draw anything
+//  lo: low limit
+//  hi: high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
+      EncoderRate.enabled = false;
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(HMI_value.Value, lo, hi);
+    return 1;
+  }
+  return 0;
+}
+
+// Get an integer value using the encoder
+//  lo: low limit
+//  hi: high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetInt(const int32_t lo, const int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
+      EncoderRate.enabled = false;
+      DWINUI::Draw_Int(HMI_data.Text_Color, HMI_data.Background_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, HMI_value.Value);
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(HMI_value.Value, lo, hi);
+    DWINUI::Draw_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, HMI_value.Value);
+    return 1;
+  }
+  return 0;
+}
+
+// Set an integer using the encoder
+void HMI_SetInt() {
+  int8_t val = HMI_GetInt(HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return; break;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Set an integer without drawing
+void HMI_SetIntNoDraw() {
+  int8_t val = HMI_GetIntNoDraw(HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return; break;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Set an integer pointer variable using the encoder
+void HMI_SetPInt() {
+  int8_t val = HMI_GetInt(HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: *HMI_value.P_Int = HMI_value.Value; if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Get a scaled float value using the encoder
+//  dp: decimal places
+//  lo: scaled low limit
+//  hi: scaled high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetFloat(uint8_t dp, int32_t lo, int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
+      EncoderRate.enabled = false;
+      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), HMI_value.Value / POW(10, dp));
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(HMI_value.Value, lo, hi);
+    DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), HMI_value.Value / POW(10, dp));
+    return 1;
+  }
+  return 0;
+}
+
+// Set a scaled float using the encoder
+void HMI_SetFloat() {
+  const int8_t val = HMI_GetFloat(HMI_value.dp, HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Set a scaled float pointer variable using the encoder
+void HMI_SetPFloat() {
+  const int8_t val = HMI_GetFloat(HMI_value.dp, HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: *HMI_value.P_Float = HMI_value.Value / POW(10, HMI_value.dp); if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Menu Creation and Drawing functions ======================================================
+
+void SetMenuTitle(frame_rect_t cn, const __FlashStringHelper* fstr) {
+  if (HMI_IsChinese() && (cn.w != 0))
+    CurrentMenu->MenuTitle.SetFrame(cn.x, cn.y, cn.w, cn.h);
+  else
+    CurrentMenu->MenuTitle.SetCaption(fstr);
+}
+
+void Draw_Prepare_Menu() {
+  checkkey = Menu;
+  if (!PrepareMenu) PrepareMenu = new MenuClass();
+  if (CurrentMenu != PrepareMenu) {
+    CurrentMenu = PrepareMenu;
+    SetMenuTitle({133, 1, 28, 13}, GET_TEXT_F(MSG_PREPARE));
+    DWINUI::MenuItemsPrepare(13);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENT_MAN), onDrawSubMenu, Draw_FilamentMan_Menu);
+    #endif
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_MOVE_AXIS), onDrawMoveSubMenu, Goto_Move_Menu);
+    MENU_ITEM(ICON_Tram, GET_TEXT_F(MSG_BED_TRAMMING), onDrawSubMenu, Draw_Tramming_Menu);
+    MENU_ITEM(ICON_CloseMotor, GET_TEXT_F(MSG_DISABLE_STEPPERS), onDrawDisableMotors, DisableMotors);
+    #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_HOMING), onDrawSubMenu, Draw_Homing_Menu);
+    #else
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawAutoHome, AutoHome);
+    #endif
+    #if ENABLED(MESH_BED_LEVELING)
+      MENU_ITEM(ICON_ManualMesh, GET_TEXT_F(MSG_MANUAL_MESH), onDrawSubMenu, Draw_ManualMesh_Menu);
+    #endif
+    #if HAS_ZOFFSET_ITEM
+      #if HAS_BED_PROBE
+        MENU_ITEM(ICON_SetZOffset, GET_TEXT_F(MSG_PROBE_WIZARD), onDrawSubMenu, Draw_ZOffsetWiz_Menu);
+      #elif ENABLED(BABYSTEPPING)
+        EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      #else
+        MENU_ITEM(ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawHomeOffset, SetHome);
+      #endif
+    #endif
+    #if HAS_PREHEAT
+      MENU_ITEM(ICON_PLAPreheat, GET_TEXT_F(MSG_PREHEAT_1), onDrawPreheat1, DoPreheat0);
+      #if PREHEAT_COUNT > 1
+        MENU_ITEM(ICON_ABSPreheat, PSTR("Preheat " PREHEAT_2_LABEL), onDrawPreheat2, DoPreheat1);
+      #endif
+      #if PREHEAT_COUNT > 2
+        MENU_ITEM(ICON_CustomPreheat, GET_TEXT_F(MSG_PREHEAT_CUSTOM), onDrawMenuItem, DoPreheat2);
+      #endif
+    #endif
+    MENU_ITEM(ICON_Cool, GET_TEXT_F(MSG_COOLDOWN), onDrawCooldown, DoCoolDown);
+    MENU_ITEM(ICON_Language, PSTR(GET_TEXT_F(MSG_UI_LANGUAGE)), onDrawLanguage, SetLanguage);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Tramming_Menu() {
+  DWINUI::ClearMenuArea();
+  checkkey = Menu;
+  if (!TrammingMenu) TrammingMenu = new MenuClass();
+  if (CurrentMenu != TrammingMenu) {
+    CurrentMenu = TrammingMenu;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_BED_TRAMMING)); // TODO: Chinese, English "Bed Tramming" JPG
+    DWINUI::MenuItemsPrepare(6);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FL), onDrawMenuItem, TramFL);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FR), onDrawMenuItem, TramFR);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BR), onDrawMenuItem, TramBR);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BL), onDrawMenuItem, TramBL);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_C ), onDrawMenuItem, TramC );
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Control_Menu() {
+  checkkey = Menu;
+  if (!ControlMenu) ControlMenu = new MenuClass();
+  if (CurrentMenu != ControlMenu) {
+    CurrentMenu = ControlMenu;
+    SetMenuTitle({103, 1, 28, 14}, GET_TEXT_F(MSG_CONTROL));
+    DWINUI::MenuItemsPrepare(9);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    MENU_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawTempSubMenu, Draw_Temperature_Menu);
+    MENU_ITEM(ICON_Motion, GET_TEXT_F(MSG_MOTION), onDrawMotionSubMenu, Draw_Motion_Menu);
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
+      MENU_ITEM(ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM), onDrawReadEeprom, ReadEeprom);
+      MENU_ITEM(ICON_ResumeEEPROM, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawResetEeprom, ResetEeprom);
+    #endif
+    MENU_ITEM(ICON_Reboot, GET_TEXT_F(MSG_RESET_PRINTER), onDrawMenuItem, RebootPrinter);
+    MENU_ITEM(ICON_AdvSet, GET_TEXT_F(MSG_ADVANCED_SETTINGS), onDrawSubMenu, Draw_AdvancedSettings_Menu);
+    MENU_ITEM(ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN), onDrawInfoSubMenu, Goto_Info_Menu);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_AdvancedSettings_Menu() {
+  checkkey = Menu;
+  if (!AdvancedSettings) AdvancedSettings = new MenuClass();
+  if (CurrentMenu != AdvancedSettings) {
+    CurrentMenu = AdvancedSettings;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_ADVANCED_SETTINGS)); // TODO: Chinese, English "Advanced Settings" JPG
+    DWINUI::MenuItemsPrepare(15);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+    #if HAS_HOME_OFFSET
+      MENU_ITEM(ICON_HomeOffset, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawSubMenu, Draw_HomeOffset_Menu);
+    #endif
+    #if HAS_BED_PROBE
+      MENU_ITEM(ICON_ProbeSet, GET_TEXT_F(MSG_ZPROBE_SETTINGS), onDrawSubMenu, Draw_ProbeSet_Menu);
+    #endif
+    #if HAS_HOTEND
+      MENU_ITEM(ICON_PIDNozzle, F("Hotend PID Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
+    #endif
+    #if HAS_HEATED_BED
+      MENU_ITEM(ICON_PIDbed, F("Bed PID Settings"), onDrawSubMenu, Draw_BedPID_Menu);
+    #endif
+    #if HAS_FILAMENT_SENSOR
+      MENU_ITEM(ICON_FilSet, GET_TEXT_F(MSG_FILAMENT_SET), onDrawSubMenu, Draw_FilSet_Menu);
+    #endif
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      MENU_ITEM(ICON_Pwrlossr, GET_TEXT_F(MSG_OUTAGE_RECOVERY), onDrawPwrLossR, SetPwrLossr);
+    #endif
+    #if HAS_LCD_BRIGHTNESS
+      EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
+    #endif
+    MENU_ITEM(ICON_Scolor, GET_TEXT_F(MSG_COLORS_SELECT), onDrawSubMenu, Draw_SelectColors_Menu);
+    #if ENABLED(SOUND_MENU_ITEM)
+      MENU_ITEM(ICON_Sound, GET_TEXT_F(MSG_SOUND_ENABLE), onDrawEnableSound, SetEnableSound);
+    #endif
+    #if HAS_MESH
+      MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
+    #endif
+    #if HAS_ESDIAG
+      MENU_ITEM(ICON_ESDiag, F("End-stops diag."), onDrawSubMenu, Draw_EndStopDiag);
+    #endif
+    #if ENABLED(PRINTCOUNTER)
+      MENU_ITEM(ICON_PrintStats, GET_TEXT_F(MSG_INFO_STATS_MENU), onDrawSubMenu, Draw_PrintStats);
+      MENU_ITEM(ICON_PrintStatsReset, GET_TEXT_F(MSG_INFO_PRINT_COUNT_RESET), onDrawSubMenu, PrintStats.Reset);
+    #endif
+    MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Move_Menu() {
+  checkkey = Menu;
+  if (!MoveMenu) MoveMenu = new MenuClass();
+  if (CurrentMenu != MoveMenu) {
+    CurrentMenu = MoveMenu;
+    SetMenuTitle({192, 1, 42, 14}, GET_TEXT_F(MSG_MOVE_AXIS));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+    EDIT_ITEM(ICON_MoveX, GET_TEXT_F(MSG_MOVE_X), onDrawMoveX, SetMoveX, &current_position.x);
+    EDIT_ITEM(ICON_MoveY, GET_TEXT_F(MSG_MOVE_Y), onDrawMoveY, SetMoveY, &current_position.y);
+    EDIT_ITEM(ICON_MoveZ, GET_TEXT_F(MSG_MOVE_Z), onDrawMoveZ, SetMoveZ, &current_position.z);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_Extruder, GET_TEXT_F(MSG_MOVE_E), onDrawMoveE, SetMoveE, &current_position.e);
+    #endif
+  }
+  CurrentMenu->draw();
+  if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: current position is unknown, home axes");
+}
+
+#if HAS_HOME_OFFSET
+  void Draw_HomeOffset_Menu() {
+    checkkey = Menu;
+    if (!HomeOffMenu) HomeOffMenu = new MenuClass();
+    if (CurrentMenu != HomeOffMenu) {
+      CurrentMenu = HomeOffMenu;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_SET_HOME_OFFSETS)); // TODO: Chinese, English "Set Home Offsets" JPG
+      DWINUI::MenuItemsPrepare(4);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
+      EDIT_ITEM(ICON_HomeOffsetX, GET_TEXT_F(MSG_HOME_OFFSET_X), onDrawPFloatMenu, SetHomeOffsetX, &home_offset[X_AXIS]);
+      EDIT_ITEM(ICON_HomeOffsetY, GET_TEXT_F(MSG_HOME_OFFSET_Y), onDrawPFloatMenu, SetHomeOffsetY, &home_offset[Y_AXIS]);
+      EDIT_ITEM(ICON_HomeOffsetZ, GET_TEXT_F(MSG_HOME_OFFSET_Z), onDrawPFloatMenu, SetHomeOffsetZ, &home_offset[Z_AXIS]);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_BED_PROBE
+  void Draw_ProbeSet_Menu() {
+    checkkey = Menu;
+    if (!ProbeSetMenu) ProbeSetMenu = new MenuClass();
+    if (CurrentMenu != ProbeSetMenu) {
+      CurrentMenu = ProbeSetMenu;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_ZPROBE_SETTINGS)); // TODO: Chinese, English "Probe Settings" JPG
+      DWINUI::MenuItemsPrepare(8);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
+      EDIT_ITEM(ICON_ProbeOffsetX, GET_TEXT_F(MSG_ZPROBE_XOFFSET), onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
+      EDIT_ITEM(ICON_ProbeOffsetY, GET_TEXT_F(MSG_ZPROBE_YOFFSET), onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
+      EDIT_ITEM(ICON_ProbeOffsetZ, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+      #ifdef BLTOUCH_HS_MODE
+        MENU_ITEM(ICON_HSMode, F("Enable HS mode"), onDrawHSMode, SetHSMode);
+      #endif
+      MENU_ITEM(ICON_ProbeTest, GET_TEXT_F(MSG_M48_TEST), onDrawMenuItem, ProbeTest);
+      MENU_ITEM(ICON_ProbeStow, GET_TEXT_F(MSG_MANUAL_STOW), onDrawMenuItem, ProbeStow);
+      MENU_ITEM(ICON_ProbeDeploy, GET_TEXT_F(MSG_MANUAL_DEPLOY), onDrawMenuItem, ProbeDeploy);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_FILAMENT_SENSOR
+  void Draw_FilSet_Menu() {
+    checkkey = Menu;
+    if (!FilSetMenu) FilSetMenu = new MenuClass();
+    if (CurrentMenu != FilSetMenu) {
+      CurrentMenu = FilSetMenu;
+      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_FILAMENT_SET));
+      DWINUI::MenuItemsPrepare(10);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
+      #if HAS_FILAMENT_SENSOR
+        MENU_ITEM(ICON_Runout, GET_TEXT_F(MSG_RUNOUT_ENABLE), onDrawRunoutEnable, SetRunoutEnable);
+      #endif
+      #if HAS_FILAMENT_RUNOUT_DISTANCE
+        EDIT_ITEM(ICON_Runout, F("Runout Distance"), onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
+      #endif
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        EDIT_ITEM(ICON_ExtrudeMinT, F("Extrude Min Temp."), onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
+      #endif
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        EDIT_ITEM(ICON_FilLoad, GET_TEXT_F(MSG_FILAMENT_LOAD), onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
+        EDIT_ITEM(ICON_FilUnload, GET_TEXT_F(MSG_FILAMENT_UNLOAD), onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
+      #endif
+      #if ENABLED(FWRETRACT)
+        EDIT_ITEM(ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT), onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
+        EDIT_ITEM(ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED), onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+        EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
+        EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif // HAS_FILAMENT_SENSOR
+
+void Draw_SelectColors_Menu() {
+  checkkey = Menu;
+  if (!SelectColorMenu) SelectColorMenu = new MenuClass();
+  if (CurrentMenu != SelectColorMenu) {
+    CurrentMenu = SelectColorMenu;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_SELECT)); // TODO: Chinese, English "Select Color" JPG
+    DWINUI::MenuItemsPrepare(20);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
+    MENU_ITEM(ICON_StockConfiguration, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawMenuItem, RestoreDefaultsColors);
+    EDIT_ITEM(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
+    EDIT_ITEM(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_color);
+    EDIT_ITEM(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_color);
+    EDIT_ITEM(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_color);
+    EDIT_ITEM(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
+    EDIT_ITEM(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
+    EDIT_ITEM(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
+    EDIT_ITEM(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
+    EDIT_ITEM(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
+    EDIT_ITEM(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
+    EDIT_ITEM(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_color);
+    EDIT_ITEM(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
+    EDIT_ITEM(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
+    EDIT_ITEM(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
+    EDIT_ITEM(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
+    EDIT_ITEM(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
+    EDIT_ITEM(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
+    EDIT_ITEM(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_GetColor_Menu() {
+  checkkey = Menu;
+  if (!GetColorMenu) GetColorMenu = new MenuClass();
+  if (CurrentMenu != GetColorMenu) {
+    CurrentMenu = GetColorMenu;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_GET)); // TODO: Chinese, English "Get Color" JPG
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, DWIN_ApplyColor);
+    MENU_ITEM(ICON_Cancel, GET_TEXT_F(MSG_BUTTON_CANCEL), onDrawMenuItem, Draw_SelectColors_Menu);
+    MENU_ITEM(0, GET_TEXT_F(MSG_COLORS_RED), onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(1, GET_TEXT_F(MSG_COLORS_GREEN), onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(2, GET_TEXT_F(MSG_COLORS_BLUE), onDrawGetColorItem, SetRGBColor);
+  }
+  CurrentMenu->draw();
+  DWIN_Draw_Rectangle(1, *HMI_value.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
+}
+
+void Draw_Tune_Menu() {
+  checkkey = Menu;
+  if (!TuneMenu) TuneMenu = new MenuClass();
+  if (CurrentMenu != TuneMenu) {
+    CurrentMenu = TuneMenu;
+    SetMenuTitle({73, 2, 28, 12}, GET_TEXT_F(MSG_TUNE)); // TODO: Chinese, English "Tune" JPG
+    DWINUI::MenuItemsPrepare(14);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_PrintProcess);
+    EDIT_ITEM(ICON_Speed, GET_TEXT_F(MSG_SPEED), onDrawSpeedItem, SetSpeed, &feedrate_percentage);
+    #if HAS_HOTEND
+      HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+    #endif
+    #if HAS_HEATED_BED
+      BedTargetItem = EDIT_ITEM(ICON_BedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+    #endif
+    #if HAS_FAN
+      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+    #endif
+    #if HAS_ZOFFSET_ITEM && EITHER(HAS_BED_PROBE, BABYSTEPPING)
+      EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawZOffset, SetZOffset, &BABY_Z_VAR);
+    #endif
+    #if ENABLED(FWRETRACT)
+      EDIT_ITEM(ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT), onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
+      EDIT_ITEM(ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED), onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+      EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
+      EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+    #endif
+    EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
+    #endif
+    MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
+    #if HAS_LCD_BRIGHTNESS
+      EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Motion_Menu() {
+  checkkey = Menu;
+  if (!MotionMenu) MotionMenu = new MenuClass();
+  if (CurrentMenu != MotionMenu) {
+    CurrentMenu = MotionMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MOTION)); // TODO: Chinese, English "Motion" JPG
+    DWINUI::MenuItemsPrepare(6);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+    MENU_ITEM(ICON_MaxSpeed, GET_TEXT_F(MSG_SPEED), onDrawSpeed, Draw_MaxSpeed_Menu);
+    MENU_ITEM(ICON_MaxAccelerated, GET_TEXT_F(MSG_ACCELERATION), onDrawAcc, Draw_MaxAccel_Menu);
+    #if HAS_CLASSIC_JERK
+      MENU_ITEM(ICON_MaxJerk, GET_TEXT_F(MSG_JERK), onDrawJerk, Draw_MaxJerk_Menu);
+    #endif
+    MENU_ITEM(ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), onDrawSteps, Draw_Steps_Menu);
+    EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+  }
+  CurrentMenu->draw();
+}
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void Draw_FilamentMan_Menu() {
+    checkkey = Menu;
+    if (!FilamentMenu) FilamentMenu = new MenuClass();
+    if (CurrentMenu != FilamentMenu) {
+      CurrentMenu = FilamentMenu;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_FILAMENT_MAN)); // TODO: Chinese, English "Filament Management" JPG
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_Park, GET_TEXT_F(MSG_FILAMENT_PARK_ENABLED), onDrawMenuItem, ParkHead);
+      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
+      #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+        MENU_ITEM(ICON_FilUnload, GET_TEXT_F(MSG_FILAMENTUNLOAD), onDrawMenuItem, UnloadFilament);
+        MENU_ITEM(ICON_FilLoad, GET_TEXT_F(MSG_FILAMENTLOAD), onDrawMenuItem, LoadFilament);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if ENABLED(MESH_BED_LEVELING)
+  void Draw_ManualMesh_Menu() {
+    checkkey = Menu;
+    if (!ManualMesh) ManualMesh = new MenuClass();
+    if (CurrentMenu != ManualMesh) {
+      CurrentMenu = ManualMesh;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_MANUAL_MESH)); // TODO: Chinese, English "Manual Mesh Leveling" JPG
+      DWINUI::MenuItemsPrepare(6);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_ManualMesh, GET_TEXT_F(MSG_LEVEL_BED), onDrawMenuItem, ManualMeshStart);
+      MMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_MOVE_Z), onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
+      MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_UBL_CONTINUE_MESH), onDrawMenuItem, ManualMeshContinue);
+      MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
+      MENU_ITEM(ICON_MeshSave, GET_TEXT_F(MSG_UBL_SAVE_MESH), onDrawMenuItem, ManualMeshSave);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_PREHEAT
+
+  void Draw_Preheat_Menu(frame_rect_t cn, const __FlashStringHelper* fstr) {
+    checkkey = Menu;
+    if (CurrentMenu != PreheatMenu) {
+      CurrentMenu = PreheatMenu;
+      SetMenuTitle(cn, fstr);
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Temperature_Menu);
+      #if HAS_HOTEND
+        EDIT_ITEM(ICON_SetEndTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Preheat].hotend_temp);
+      #endif
+      #if HAS_HEATED_BED
+        EDIT_ITEM(ICON_SetBedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Preheat].bed_temp);
+      #endif
+      #if HAS_FAN
+        EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Preheat].fan_speed);
+      #endif
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+
+  void Draw_Preheat1_Menu() {
+    HMI_value.Preheat = 0;
+    if (!PreheatMenu) PreheatMenu = new MenuClass();
+    Draw_Preheat_Menu({59, 16, 81, 14}, F(PREHEAT_1_LABEL " Preheat Settings")); // TODO: English "PLA Settings" JPG
+  }
+
+  void Draw_Preheat2_Menu() {
+    HMI_value.Preheat = 1;
+    if (!PreheatMenu) PreheatMenu = new MenuClass();
+    Draw_Preheat_Menu({142, 16, 82, 14}, F(PREHEAT_2_LABEL " Preheat Settings"));  // TODO: English "ABS Settings" JPG
+  }
+
+  #ifdef PREHEAT_3_LABEL
+    void Draw_Preheat3_Menu() {
+      HMI_value.Preheat = 2;
+      if (!PreheatMenu) PreheatMenu = new MenuClass();
+      #define PREHEAT_3_TITLE PREHEAT_3_LABEL " Preheat Set."
+      Draw_Preheat_Menu({0}, F(PREHEAT_3_TITLE));  // TODO: Chinese, English "Custom Preheat Settings" JPG
+    }
+  #endif
+
+#endif // HAS_PREHEAT
+
+void Draw_Temperature_Menu() {
+  checkkey = Menu;
+  if (!TemperatureMenu) TemperatureMenu = new MenuClass();
+  if (CurrentMenu != TemperatureMenu) {
+    CurrentMenu = TemperatureMenu;
+    SetMenuTitle({236, 2, 28, 12}, GET_TEXT_F(MSG_TEMPERATURE));
+    DWINUI::MenuItemsPrepare(7);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+    #if HAS_HOTEND
+      HotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+    #endif
+    #if HAS_HEATED_BED
+      BedTargetItem = EDIT_ITEM(ICON_SetBedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+    #endif
+    #if HAS_FAN
+      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+    #endif
+    #if HAS_HOTEND
+      MENU_ITEM(ICON_SetPLAPreheat, F(PREHEAT_1_LABEL " Preheat Settings"), onDrawPLAPreheatSubMenu, Draw_Preheat1_Menu);
+      MENU_ITEM(ICON_SetABSPreheat, F(PREHEAT_2_LABEL " Preheat Settings"), onDrawABSPreheatSubMenu, Draw_Preheat2_Menu);
+      #ifdef PREHEAT_3_LABEL
+        MENU_ITEM(ICON_SetCustomPreheat, PREHEAT_3_TITLE, onDrawSubMenu, Draw_Preheat3_Menu);
+      #endif
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_MaxSpeed_Menu() {
+  checkkey = Menu;
+  if (!MaxSpeedMenu) MaxSpeedMenu = new MenuClass();
+  if (CurrentMenu != MaxSpeedMenu) {
+    CurrentMenu = MaxSpeedMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MAXSPEED));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+    EDIT_ITEM(ICON_MaxSpeedX, GET_TEXT_F(MSG_MAXSPEED_X), onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedY, GET_TEXT_F(MSG_MAXSPEED_Y), onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedZ, GET_TEXT_F(MSG_MAXSPEED_Z), onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_MaxSpeedE, GET_TEXT_F(MSG_MAXSPEED_E), onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_MaxAccel_Menu() {
+  checkkey = Menu;
+  if (!MaxAccelMenu) MaxAccelMenu = new MenuClass();
+  if (CurrentMenu != MaxAccelMenu) {
+    CurrentMenu = MaxAccelMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_ACCELERATION));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+    EDIT_ITEM(ICON_MaxAccX, GET_TEXT_F(MSG_AMAX_A), onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
+    EDIT_ITEM(ICON_MaxAccY, GET_TEXT_F(MSG_AMAX_B), onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+    EDIT_ITEM(ICON_MaxAccZ, GET_TEXT_F(MSG_AMAX_C), onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E), onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+#if HAS_CLASSIC_JERK
+  void Draw_MaxJerk_Menu() {
+    checkkey = Menu;
+    if (!MaxJerkMenu) MaxJerkMenu = new MenuClass();
+    if (CurrentMenu != MaxJerkMenu) {
+      CurrentMenu = MaxJerkMenu;
+      SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_JERK));
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+      EDIT_ITEM(ICON_MaxSpeedJerkX, GET_TEXT_F(MSG_VA_JERK), onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk[X_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedJerkY, GET_TEXT_F(MSG_VB_JERK), onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk[Y_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedJerkZ, GET_TEXT_F(MSG_VC_JERK), onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk[Z_AXIS]);
+      #if HAS_HOTEND
+        EDIT_ITEM(ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK), onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk[E_AXIS]);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+void Draw_Steps_Menu() {
+  checkkey = Menu;
+  if (!StepsMenu) StepsMenu = new MenuClass();
+  if (CurrentMenu != StepsMenu) {
+    CurrentMenu = StepsMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_STEPS_PER_MM));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+    EDIT_ITEM(ICON_StepX, GET_TEXT_F(MSG_A_STEPS), onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+    EDIT_ITEM(ICON_StepY, GET_TEXT_F(MSG_B_STEPS), onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+    EDIT_ITEM(ICON_StepZ, GET_TEXT_F(MSG_C_STEPS), onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_StepE, GET_TEXT_F(MSG_E_STEPS), onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+#if HAS_HOTEND
+  void Draw_HotendPID_Menu() {
+    checkkey = Menu;
+    if (!HotendPIDMenu) HotendPIDMenu = new MenuClass();
+    if (CurrentMenu != HotendPIDMenu) {
+      CurrentMenu = HotendPIDMenu;
+      CurrentMenu->MenuTitle.SetCaption(F("Hotend PID Settings"));
+      DWINUI::MenuItemsPrepare(8);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F("Hotend PID"), onDrawMenuItem, HotendPID);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
+      EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
+      EDIT_ITEM(ICON_PIDcycles, GET_TEXT_F(MSG_PID_CYCLE), onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_HEATED_BED
+  void Draw_BedPID_Menu() {
+    checkkey = Menu;
+    if (!BedPIDMenu) BedPIDMenu = new MenuClass();
+    if (CurrentMenu != BedPIDMenu) {
+      CurrentMenu = BedPIDMenu;
+      CurrentMenu->MenuTitle.SetCaption(F("Bed PID Settings"));
+      DWINUI::MenuItemsPrepare(8);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F("Bed PID"), onDrawMenuItem,BedPID);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
+      EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
+      EDIT_ITEM(ICON_PIDcycles, GET_TEXT_F(MSG_PID_CYCLE), onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_BED_PROBE
+  void Draw_ZOffsetWiz_Menu() {
+    checkkey = Menu;
+    if (!ZOffsetWizMenu) ZOffsetWizMenu = new MenuClass();
+    if (CurrentMenu != ZOffsetWizMenu) {
+      CurrentMenu = ZOffsetWizMenu;
+      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_PROBE_WIZARD));
+      DWINUI::MenuItemsPrepare(4);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
+      MENU_ITEM(ICON_MoveZ0, F("Move Z to Home"), onDrawMenuItem, SetMoveZto0);
+      EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+    }
+    CurrentMenu->draw();
+    if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
+  }
+#endif
+
+#if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  void Draw_Homing_Menu() {
+    checkkey = Menu;
+    if (!HomingMenu) HomingMenu = new MenuClass();
+    if (CurrentMenu != HomingMenu) {
+      CurrentMenu = HomingMenu;
+      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_HOMING));
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
+      MENU_ITEM(ICON_HomeX, GET_TEXT_F(MSG_AUTO_HOME_X), onDrawMenuItem, HomeX);
+      MENU_ITEM(ICON_HomeY, GET_TEXT_F(MSG_AUTO_HOME_Y), onDrawMenuItem, HomeY);
+      MENU_ITEM(ICON_HomeZ, GET_TEXT_F(MSG_AUTO_HOME_Z), onDrawMenuItem, HomeZ);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#endif // DWIN_CREALITY_LCD_ENHANCED
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin.h b/Marlin/src/lcd/e3v2/enhanced/dwin.h
new file mode 100644
index 0000000000..f377732b41
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin.h
@@ -0,0 +1,255 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.9.1
+ * Date: 2021/11/21
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+#include "dwinui.h"
+#include "../common/encoder.h"
+#include "../../../libs/BL24CXX.h"
+
+#if ANY(AUTO_BED_LEVELING_BILINEAR, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT) && DISABLED(PROBE_MANUALLY)
+  #define HAS_ONESTEP_LEVELING 1
+#endif
+
+#if !HAS_BED_PROBE && ENABLED(BABYSTEPPING)
+  #define JUST_BABYSTEP 1
+#endif
+
+#if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
+  #define HAS_ZOFFSET_ITEM 1
+#endif
+
+#include "dwin_defines.h"
+
+enum processID : uint8_t {
+  // Process ID
+  MainMenu,
+  Menu,
+  SetInt,
+  SetPInt,
+  SetIntNoDraw,
+  SetFloat,
+  SetPFloat,
+  SelectFile,
+  PrintProcess,
+  PrintDone,
+  PwrlossRec,
+  Reboot,
+  Info,
+
+  // Popup Windows
+  Homing,
+  Leveling,
+  PidProcess,
+  ESDiagProcess,
+  PrintStatsProcess,
+  PauseOrStop,
+  FilamentPurge,
+  WaitResponse,
+  Locked,
+  NothingToDo,
+};
+
+enum pidresult_t : uint8_t {
+  PID_BAD_EXTRUDER_NUM,
+  PID_TEMP_TOO_HIGH,
+  PID_TUNING_TIMEOUT,
+  PID_EXTR_START,
+  PID_BED_START,
+  PID_DONE
+};
+
+#define DWIN_CHINESE 123
+#define DWIN_ENGLISH 0
+
+typedef struct {
+  int8_t Color[3];                    // Color components
+  int8_t Preheat          = 0;        // Material Select 0: PLA, 1: ABS, 2: Custom
+  AxisEnum axis           = X_AXIS;   // Axis Select
+  int32_t MaxValue        = 0;        // Auxiliar max integer/scaled float value
+  int32_t MinValue        = 0;        // Auxiliar min integer/scaled float value
+  int8_t dp               = 0;        // Auxiliar decimal places
+  int32_t Value           = 0;        // Auxiliar integer / scaled float value
+  int16_t *P_Int          = nullptr;  // Auxiliar pointer to 16 bit integer variable
+  float *P_Float          = nullptr;  // Auxiliar pointer to float variable
+  void (*Apply)()         = nullptr;  // Auxiliar apply function
+  void (*LiveUpdate)()    = nullptr;  // Auxiliar live update function
+} HMI_value_t;
+
+typedef struct {
+  uint8_t language;
+  bool pause_flag:1;    // printing is paused
+  bool pause_action:1;  // flag a pause action
+  bool print_finish:1;  // print was finished
+  bool select_flag:1;   // Popup button selected
+  bool home_flag:1;     // homing in course
+  bool heat_flag:1;     // 0: heating done  1: during heating
+} HMI_flag_t;
+
+extern HMI_value_t HMI_value;
+extern HMI_flag_t HMI_flag;
+extern uint8_t checkkey;
+extern millis_t dwin_heat_time;
+
+// Popups
+#if HAS_HOTEND || HAS_HEATED_BED
+  void DWIN_Popup_Temperature(const bool toohigh);
+#endif
+#if HAS_HOTEND
+  void Popup_Window_ETempTooLow();
+#endif
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void Popup_PowerLossRecovery();
+#endif
+
+// SD Card
+void HMI_SDCardInit();
+void HMI_SDCardUpdate();
+
+// Other
+void Goto_PrintProcess();
+void Goto_Main_Menu();
+void Goto_Info_Menu();
+void Goto_PowerLossRecovery();
+void Draw_Status_Area(const bool with_update); // Status Area
+void Draw_Main_Area();      // Redraw main area;
+void DWIN_Redraw_screen();  // Redraw all screen elements
+void HMI_StartFrame(const bool with_update);   // Prepare the menu view
+void HMI_MainMenu();        // Main process screen
+void HMI_SelectFile();      // File page
+void HMI_Printing();        // Print page
+void HMI_ReturnScreen();    // Return to previous screen before popups
+void ApplyExtMinT();
+void HMI_SetLanguageCache(); // Set the languaje image cache
+
+void HMI_Init();
+void HMI_Popup();
+void HMI_SaveProcessID(const uint8_t id);
+void HMI_AudioFeedback(const bool success=true);
+void EachMomentUpdate();
+void update_variable();
+void DWIN_HandleScreen();
+void DWIN_Update();
+void DWIN_CheckStatusMessage();
+void DWIN_StartHoming();
+void DWIN_CompletedHoming();
+#if HAS_MESH
+  void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const float zval);
+#endif
+void DWIN_MeshLevelingStart();
+void DWIN_CompletedLeveling();
+void DWIN_PidTuning(pidresult_t result);
+void DWIN_Print_Started(const bool sd = false);
+void DWIN_Print_Finished();
+#if HAS_FILAMENT_SENSOR
+  void DWIN_FilamentRunout(const uint8_t extruder);
+#endif
+void DWIN_Progress_Update();
+void DWIN_Print_Header(const char *text);
+void DWIN_SetColorDefaults();
+void DWIN_StoreSettings(char *buff);
+void DWIN_LoadSettings(const char *buff);
+void DWIN_SetDataDefaults();
+void DWIN_RebootScreen();
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void Draw_Popup_FilamentPurge();
+  void DWIN_Popup_FilamentPurge();
+  void HMI_FilamentPurge();
+#endif
+
+// Utility and extensions
+void DWIN_LockScreen();
+void DWIN_UnLockScreen();
+void HMI_LockScreen();
+#if HAS_MESH
+  void DWIN_MeshViewer();
+#endif
+#if HAS_ESDIAG
+  void Draw_EndStopDiag();
+#endif
+#if ENABLED(PRINTCOUNTER)
+  void Draw_PrintStats();
+#endif
+
+// HMI user control functions
+void HMI_Menu();
+void HMI_SetInt();
+void HMI_SetPInt();
+void HMI_SetIntNoDraw();
+void HMI_SetFloat();
+void HMI_SetPFloat();
+
+// Menu drawing functions
+void Draw_Control_Menu();
+void Draw_AdvancedSettings_Menu();
+void Draw_Prepare_Menu();
+void Draw_Move_Menu();
+void Draw_Tramming_Menu();
+#if HAS_HOME_OFFSET
+  void Draw_HomeOffset_Menu();
+#endif
+#if HAS_BED_PROBE
+  void Draw_ProbeSet_Menu();
+#endif
+#if HAS_FILAMENT_SENSOR
+  void Draw_FilSet_Menu();
+#endif
+void Draw_SelectColors_Menu();
+void Draw_GetColor_Menu();
+void Draw_Tune_Menu();
+void Draw_Motion_Menu();
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void Draw_FilamentMan_Menu();
+#endif
+#if ENABLED(MESH_BED_LEVELING)
+  void Draw_ManualMesh_Menu();
+#endif
+#if HAS_HOTEND
+  void Draw_Preheat1_Menu();
+  void Draw_Preheat2_Menu();
+  void Draw_Preheat3_Menu();
+  void Draw_HotendPID_Menu();
+#endif
+void Draw_Temperature_Menu();
+void Draw_MaxSpeed_Menu();
+void Draw_MaxAccel_Menu();
+#if HAS_CLASSIC_JERK
+  void Draw_MaxJerk_Menu();
+#endif
+void Draw_Steps_Menu();
+#if HAS_HEATED_BED
+  void Draw_BedPID_Menu();
+#endif
+#if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+  void Draw_ZOffsetWiz_Menu();
+#endif
+#if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  void Draw_Homing_Menu();
+#endif
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin_defines.h b/Marlin/src/lcd/e3v2/enhanced/dwin_defines.h
new file mode 100644
index 0000000000..b92d3d3b85
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin_defines.h
@@ -0,0 +1,92 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN general defines and data structs
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.9.1
+ * Date: 2021/11/21
+ */
+
+#include "../../../core/types.h"
+#include "../common/dwin_color.h"
+
+#define Def_Background_Color  RGB( 1, 12,  8)
+#define Def_Cursor_color      RGB(20, 49, 31)
+#define Def_TitleBg_color     RGB( 0, 23, 16)
+#define Def_TitleTxt_color    Color_White
+#define Def_Text_Color        Color_White
+#define Def_Selected_Color    Select_Color
+#define Def_SplitLine_Color   RGB( 0, 23, 16)
+#define Def_Highlight_Color   Color_White
+#define Def_StatusBg_Color    RGB( 0, 23, 16)
+#define Def_StatusTxt_Color   Color_Yellow
+#define Def_PopupBg_color     Color_Bg_Window
+#define Def_PopupTxt_Color    Popup_Text_Color
+#define Def_AlertBg_Color     Color_Bg_Red
+#define Def_AlertTxt_Color    Color_Yellow
+#define Def_PercentTxt_Color  Percent_Color
+#define Def_Barfill_Color     BarFill_Color
+#define Def_Indicator_Color   Color_White
+#define Def_Coordinate_Color  Color_White
+
+#define HAS_ESDIAG 1
+#define DEFAULT_LCD_BRIGHTNESS 127
+
+typedef struct {
+// Color settings
+  uint16_t Background_Color = Def_Background_Color;
+  uint16_t Cursor_color     = Def_Cursor_color;
+  uint16_t TitleBg_color    = Def_TitleBg_color;
+  uint16_t TitleTxt_color   = Def_TitleTxt_color;
+  uint16_t Text_Color       = Def_Text_Color;
+  uint16_t Selected_Color   = Def_Selected_Color;
+  uint16_t SplitLine_Color  = Def_SplitLine_Color;
+  uint16_t Highlight_Color  = Def_Highlight_Color;
+  uint16_t StatusBg_Color   = Def_StatusBg_Color;
+  uint16_t StatusTxt_Color  = Def_StatusTxt_Color;
+  uint16_t PopupBg_color    = Def_PopupBg_color;
+  uint16_t PopupTxt_Color   = Def_PopupTxt_Color;
+  uint16_t AlertBg_Color    = Def_AlertBg_Color;
+  uint16_t AlertTxt_Color   = Def_AlertTxt_Color;
+  uint16_t PercentTxt_Color = Def_PercentTxt_Color;
+  uint16_t Barfill_Color    = Def_Barfill_Color;
+  uint16_t Indicator_Color  = Def_Indicator_Color;
+  uint16_t Coordinate_Color = Def_Coordinate_Color;
+//
+  #if defined(PREHEAT_1_TEMP_HOTEND) && HAS_HOTEND
+    int16_t HotendPidT = PREHEAT_1_TEMP_HOTEND;
+  #endif
+  #if defined(PREHEAT_1_TEMP_BED) && HAS_HEATED_BED
+    int16_t BedPidT = PREHEAT_1_TEMP_BED;
+  #endif
+  #if ANY(HAS_HOTEND, HAS_HEATED_BED)
+    int16_t PidCycles = 10;
+  #endif
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+    int16_t ExtMinT = EXTRUDE_MINTEMP;
+  #endif
+} HMI_data_t;
+
+static constexpr size_t eeprom_data_size = 64;
+extern HMI_data_t HMI_data;
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin_lcd.cpp b/Marlin/src/lcd/e3v2/enhanced/dwin_lcd.cpp
new file mode 100644
index 0000000000..83cbc20718
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin_lcd.cpp
@@ -0,0 +1,160 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/09
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+
+#include "../../../inc/MarlinConfig.h"
+
+#include "dwin_lcd.h"
+
+/*---------------------------------------- Picture related functions ----------------------------------------*/
+
+// Display QR code
+//  The size of the QR code is (46*QR_Pixel)*(46*QR_Pixel) dot matrix
+//  QR_Pixel: The pixel size occupied by each point of the QR code: 0x01-0x0F (1-16)
+//  (Nx, Ny): The coordinates of the upper left corner displayed by the QR code
+//  str: multi-bit data
+void DWIN_Draw_QR(uint8_t QR_Pixel, uint16_t x, uint16_t y, char *string) {
+  size_t i = 0;
+  DWIN_Byte(i, 0x21);
+  DWIN_Word(i, x);
+  DWIN_Word(i, y);
+  DWIN_Byte(i, QR_Pixel);
+  DWIN_Text(i, string);
+  DWIN_Send(i);
+}
+
+// Draw an Icon with transparent background
+//  libID: Icon library ID
+//  picID: Icon ID
+//  x/y: Upper-left point
+void DWIN_ICON_Show(uint8_t libID, uint8_t picID, uint16_t x, uint16_t y) {
+  DWIN_ICON_Show(false, false, true, libID, picID, x, y);
+}
+
+// Copy area from current virtual display area to current screen
+//  xStart/yStart: Upper-left of virtual area
+//  xEnd/yEnd: Lower-right of virtual area
+//  x/y: Screen paste point
+void DWIN_Frame_AreaCopy(uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd, uint16_t x, uint16_t y) {
+  size_t i = 0;
+  DWIN_Byte(i, 0x26);
+  DWIN_Word(i, xStart);
+  DWIN_Word(i, yStart);
+  DWIN_Word(i, xEnd);
+  DWIN_Word(i, yEnd);
+  DWIN_Word(i, x);
+  DWIN_Word(i, y);
+  DWIN_Send(i);
+}
+
+// Copy area from virtual display area to current screen
+//  IBD: background display: 0=Background filtering is not displayed, 1=Background display \\When setting the background filtering not to display, the background must be pure black
+//  BIR: Background image restoration: 0=Background image is not restored, 1=Automatically use virtual display area image for background restoration
+//  BFI: Background filtering strength: 0=normal, 1=enhanced, (only valid when the icon background display=0)
+//  cacheID: virtual area number
+//  xStart/yStart: Upper-left of virtual area
+//  xEnd/yEnd: Lower-right of virtual area
+//  x/y: Screen paste point
+void DWIN_Frame_AreaCopy(bool IBD, bool BIR, bool BFI, uint8_t cacheID, uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd, uint16_t x, uint16_t y) {
+  size_t i = 0;
+  DWIN_Byte(i, 0x27);
+  DWIN_Byte(i, (IBD & 1) << 7 | (BIR & 1) << 6 | (BFI & 1) << 5 | cacheID);
+  DWIN_Word(i, xStart);
+  DWIN_Word(i, yStart);
+  DWIN_Word(i, xEnd);
+  DWIN_Word(i, yEnd);
+  DWIN_Word(i, x);
+  DWIN_Word(i, y);
+  DWIN_Send(i);
+}
+
+// Copy area from virtual display area to current screen with transparent background
+//  cacheID: virtual area number
+//  xStart/yStart: Upper-left of virtual area
+//  xEnd/yEnd: Lower-right of virtual area
+//  x/y: Screen paste point
+void DWIN_Frame_AreaCopy(uint8_t cacheID, uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd, uint16_t x, uint16_t y) {
+  DWIN_Frame_AreaCopy(false, false, true, cacheID, xStart, yStart, xEnd, yEnd, x, y);
+}
+
+// Write buffer data to the SRAM or Flash
+//  mem: 0x5A=32KB SRAM, 0xA5=16KB Flash
+//  addr: start address
+//  length: Bytes to write
+//  data: address of the buffer with data
+void DWIN_WriteToMem(uint8_t mem, uint16_t addr, uint16_t length, uint8_t *data) {
+  const uint8_t max_size = 128;
+  uint16_t pending = length;
+  uint16_t to_send;
+  uint16_t indx;
+  uint8_t block = 0;
+
+  while (pending > 0) {
+    indx = block * max_size;
+    to_send = _MIN(pending, max_size);
+    size_t i = 0;
+    DWIN_Byte(i, 0x31);
+    DWIN_Byte(i, mem);
+    DWIN_Word(i, addr + indx); // start address of the data block
+    ++i;
+    LOOP_L_N(j, i) { LCD_SERIAL.write(DWIN_SendBuf[j]); delayMicroseconds(1); }  // Buf header
+    for (uint16_t j = indx; j <= indx + to_send - 1; j++) LCD_SERIAL.write(*(data + j)); delayMicroseconds(1);  // write block of data
+    LOOP_L_N(j, 4) { LCD_SERIAL.write(DWIN_BufTail[j]); delayMicroseconds(1); }
+    block++;
+    pending -= to_send;
+  }
+}
+
+// Write the contents of the 32KB SRAM data memory into the designated image memory space.
+//  picID: Picture memory space location, 0x00-0x0F, each space is 32Kbytes
+void DWIN_SRAMToPic(uint8_t picID) {
+  size_t i = 0;
+  DWIN_Byte(i, 0x33);
+  DWIN_Byte(i, 0x5A);
+  DWIN_Byte(i, 0xA5);
+  DWIN_Byte(i, picID);
+  DWIN_Send(i);
+}
+
+//--------------------------Test area -------------------------
+
+//void DWIN_ReadSRAM(uint16_t addr, uint8_t length, const char * const data) {
+//  size_t i = 0;
+//  DWIN_Byte(i, 0x32);
+//  DWIN_Byte(i, 0x5A);  // 0x5A Read from SRAM - 0xA5 Read from Flash
+//  DWIN_Word(i, addr);  // 0x0000 to 0x7FFF
+//  const size_t len = _MIN(0xF0, length);
+//  DWIN_Byte(i, len);
+//  DWIN_Send(i);
+//}
+
+#endif // DWIN_CREALITY_LCD_ENHANCED
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin_lcd.h b/Marlin/src/lcd/e3v2/enhanced/dwin_lcd.h
new file mode 100644
index 0000000000..fc1b6d6756
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin_lcd.h
@@ -0,0 +1,76 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/09
+ */
+
+#include "../common/dwin_api.h"
+
+// Display QR code
+//  The size of the QR code is (46*QR_Pixel)*(46*QR_Pixel) dot matrix
+//  QR_Pixel: The pixel size occupied by each point of the QR code: 0x01-0x0F (1-16)
+//  (Nx, Ny): The coordinates of the upper left corner displayed by the QR code
+//  str: multi-bit data
+void DWIN_Draw_QR(uint8_t QR_Pixel, uint16_t x, uint16_t y, char *string);
+
+inline void DWIN_Draw_QR(uint8_t QR_Pixel, uint16_t x, uint16_t y, FSTR_P title) {
+  DWIN_Draw_QR(QR_Pixel, x, y, (char *)title);
+}
+
+// Copy area from virtual display area to current screen
+//  cacheID: virtual area number
+//  xStart/yStart: Upper-left of virtual area
+//  xEnd/yEnd: Lower-right of virtual area
+//  x/y: Screen paste point
+void DWIN_Frame_AreaCopy(uint8_t cacheID, uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd, uint16_t x, uint16_t y);
+
+// Copy area from current virtual display area to current screen
+//  xStart/yStart: Upper-left of virtual area
+//  xEnd/yEnd: Lower-right of virtual area
+//  x/y: Screen paste point
+void DWIN_Frame_AreaCopy(uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd, uint16_t x, uint16_t y);
+
+// Copy area from virtual display area to current screen
+//  IBD: background display: 0=Background filtering is not displayed, 1=Background display \\When setting the background filtering not to display, the background must be pure black
+//  BIR: Background image restoration: 0=Background image is not restored, 1=Automatically use virtual display area image for background restoration
+//  BFI: Background filtering strength: 0=normal, 1=enhanced, (only valid when the icon background display=0)
+//  cacheID: virtual area number
+//  xStart/yStart: Upper-left of virtual area
+//  xEnd/yEnd: Lower-right of virtual area
+//  x/y: Screen paste point
+void DWIN_Frame_AreaCopy(bool IBD, bool BIR, bool BFI, uint8_t cacheID, uint16_t xStart, uint16_t yStart, uint16_t xEnd, uint16_t yEnd, uint16_t x, uint16_t y);
+
+// Write buffer data to the SRAM or Flash
+//  mem: 0x5A=32KB SRAM, 0xA5=16KB Flash
+//  addr: start address
+//  length: Bytes to write
+//  data: address of the buffer with data
+void DWIN_WriteToMem(uint8_t mem, uint16_t addr, uint16_t length, uint8_t *data);
+
+// Write the contents of the 32KB SRAM data memory into the designated image memory space.
+//  picID: Picture memory space location, 0x00-0x0F, each space is 32Kbytes
+void DWIN_SRAMToPic(uint8_t picID);
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin_popup.cpp b/Marlin/src/lcd/e3v2/enhanced/dwin_popup.cpp
new file mode 100644
index 0000000000..cf1ab8c0ad
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin_popup.cpp
@@ -0,0 +1,61 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/06
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+
+#include "dwin.h"
+#include "dwin_popup.h"
+
+void Draw_Select_Highlight(const bool sel) {
+  HMI_flag.select_flag = sel;
+  const uint16_t c1 = sel ? HMI_data.Highlight_Color : HMI_data.PopupBg_color,
+                 c2 = sel ? HMI_data.PopupBg_color : HMI_data.Highlight_Color;
+  DWIN_Draw_Rectangle(0, c1, 25, 279, 126, 318);
+  DWIN_Draw_Rectangle(0, c1, 24, 278, 127, 319);
+  DWIN_Draw_Rectangle(0, c2, 145, 279, 246, 318);
+  DWIN_Draw_Rectangle(0, c2, 144, 278, 247, 319);
+}
+
+void DWIN_Popup_Continue(const uint8_t icon, FSTR_P const fmsg1, FSTR_P const fmsg2) {
+  HMI_SaveProcessID(WaitResponse);
+  DWIN_Draw_Popup(icon, fmsg1, fmsg2, ICON_Continue_E);  // Button Continue
+  DWIN_UpdateLCD();
+}
+
+void DWIN_Popup_ConfirmCancel(const uint8_t icon, FSTR_P const fmsg2) {
+  DWIN_Draw_Popup(ICON_BLTouch, F("Please confirm"), fmsg2);
+  DWINUI::Draw_Icon(ICON_Confirm_E, 26, 280);
+  DWINUI::Draw_Icon(ICON_Cancel_E, 146, 280);
+  Draw_Select_Highlight(true);
+  DWIN_UpdateLCD();
+}
+
+#endif // DWIN_CREALITY_LCD_ENHANCED
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwin_popup.h b/Marlin/src/lcd/e3v2/enhanced/dwin_popup.h
new file mode 100644
index 0000000000..65784a8c9f
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwin_popup.h
@@ -0,0 +1,62 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/06
+ */
+
+#include "dwinui.h"
+#include "dwin.h"
+
+// Popup windows
+
+void Draw_Select_Highlight(const bool sel);
+
+inline void Draw_Popup_Bkgd() {
+  DWIN_Draw_Rectangle(1, HMI_data.PopupBg_color, 14, 60, 258, 330);
+  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, 14, 60, 258, 330);
+}
+
+template<typename T, typename U>
+void DWIN_Draw_Popup(const uint8_t icon, T amsg1=nullptr, U amsg2=nullptr, uint8_t button=0) {
+  DWINUI::ClearMenuArea();
+  Draw_Popup_Bkgd();
+  if (icon) DWINUI::Draw_Icon(icon, 101, 105);
+  if (amsg1) DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 210, amsg1);
+  if (amsg2) DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 240, amsg2);
+  if (button) DWINUI::Draw_Icon(button, 86, 280);
+}
+
+template<typename T, typename U>
+void DWIN_Popup_Confirm(const uint8_t icon, T amsg1, U amsg2) {
+  HMI_SaveProcessID(WaitResponse);
+  DWIN_Draw_Popup(icon, amsg1, amsg2, ICON_Confirm_E);  // Button Confirm
+  DWIN_UpdateLCD();
+}
+
+void DWIN_Popup_Continue(const uint8_t icon, FSTR_P const fmsg1, FSTR_P const fmsg2);
+
+void DWIN_Popup_ConfirmCancel(const uint8_t icon, FSTR_P const fmsg2);
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwinui.cpp b/Marlin/src/lcd/e3v2/enhanced/dwinui.cpp
new file mode 100644
index 0000000000..5017253740
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwinui.cpp
@@ -0,0 +1,454 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/09
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+
+#include "../../../inc/MarlinConfig.h"
+#include "dwin_lcd.h"
+#include "dwinui.h"
+#include "dwin_defines.h"
+
+//#define DEBUG_OUT 1
+#include "../../../core/debug_out.h"
+
+int8_t MenuItemTotal = 0;
+int8_t MenuItemCount = 0;
+MenuItemClass** MenuItems = nullptr;
+MenuClass *CurrentMenu = nullptr;
+MenuClass *PreviousMenu = nullptr;
+
+xy_int_t DWINUI::cursor = { 0 };
+uint16_t DWINUI::pencolor = Color_White;
+uint16_t DWINUI::textcolor = Def_Text_Color;
+uint16_t DWINUI::backcolor = Def_Background_Color;
+uint8_t  DWINUI::font = font8x16;
+
+void (*DWINUI::onCursorErase)(const int8_t line)=nullptr;
+void (*DWINUI::onCursorDraw)(const int8_t line)=nullptr;
+void (*DWINUI::onTitleDraw)(TitleClass* title)=nullptr;
+void (*DWINUI::onMenuDraw)(MenuClass* menu)=nullptr;
+
+void DWINUI::init() {
+  DEBUG_ECHOPGM("\r\nDWIN handshake ");
+  delay(750);   // Delay here or init later in the boot process
+  const bool success = DWIN_Handshake();
+  if (success) DEBUG_ECHOLNPGM("ok."); else DEBUG_ECHOLNPGM("error.");
+  DWIN_Frame_SetDir(1);
+  TERN(SHOW_BOOTSCREEN,,DWIN_Frame_Clear(Color_Bg_Black));
+  DWIN_UpdateLCD();
+  cursor.x = 0;
+  cursor.y = 0;
+  pencolor = Color_White;
+  textcolor = Def_Text_Color;
+  backcolor = Def_Background_Color;
+  font = font8x16;
+}
+
+// Set text/number font
+void DWINUI::setFont(uint8_t cfont) {
+  font = cfont;
+}
+
+// Get font character width
+uint8_t DWINUI::fontWidth(uint8_t cfont) {
+  switch (cfont) {
+    case font6x12 : return 6;
+    case font8x16 : return 8;
+    case font10x20: return 10;
+    case font12x24: return 12;
+    case font14x28: return 14;
+    case font16x32: return 16;
+    case font20x40: return 20;
+    case font24x48: return 24;
+    case font28x56: return 28;
+    case font32x64: return 32;
+    default: return 0;
+  }
+}
+
+// Get font character height
+uint8_t DWINUI::fontHeight(uint8_t cfont) {
+  switch (cfont) {
+    case font6x12 : return 12;
+    case font8x16 : return 16;
+    case font10x20: return 20;
+    case font12x24: return 24;
+    case font14x28: return 28;
+    case font16x32: return 32;
+    case font20x40: return 40;
+    case font24x48: return 48;
+    case font28x56: return 56;
+    case font32x64: return 64;
+    default: return 0;
+  }
+}
+
+// Get screen x coordinates from text column
+uint16_t DWINUI::ColToX(uint8_t col) {
+  return col * fontWidth(font);
+}
+
+// Get screen y coordinates from text row
+uint16_t DWINUI::RowToY(uint8_t row) {
+  return row * fontHeight(font);
+}
+
+// Set text/number color
+void DWINUI::SetColors(uint16_t fgcolor, uint16_t bgcolor) {
+  textcolor = fgcolor;
+  backcolor = bgcolor;
+}
+void DWINUI::SetTextColor(uint16_t fgcolor) {
+  textcolor = fgcolor;
+}
+void DWINUI::SetBackgroundColor(uint16_t bgcolor) {
+  backcolor = bgcolor;
+}
+
+// Moves cursor to point
+//  x: abscissa of the display
+//  y: ordinate of the display
+//  point: xy coordinate
+void DWINUI::MoveTo(int16_t x, int16_t y) {
+  cursor.x = x;
+  cursor.y = y;
+}
+void DWINUI::MoveTo(xy_int_t point) {
+  cursor = point;
+}
+
+// Moves cursor relative to the actual position
+//  x: abscissa of the display
+//  y: ordinate of the display
+//  point: xy coordinate
+void DWINUI::MoveBy(int16_t x, int16_t y) {
+  cursor.x += x;
+  cursor.y += y;
+}
+void DWINUI::MoveBy(xy_int_t point) {
+  cursor += point;
+}
+
+// Draw a Centered string using DWIN_WIDTH
+void DWINUI::Draw_CenteredString(bool bShow, uint8_t size, uint16_t color, uint16_t bColor, uint16_t y, const char * const string) {
+  const int8_t x = _MAX(0U, DWIN_WIDTH - strlen_P(string) * fontWidth(size)) / 2 - 1;
+  DWIN_Draw_String(bShow, size, color, bColor, x, y, string);
+}
+
+// Draw a char at cursor position
+void DWINUI::Draw_Char(const char c) {
+  const char string[2] = { c, 0};
+  DWIN_Draw_String(false, font, textcolor, backcolor, cursor.x, cursor.y, string, 1);
+  MoveBy(fontWidth(font), 0);
+}
+
+// Draw a string at cursor position
+//  color: Character color
+//  *string: The string
+//  rlimit: For draw less chars than string length use rlimit
+void DWINUI::Draw_String(const char * const string, uint16_t rlimit) {
+  DWIN_Draw_String(false, font, textcolor, backcolor, cursor.x, cursor.y, string, rlimit);
+  MoveBy(strlen(string) * fontWidth(font), 0);
+}
+void DWINUI::Draw_String(uint16_t color, const char * const string, uint16_t rlimit) {
+  DWIN_Draw_String(false, font, color, backcolor, cursor.x, cursor.y, string, rlimit);
+  MoveBy(strlen(string) * fontWidth(font), 0);
+}
+
+// Draw a signed floating point number
+//  bShow: true=display background color; false=don't display background color
+//  zeroFill: true=zero fill; false=no zero fill
+//  zeroMode: 1=leading 0 displayed as 0; 0=leading 0 displayed as a space
+//  size: Font size
+//  bColor: Background color
+//  iNum: Number of whole digits
+//  fNum: Number of decimal digits
+//  x/y: Upper-left point
+//  value: Float value
+void DWINUI::Draw_Signed_Float(uint8_t bShow, bool zeroFill, uint8_t zeroMode, uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+  DWIN_Draw_FloatValue(bShow, zeroFill, zeroMode, size, color, bColor, iNum, fNum, x, y, value < 0 ? -value : value);
+  DWIN_Draw_String(bShow, size, color, bColor, x - 6, y, value < 0 ? F("-") : F(" "));
+}
+
+// Draw a circle
+//  color: circle color
+//  x: the abscissa of the center of the circle
+//  y: ordinate of the center of the circle
+//  r: circle radius
+void DWINUI::Draw_Circle(uint16_t color, uint16_t x, uint16_t y, uint8_t r) {
+  int a = 0, b = 0;
+  while (a <= b) {
+    b = SQRT(sq(r) - sq(a));
+    if (a == 0) b--;
+    DWIN_Draw_Point(color, 1, 1, x + a, y + b);   // Draw some sector 1
+    DWIN_Draw_Point(color, 1, 1, x + b, y + a);   // Draw some sector 2
+    DWIN_Draw_Point(color, 1, 1, x + b, y - a);   // Draw some sector 3
+    DWIN_Draw_Point(color, 1, 1, x + a, y - b);   // Draw some sector 4
+    DWIN_Draw_Point(color, 1, 1, x - a, y - b);   // Draw some sector 5
+    DWIN_Draw_Point(color, 1, 1, x - b, y - a);   // Draw some sector 6
+    DWIN_Draw_Point(color, 1, 1, x - b, y + a);   // Draw some sector 7
+    DWIN_Draw_Point(color, 1, 1, x - a, y + b);   // Draw some sector 8
+    a++;
+  }
+}
+
+// Draw a circle filled with color
+//  bcolor: fill color
+//  x: the abscissa of the center of the circle
+//  y: ordinate of the center of the circle
+//  r: circle radius
+void DWINUI::Draw_FillCircle(uint16_t bcolor, uint16_t x,uint16_t y,uint8_t r) {
+  int a = 0, b = 0;
+  while (a <= b) {
+    b = SQRT(sq(r) - sq(a)); // b=sqrt(r*r-a*a);
+    if (a == 0) b--;
+    DWIN_Draw_Line(bcolor, x-b,y-a,x+b,y-a);
+    DWIN_Draw_Line(bcolor, x-a,y-b,x+a,y-b);
+    DWIN_Draw_Line(bcolor, x-b,y+a,x+b,y+a);
+    DWIN_Draw_Line(bcolor, x-a,y+b,x+a,y+b);
+    a++;
+  }
+}
+
+// Color Interpolator
+//  val : Interpolator minv..maxv
+//  minv : Minimum value
+//  maxv : Maximum value
+//  color1 : Start color
+//  color2 : End color
+uint16_t DWINUI::ColorInt(int16_t val, int16_t minv, int16_t maxv, uint16_t color1, uint16_t color2) {
+  uint8_t B,G,R;
+  float n;
+  n = (float)(val-minv)/(maxv-minv);
+  R = (1-n)*GetRColor(color1) + n*GetRColor(color2);
+  G = (1-n)*GetGColor(color1) + n*GetGColor(color2);
+  B = (1-n)*GetBColor(color1) + n*GetBColor(color2);
+  return RGB(R,G,B);
+}
+
+// Color Interpolator through Red->Yellow->Green->Blue
+//  val : Interpolator minv..maxv
+//  minv : Minimum value
+//  maxv : Maximum value
+uint16_t DWINUI::RainbowInt(int16_t val, int16_t minv, int16_t maxv) {
+  uint8_t B,G,R;
+  const uint8_t maxB = 28;
+  const uint8_t maxR = 28;
+  const uint8_t maxG = 38;
+  const int16_t limv = _MAX(abs(minv), abs(maxv));
+  float n;
+  if (minv>=0) {
+    n = (float)(val-minv)/(maxv-minv);
+  } else {
+    n = (float)val/limv;
+  }
+  n = _MIN(1, n);
+  n = _MAX(-1, n);
+  if (n < 0) {
+    R = 0;
+    G = (1+n)*maxG;
+    B = (-n)*maxB;
+  } else if (n < 0.5) {
+    R = maxR*n*2;
+    G = maxG;
+    B = 0;
+  } else {
+    R = maxR;
+    G = maxG*(1-n);
+    B = 0;
+  }
+  return RGB(R,G,B);
+}
+
+// Draw a checkbox
+//  Color: frame color
+//  bColor: Background color
+//  x/y: Upper-left point
+//  mode : 0 : unchecked, 1 : checked
+void DWINUI::Draw_Checkbox(uint16_t color, uint16_t bcolor, uint16_t x, uint16_t y, bool checked=false) {
+  DWIN_Draw_String(true, font8x16, color, bcolor, x + 4, y, checked ? F("x") : F(" "));
+  DWIN_Draw_Rectangle(0, color, x + 2, y + 2, x + 17, y + 17);
+}
+
+// Clear Menu by filling the menu area with background color
+void DWINUI::ClearMenuArea() {
+  DWIN_Draw_Rectangle(1, backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
+}
+
+void DWINUI::MenuItemsClear() {
+  if (MenuItems == nullptr) return;
+  for (int8_t i = 0; i < MenuItemCount; i++) delete MenuItems[i];
+  delete[] MenuItems;
+  MenuItems = nullptr;
+  MenuItemCount = 0;
+  MenuItemTotal = 0;
+}
+
+void DWINUI::MenuItemsPrepare(int8_t totalitems) {
+  MenuItemsClear();
+  MenuItemTotal = totalitems;
+  MenuItems = new MenuItemClass*[totalitems];
+}
+
+MenuItemClass* DWINUI::MenuItemsAdd(MenuItemClass* menuitem) {
+  if (MenuItemCount < MenuItemTotal) {
+    MenuItems[MenuItemCount] = menuitem;
+    menuitem->pos = MenuItemCount++;
+    return menuitem;
+  }
+  else {
+    delete menuitem;
+    return nullptr;
+  }
+}
+
+/* Title Class ==============================================================*/
+
+TitleClass Title;
+
+void TitleClass::draw() {
+  if (DWINUI::onTitleDraw != nullptr) (*DWINUI::onTitleDraw)(this);
+}
+
+void TitleClass::SetCaption(const char * const title) {
+  frameid = 0;
+  if ( caption == title ) return;
+  const uint8_t len = _MIN(sizeof(caption) - 1, strlen(title));
+  memcpy(&caption[0], title, len);
+  caption[len] = '\0';
+}
+
+void TitleClass::ShowCaption(const char * const title) {
+  SetCaption(title);
+  draw();
+}
+
+void TitleClass::SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
+  caption[0] = '\0';
+  frameid = id;
+  frame = { x1, y1, x2, y2 };
+}
+
+void TitleClass::SetFrame(uint16_t x, uint16_t y, uint16_t w, uint16_t h) {
+  SetFrame(1, x, y, x + w - 1, y + h - 1);
+}
+
+void TitleClass::FrameCopy(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
+  SetFrame(id, x1, y1, x2, y2);
+  draw();
+}
+
+void TitleClass::FrameCopy(uint16_t x, uint16_t y, uint16_t w, uint16_t h) {
+  FrameCopy(1, x, y, x + w - 1, y + h - 1);
+}
+
+/* Menu Class ===============================================================*/
+
+MenuClass::MenuClass() {
+  selected = 0;
+  topline = 0;
+}
+
+void MenuClass::draw() {
+  MenuTitle.draw();
+  if (DWINUI::onMenuDraw != nullptr) (*DWINUI::onMenuDraw)(this);
+  for (int8_t i = 0; i < MenuItemCount; i++)
+    MenuItems[i]->draw(i - topline);
+  if (DWINUI::onCursorDraw != nullptr) DWINUI::onCursorDraw(line());
+  DWIN_UpdateLCD();
+}
+
+void MenuClass::onScroll(bool dir) {
+  int8_t sel = selected;
+  if (dir) sel++; else sel--;
+  LIMIT(sel, 0, MenuItemCount - 1);
+  if (sel != selected) {
+    if (DWINUI::onCursorErase != nullptr) DWINUI::onCursorErase(line());
+    if ((sel - topline) == TROWS) {
+      DWIN_Frame_AreaMove(1, DWIN_SCROLL_UP, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      topline++;
+      MenuItems[sel]->draw(TROWS - 1);
+    }
+    if ((sel < topline)) {
+      DWIN_Frame_AreaMove(1, DWIN_SCROLL_DOWN, MLINE, DWINUI::backcolor, 0, TITLE_HEIGHT + 1, DWIN_WIDTH, STATUS_Y - 1);
+      topline--;
+      MenuItems[sel]->draw(0);
+    }
+    selected = sel;
+    if (DWINUI::onCursorDraw != nullptr) DWINUI::onCursorDraw(line());
+    DWIN_UpdateLCD();
+  }
+}
+
+void MenuClass::onClick() {
+  if (MenuItems[selected]->onClick != nullptr) (*MenuItems[selected]->onClick)();
+}
+
+MenuItemClass *MenuClass::SelectedItem() {
+  return MenuItems[selected];
+}
+
+/* MenuItem Class ===========================================================*/
+
+MenuItemClass::MenuItemClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)()) {
+  icon = cicon;
+  onClick = onclick;
+  onDraw = ondraw;
+  const uint8_t len = _MIN(sizeof(caption) - 1, strlen(text));
+  memcpy(&caption[0], text, len);
+  caption[len] = '\0';
+}
+
+MenuItemClass::MenuItemClass(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)()) {
+  icon = cicon;
+  onClick = onclick;
+  onDraw = ondraw;
+  caption[0] = '\0';
+  frameid = id;
+  frame = { x1, y1, x2, y2 };
+}
+
+void MenuItemClass::SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2) {
+  caption[0] = '\0';
+  frameid = id;
+  frame = { x1, y1, x2, y2 };
+}
+
+void MenuItemClass::draw(int8_t line) {
+  if (line < 0 || line >= TROWS) return;
+  if (onDraw != nullptr) (*onDraw)(this, line);
+};
+
+MenuItemPtrClass::MenuItemPtrClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val) : MenuItemClass(cicon, text, ondraw, onclick) {
+  value = val;
+};
+
+#endif // DWIN_CREALITY_LCD_ENHANCED
diff --git a/Marlin/src/lcd/e3v2/enhanced/dwinui.h b/Marlin/src/lcd/e3v2/enhanced/dwinui.h
new file mode 100644
index 0000000000..cb7720834c
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/dwinui.h
@@ -0,0 +1,500 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.9.1
+ * Date: 2021/11/21
+ */
+
+#include "dwin_lcd.h"
+#include "../common/dwin_set.h"
+#include "../common/dwin_font.h"
+#include "../common/dwin_color.h"
+
+// Extra Icons
+#define ICON_Brightness           ICON_Motion
+#define ICON_Cancel               ICON_StockConfiguration
+#define ICON_CustomPreheat        ICON_SetEndTemp
+#define ICON_Error                ICON_TempTooHigh
+#define ICON_ESDiag               ICON_Info
+#define ICON_ExtrudeMinT          ICON_HotendTemp
+#define ICON_FilLoad              ICON_WriteEEPROM
+#define ICON_FilMan               ICON_ResumeEEPROM
+#define ICON_FilSet               ICON_ResumeEEPROM
+#define ICON_FilUnload            ICON_ReadEEPROM
+#define ICON_Flow                 ICON_StepE
+#define ICON_FWRetLength          ICON_StepE
+#define ICON_FWRetSpeed           ICON_Setspeed
+#define ICON_FWRetZRaise          ICON_MoveZ
+#define ICON_FWRecSpeed           ICON_Setspeed
+#define ICON_HomeX                ICON_MoveX
+#define ICON_HomeY                ICON_MoveY
+#define ICON_HomeZ                ICON_MoveZ
+#define ICON_HSMode               ICON_StockConfiguration
+#define ICON_Tram                 ICON_SetEndTemp
+#define ICON_Lock                 ICON_Cool
+#define ICON_ManualMesh           ICON_HotendTemp
+#define ICON_MeshNext             ICON_Axis
+#define ICON_MeshSave             ICON_WriteEEPROM
+#define ICON_MeshViewer           ICON_HotendTemp
+#define ICON_MoveZ0               ICON_HotendTemp
+#define ICON_Park                 ICON_Motion
+#define ICON_PIDbed               ICON_SetBedTemp
+#define ICON_PIDcycles            ICON_ResumeEEPROM
+#define ICON_PIDValue             ICON_Contact
+#define ICON_PrintStats           ICON_PrintTime
+#define ICON_PrintStatsReset      ICON_RemainTime
+#define ICON_ProbeDeploy          ICON_SetEndTemp
+#define ICON_ProbeSet             ICON_SetEndTemp
+#define ICON_ProbeStow            ICON_SetEndTemp
+#define ICON_ProbeTest            ICON_SetEndTemp
+#define ICON_Pwrlossr             ICON_Motion
+#define ICON_Reboot               ICON_ResumeEEPROM
+#define ICON_Runout               ICON_MaxAccE
+#define ICON_Scolor               ICON_MaxSpeed
+#define ICON_SetCustomPreheat     ICON_SetEndTemp
+#define ICON_Sound                ICON_Cool
+
+// Extended and default UI Colors
+#define Color_Black           0
+#define Color_Green           RGB(0,63,0)
+#define Color_Aqua            RGB(0,63,31)
+#define Color_Blue            RGB(0,0,31)
+
+// UI element defines and constants
+#define DWIN_FONT_MENU font8x16
+#define DWIN_FONT_STAT font10x20
+#define DWIN_FONT_HEAD font10x20
+#define DWIN_FONT_ALERT font10x20
+#define STATUS_Y 354
+#define LCD_WIDTH (DWIN_WIDTH / 8)
+
+constexpr uint16_t TITLE_HEIGHT = 30,                          // Title bar height
+                   MLINE = 53,                                 // Menu line height
+                   TROWS = (STATUS_Y - TITLE_HEIGHT) / MLINE,  // Total rows
+                   MROWS = TROWS - 1,                          // Other-than-Back
+                   ICOX = 26,                                  // Menu item icon X position
+                   LBLX = 60,                                  // Menu item label X position
+                   VALX = 210,                                 // Menu item value X position
+                   MENU_CHR_W = 8, MENU_CHR_H = 16,            // Menu font 8x16
+                   STAT_CHR_W = 10;
+
+// Menuitem Y position
+#define MYPOS(L) (TITLE_HEIGHT + MLINE * (L))
+
+// Menuitem caption Offset
+#define CAPOFF ((MLINE - MENU_CHR_H) / 2)
+
+// Menuitem caption Y position
+#define MBASE(L) (MYPOS(L) + CAPOFF)
+
+// Create and add a MenuItem object to the menu array
+#define MENU_ITEM(V...) DWINUI::MenuItemsAdd(new MenuItemClass(V))
+#define EDIT_ITEM(V...) DWINUI::MenuItemsAdd(new MenuItemPtrClass(V))
+
+typedef struct { uint16_t left, top, right, bottom; } rect_t;
+typedef struct { uint16_t x, y, w, h; } frame_rect_t;
+
+class TitleClass {
+public:
+  char caption[32] = "";
+  uint8_t frameid = 0;
+  rect_t frame = {0};
+  void draw();
+  void SetCaption(const char * const title);
+  inline void SetCaption(FSTR_P title) { SetCaption((char *)title); }
+  void ShowCaption(const char * const title);
+  inline void ShowCaption(FSTR_P title) { ShowCaption((char *)title); }
+  void SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2);
+  void SetFrame(uint16_t x, uint16_t y, uint16_t w, uint16_t h);
+  void FrameCopy(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2);
+  void FrameCopy(uint16_t x, uint16_t y, uint16_t h, uint16_t v);
+};
+extern TitleClass Title;
+
+class MenuItemClass {
+protected:
+public:
+  int8_t pos = 0;
+  uint8_t icon = 0;
+  char caption[32] = "";
+  uint8_t frameid = 0;
+  rect_t frame = {0};
+  void (*onDraw)(MenuItemClass* menuitem, int8_t line) = nullptr;
+  void (*onClick)() = nullptr;
+  MenuItemClass() {};
+  MenuItemClass(uint8_t cicon, const char * const text=nullptr, void (*ondraw)(MenuItemClass* menuitem, int8_t line)=nullptr, void (*onclick)()=nullptr);
+  MenuItemClass(uint8_t cicon, FSTR_P text = nullptr, void (*ondraw)(MenuItemClass* menuitem, int8_t line)=nullptr, void (*onclick)()=nullptr) : MenuItemClass(cicon, FTOP(text), ondraw, onclick){}
+  MenuItemClass(uint8_t cicon, uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, void (*ondraw)(MenuItemClass* menuitem, int8_t line)=nullptr, void (*onclick)()=nullptr);
+  void SetFrame(uint8_t id, uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2);
+  virtual ~MenuItemClass(){};
+  virtual void draw(int8_t line);
+};
+
+class MenuItemPtrClass: public MenuItemClass {
+public:
+  void *value = nullptr;
+  using MenuItemClass::MenuItemClass;
+  MenuItemPtrClass(uint8_t cicon, const char * const text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val);
+  MenuItemPtrClass(uint8_t cicon, FSTR_P text, void (*ondraw)(MenuItemClass* menuitem, int8_t line), void (*onclick)(), void* val) : MenuItemPtrClass(cicon, FTOP(text), ondraw, onclick, val){}
+};
+
+class MenuClass {
+public:
+  int8_t topline = 0;
+  int8_t selected = 0;
+  TitleClass MenuTitle;
+  MenuClass();
+  virtual ~MenuClass(){};
+  inline int8_t line() { return selected - topline; };
+  inline int8_t line(uint8_t pos) {return pos - topline; };
+  void draw();
+  void onScroll(bool dir);
+  void onClick();
+  MenuItemClass* SelectedItem();
+};
+extern MenuClass *CurrentMenu;
+
+namespace DWINUI {
+  extern xy_int_t cursor;
+  extern uint16_t pencolor;
+  extern uint16_t textcolor;
+  extern uint16_t backcolor;
+  extern uint8_t  font;
+
+  extern void (*onCursorErase)(const int8_t line);
+  extern void (*onCursorDraw)(const int8_t line);
+  extern void (*onTitleDraw)(TitleClass* title);
+  extern void (*onMenuDraw)(MenuClass* menu);
+
+  // DWIN LCD Initialization
+  void init();
+
+  // Set text/number font
+  void setFont(uint8_t cfont);
+
+  // Get font character width
+  uint8_t fontWidth(uint8_t cfont);
+  inline uint8_t fontWidth() { return fontWidth(font); };
+
+  // Get font character height
+  uint8_t fontHeight(uint8_t cfont);
+  inline uint8_t fontHeight() { return fontHeight(font); };
+
+  // Get screen x coordinates from text column
+  uint16_t ColToX(uint8_t col);
+
+  // Get screen y coordinates from text row
+  uint16_t RowToY(uint8_t row);
+
+  // Set text/number color
+  void SetColors(uint16_t fgcolor, uint16_t bgcolor);
+  void SetTextColor(uint16_t fgcolor);
+  void SetBackgroundColor(uint16_t bgcolor);
+
+  // Moves cursor to point
+  //  x: abscissa of the display
+  //  y: ordinate of the display
+  //  point: xy coordinate
+  void MoveTo(int16_t x, int16_t y);
+  void MoveTo(xy_int_t point);
+
+  // Moves cursor relative to the actual position
+  //  x: abscissa of the display
+  //  y: ordinate of the display
+  //  point: xy coordinate
+  void MoveBy(int16_t x, int16_t y);
+  void MoveBy(xy_int_t point);
+
+  // Draw a line from the cursor to xy position
+  //  color: Line segment color
+  //  x/y: End point
+  inline void LineTo(uint16_t color, uint16_t x, uint16_t y) {
+    DWIN_Draw_Line(color, cursor.x, cursor.y, x, y);
+  }
+  inline void LineTo(uint16_t x, uint16_t y) {
+    DWIN_Draw_Line(pencolor, cursor.x, cursor.y, x, y);
+  }
+
+  // Draw an Icon with transparent background from the library ICON
+  //  icon: Icon ID
+  //  x/y: Upper-left point
+  inline void Draw_Icon(uint8_t icon, uint16_t x, uint16_t y) {
+    DWIN_ICON_Show(ICON, icon, x, y);
+  }
+
+  // Draw a positive integer
+  //  bShow: true=display background color; false=don't display background color
+  //  zeroFill: true=zero fill; false=no zero fill
+  //  zeroMode: 1=leading 0 displayed as 0; 0=leading 0 displayed as a space
+  //  size: Font size
+  //  color: Character color
+  //  bColor: Background color
+  //  iNum: Number of digits
+  //  x/y: Upper-left coordinate
+  //  value: Integer value
+  inline void Draw_Int(uint8_t bShow, bool zeroFill, uint8_t zeroMode, uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint16_t x, uint16_t y, long value) {
+    DWIN_Draw_IntValue(bShow, zeroFill, zeroMode, size, color, bColor, iNum, x, y, value);
+  }
+  inline void Draw_Int(uint8_t iNum, long value) {
+    DWIN_Draw_IntValue(false, true, 0, font, textcolor, backcolor, iNum, cursor.x, cursor.y, value);
+    MoveBy(iNum * fontWidth(font), 0);
+  }
+  inline void Draw_Int(uint8_t iNum, uint16_t x, uint16_t y, long value) {
+    DWIN_Draw_IntValue(false, true, 0, font, textcolor, backcolor, iNum, x, y, value);
+  }
+  inline void Draw_Int(uint16_t color, uint8_t iNum, uint16_t x, uint16_t y, long value) {
+    DWIN_Draw_IntValue(false, true, 0, font, color, backcolor, iNum, x, y, value);
+  }
+  inline void Draw_Int(uint16_t color, uint16_t bColor, uint8_t iNum, uint16_t x, uint16_t y, long value) {
+    DWIN_Draw_IntValue(true, true, 0, font, color, bColor, iNum, x, y, value);
+  }
+  inline void Draw_Int(uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint16_t x, uint16_t y, long value) {
+    DWIN_Draw_IntValue(true, true, 0, size, color, bColor, iNum, x, y, value);
+  }
+
+  // Draw a floating point number
+  //  bShow: true=display background color; false=don't display background color
+  //  zeroFill: true=zero fill; false=no zero fill
+  //  zeroMode: 1=leading 0 displayed as 0; 0=leading 0 displayed as a space
+  //  size: Font size
+  //  color: Character color
+  //  bColor: Background color
+  //  iNum: Number of whole digits
+  //  fNum: Number of decimal digits
+  //  x/y: Upper-left point
+  //  value: Float value
+  inline void Draw_Float(uint8_t bShow, bool zeroFill, uint8_t zeroMode, uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    DWIN_Draw_FloatValue(bShow, zeroFill, zeroMode, size, color, bColor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Float(uint8_t iNum, uint8_t fNum, float value) {
+    DWIN_Draw_FloatValue(false, true, 0, font, textcolor, backcolor, iNum, fNum,  cursor.x, cursor.y, value);
+    MoveBy((iNum + fNum + 1) * fontWidth(font), 0);
+  }
+  inline void Draw_Float(uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    DWIN_Draw_FloatValue(false, true, 0, font, textcolor, backcolor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Float(uint16_t color, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    DWIN_Draw_FloatValue(false, true, 0, font, color, backcolor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Float(uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    DWIN_Draw_FloatValue(true, true, 0, font, color, bColor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Float(uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    DWIN_Draw_FloatValue(true, true, 0, size, color, bColor, iNum, fNum, x, y, value);
+  }
+
+  // Draw a signed floating point number
+  //  bShow: true=display background color; false=don't display background color
+  //  zeroFill: true=zero fill; false=no zero fill
+  //  zeroMode: 1=leading 0 displayed as 0; 0=leading 0 displayed as a space
+  //  size: Font size
+  //  bColor: Background color
+  //  iNum: Number of whole digits
+  //  fNum: Number of decimal digits
+  //  x/y: Upper-left point
+  //  value: Float value
+  void Draw_Signed_Float(uint8_t bShow, bool zeroFill, uint8_t zeroMode, uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value);
+  inline void Draw_Signed_Float(uint8_t iNum, uint8_t fNum, float value) {
+    Draw_Signed_Float(false, true, 0, font, textcolor, backcolor, iNum, fNum, cursor.x, cursor.y, value);
+    MoveBy((iNum + fNum + 1) * fontWidth(font), 0);
+  }
+  inline void Draw_Signed_Float(uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    Draw_Signed_Float(false, true, 0, font, textcolor, backcolor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Signed_Float(uint8_t size, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    Draw_Signed_Float(false, true, 0, size, textcolor, backcolor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Signed_Float(uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    Draw_Signed_Float(true, true, 0, font, color, bColor, iNum, fNum, x, y, value);
+  }
+  inline void Draw_Signed_Float(uint8_t size, uint16_t color, uint16_t bColor, uint8_t iNum, uint8_t fNum, uint16_t x, uint16_t y, float value) {
+    Draw_Signed_Float(true, true, 0, size, color, bColor, iNum, fNum, x, y, value);
+  }
+
+  // Draw a char at cursor position
+  void Draw_Char(const char c);
+
+  // Draw a string at cursor position
+  //  color: Character color
+  //  *string: The string
+  //  rlimit: For draw less chars than string length use rlimit
+  void Draw_String(const char * const string, uint16_t rlimit = 0xFFFF);
+  void Draw_String(uint16_t color, const char * const string, uint16_t rlimit = 0xFFFF);
+  inline void Draw_String(FSTR_P  string, uint16_t rlimit = 0xFFFF) {
+    Draw_String(FTOP(string), rlimit);
+  }
+  inline void Draw_String(uint16_t color, FSTR_P string, uint16_t rlimit = 0xFFFF) {
+    Draw_String(color, FTOP(string), rlimit);
+  }
+
+  // Draw a string
+  //  size: Font size
+  //  color: Character color
+  //  bColor: Background color
+  //  x/y: Upper-left coordinate of the string
+  //  *string: The string
+  inline void Draw_String(uint16_t x, uint16_t y, const char * const string) {
+    DWIN_Draw_String(false, font, textcolor, backcolor, x, y, string);
+  }
+  inline void Draw_String(uint16_t x, uint16_t y, FSTR_P title) {
+    DWIN_Draw_String(false, font, textcolor, backcolor, x, y, FTOP(title));
+  }
+  inline void Draw_String(uint16_t color, uint16_t x, uint16_t y, const char * const string) {
+    DWIN_Draw_String(false, font, color, backcolor, x, y, string);
+  }
+  inline void Draw_String(uint16_t color, uint16_t x, uint16_t y, FSTR_P title) {
+    DWIN_Draw_String(false, font, color, backcolor, x, y, title);
+  }
+  inline void Draw_String(uint16_t color, uint16_t bgcolor, uint16_t x, uint16_t y, const char * const string) {
+    DWIN_Draw_String(true, font, color, bgcolor, x, y, string);
+  }
+  inline void Draw_String(uint16_t color, uint16_t bgcolor, uint16_t x, uint16_t y, FSTR_P title) {
+    DWIN_Draw_String(true, font, color, bgcolor, x, y, title);
+  }
+  inline void Draw_String(uint8_t size, uint16_t color, uint16_t bgcolor, uint16_t x, uint16_t y, const char * const string) {
+    DWIN_Draw_String(true, size, color, bgcolor, x, y, string);
+  }
+  inline void Draw_String(uint8_t size, uint16_t color, uint16_t bgcolor, uint16_t x, uint16_t y, FSTR_P title) {
+    DWIN_Draw_String(true, size, color, bgcolor, x, y, title);
+  }
+
+  // Draw a centered string using DWIN_WIDTH
+  //  bShow: true=display background color; false=don't display background color
+  //  size: Font size
+  //  color: Character color
+  //  bColor: Background color
+  //  y: Upper coordinate of the string
+  //  *string: The string
+  void Draw_CenteredString(bool bShow, uint8_t size, uint16_t color, uint16_t bColor, uint16_t y, const char * const string);
+  inline void Draw_CenteredString(bool bShow, uint8_t size, uint16_t color, uint16_t bColor, uint16_t y, FSTR_P string) {
+    Draw_CenteredString(bShow, size, color, bColor, y, FTOP(string));
+  }
+  inline void Draw_CenteredString(uint16_t color, uint16_t bcolor, uint16_t y, const char * const string) {
+    Draw_CenteredString(true, font, color, bcolor, y, string);
+  }
+  inline void Draw_CenteredString(uint8_t size, uint16_t color, uint16_t y, const char * const string) {
+    Draw_CenteredString(false, size, color, backcolor, y, string);
+  }
+  inline void Draw_CenteredString(uint8_t size, uint16_t color, uint16_t y, FSTR_P title) {
+    Draw_CenteredString(false, size, color, backcolor, y, title);
+  }
+  inline void Draw_CenteredString(uint16_t color, uint16_t y, const char * const string) {
+    Draw_CenteredString(false, font, color, backcolor, y, string);
+  }
+  inline void Draw_CenteredString(uint16_t color, uint16_t y, FSTR_P title) {
+    Draw_CenteredString(false, font, color, backcolor, y, title);
+  }
+  inline void Draw_CenteredString(uint16_t y, const char * const string) {
+    Draw_CenteredString(false, font, textcolor, backcolor, y, string);
+  }
+  inline void Draw_CenteredString(uint16_t y, FSTR_P title) {
+    Draw_CenteredString(false, font, textcolor, backcolor, y, title);
+  }
+
+  // Draw a box
+  //  mode: 0=frame, 1=fill, 2=XOR fill
+  //  color: Rectangle color
+  //  frame: Box coordinates and size
+  inline void Draw_Box(uint8_t mode, uint16_t color, frame_rect_t frame) {
+    DWIN_Draw_Box(mode, color, frame.x, frame.y, frame.w, frame.h);
+  }
+
+  // Draw a circle
+  //  Color: circle color
+  //  x: abscissa of the center of the circle
+  //  y: ordinate of the center of the circle
+  //  r: circle radius
+  void Draw_Circle(uint16_t color, uint16_t x,uint16_t y,uint8_t r);
+  inline void Draw_Circle(uint16_t color, uint8_t r) {
+    Draw_Circle(color, cursor.x, cursor.y, r);
+  }
+
+  // Draw a checkbox
+  //  Color: frame color
+  //  bColor: Background color
+  //  x/y: Upper-left point
+  //  checked : 0 : unchecked, 1 : checked
+  void Draw_Checkbox(uint16_t color, uint16_t bcolor, uint16_t x, uint16_t y, bool checked);
+  inline void Draw_Checkbox(uint16_t x, uint16_t y, bool checked=false) {
+    Draw_Checkbox(textcolor, backcolor, x, y, checked);
+  }
+
+  // Color Interpolator
+  //  val : Interpolator minv..maxv
+  //  minv : Minimum value
+  //  maxv : Maximum value
+  //  color1 : Start color
+  //  color2 : End color
+  uint16_t ColorInt(int16_t val, int16_t minv, int16_t maxv, uint16_t color1, uint16_t color2);
+
+  // -------------------------- Extra -------------------------------//
+
+  // Draw a circle filled with color
+  //  bcolor: fill color
+  //  x: abscissa of the center of the circle
+  //  y: ordinate of the center of the circle
+  //  r: circle radius
+  void Draw_FillCircle(uint16_t bcolor, uint16_t x,uint16_t y,uint8_t r);
+  inline void Draw_FillCircle(uint16_t bcolor, uint8_t r) {
+    Draw_FillCircle(bcolor, cursor.x, cursor.y, r);
+  }
+
+  // Color Interpolator through Red->Yellow->Green->Blue
+  //  val : Interpolator minv..maxv
+  //  minv : Minimum value
+  //  maxv : Maximum value
+  uint16_t RainbowInt(int16_t val, int16_t minv, int16_t maxv);
+
+  // Write buffer data to the SRAM
+  //  addr: SRAM start address 0x0000-0x7FFF
+  //  length: Bytes to write
+  //  data: address of the buffer with data
+  inline void WriteToSRAM(uint16_t addr, uint16_t length, uint8_t *data) {
+    DWIN_WriteToMem(0x5A, addr, length, data);
+  }
+
+  // Write buffer data to the Flash
+  //  addr: Flash start address 0x0000-0x3FFF
+  //  length: Bytes to write
+  //  data: address of the buffer with data
+  inline void WriteToFlash(uint16_t addr, uint16_t length, uint8_t *data) {
+    DWIN_WriteToMem(0xA5, addr, length, data);
+  }
+
+  // Clear Menu by filling the area with background color
+  // Area (0, TITLE_HEIGHT, DWIN_WIDTH, STATUS_Y - 1)
+  void ClearMenuArea();
+
+  // Clear MenuItems array and free MenuItems elements
+  void MenuItemsClear();
+
+  // Prepare MenuItems array
+  void MenuItemsPrepare(int8_t totalitems);
+
+  // Add elements to the MenuItems array
+  MenuItemClass* MenuItemsAdd(MenuItemClass* menuitem);
+
+};
diff --git a/Marlin/src/lcd/e3v2/enhanced/endstop_diag.cpp b/Marlin/src/lcd/e3v2/enhanced/endstop_diag.cpp
new file mode 100644
index 0000000000..0f982c3a36
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/endstop_diag.cpp
@@ -0,0 +1,109 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN End Stops diagnostic page
+ * Author: Miguel A. Risco-Castillo
+ * Version: 1.0
+ * Date: 2021/11/06
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+#include "dwin_defines.h"
+
+#if BOTH(DWIN_CREALITY_LCD_ENHANCED, HAS_ESDIAG)
+
+#include "endstop_diag.h"
+
+#include "../../../core/types.h"
+#include "../../marlinui.h"
+#include "dwin_lcd.h"
+#include "dwinui.h"
+#include "dwin_popup.h"
+#include "dwin.h"
+
+#if HAS_FILAMENT_SENSOR
+  #include "../../../feature/runout.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../../module/probe.h"
+#endif
+
+ESDiagClass ESDiag;
+
+void draw_es_label(FSTR_P const flabel=nullptr) {
+  DWINUI::cursor.x = 40;
+  if (flabel) DWINUI::Draw_String(F(flabel));
+  DWINUI::Draw_String(F(": "));
+  DWINUI::MoveBy(0, 25);
+}
+
+void draw_es_state(const bool is_hit) {
+  const uint8_t LM = 130;
+  DWINUI::cursor.x = LM;
+  DWIN_Draw_Rectangle(1, HMI_data.PopupBg_color, LM, DWINUI::cursor.y, LM + 100, DWINUI::cursor.y + 20);
+  is_hit ? DWINUI::Draw_String(RGB(31,31,16), F(STR_ENDSTOP_HIT)) : DWINUI::Draw_String(RGB(16,63,16), F(STR_ENDSTOP_OPEN));
+  DWINUI::MoveBy(0, 25);
+}
+
+void ESDiagClass::Draw() {
+  Title.ShowCaption(F("End-stops Diagnostic"));
+  DWINUI::ClearMenuArea();
+  Draw_Popup_Bkgd();
+  DWINUI::Draw_Icon(ICON_Continue_E, 86, 250);
+  DWINUI::cursor.y = 80;
+  #define ES_LABEL(S) draw_es_label(F(STR_##S))
+  #if HAS_X_MIN
+    ES_LABEL(X_MIN);
+  #endif
+  #if HAS_Y_MIN
+    ES_LABEL(Y_MIN);
+  #endif
+  #if HAS_Z_MIN
+    ES_LABEL(Z_MIN);
+  #endif
+  #if HAS_FILAMENT_SENSOR
+    draw_es_label(F(STR_FILAMENT));
+  #endif
+  Update();
+}
+
+void ESDiagClass::Update() {
+  DWINUI::cursor.y = 80;
+  #define ES_REPORT(S) draw_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING)
+  #if HAS_X_MIN
+    ES_REPORT(X_MIN);
+  #endif
+  #if HAS_Y_MIN
+    ES_REPORT(Y_MIN);
+  #endif
+  #if HAS_Z_MIN
+    ES_REPORT(Z_MIN);
+  #endif
+  #if HAS_FILAMENT_SENSOR
+    draw_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE);
+  #endif
+  DWIN_UpdateLCD();
+}
+
+#endif // DWIN_CREALITY_LCD_ENHANCED && HAS_MESH
diff --git a/Marlin/src/lcd/e3v2/enhanced/endstop_diag.h b/Marlin/src/lcd/e3v2/enhanced/endstop_diag.h
new file mode 100644
index 0000000000..1864b95723
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/endstop_diag.h
@@ -0,0 +1,37 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN End Stops diagnostic page
+ * Author: Miguel A. Risco-Castillo
+ * Version: 1.0
+ * Date: 2021/11/06
+ */
+
+class ESDiagClass {
+public:
+  void Draw();
+  void Update();
+};
+
+extern ESDiagClass ESDiag;
diff --git a/Marlin/src/lcd/e3v2/enhanced/lockscreen.cpp b/Marlin/src/lcd/e3v2/enhanced/lockscreen.cpp
new file mode 100644
index 0000000000..8dc84dcc46
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/lockscreen.cpp
@@ -0,0 +1,76 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Lock screen implementation for DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 2.1
+ * Date: 2021/11/09
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+
+#include "../../../core/types.h"
+#include "dwin_lcd.h"
+#include "dwinui.h"
+#include "dwin.h"
+#include "lockscreen.h"
+
+LockScreenClass lockScreen;
+
+uint8_t LockScreenClass::lock_pos = 0;
+bool LockScreenClass::unlocked = false;
+uint8_t LockScreenClass::rprocess = 0;
+
+void LockScreenClass::init() {
+  lock_pos = 0;
+  unlocked = false;
+  draw();
+}
+
+void LockScreenClass::draw() {
+  Title.SetCaption(PSTR("Lock Screen"));
+  DWINUI::ClearMenuArea();
+  DWINUI::Draw_Icon(ICON_LOGO, 71, 120);  // CREALITY logo
+  DWINUI::Draw_CenteredString(Color_White, 180, F("Printer is Locked,"));
+  DWINUI::Draw_CenteredString(Color_White, 200, F("Scroll to unlock."));
+  DWINUI::Draw_CenteredString(Color_White, 240, F("-> | <-"));
+  DWIN_Draw_Box(1, HMI_data.Barfill_Color, 0, 260, DWIN_WIDTH, 20);
+  DWIN_Draw_VLine(Color_Yellow, lock_pos * DWIN_WIDTH / 255, 260, 20);
+  DWIN_UpdateLCD();
+}
+
+void LockScreenClass::onEncoder(EncoderState encoder_diffState) {
+  switch (encoder_diffState) {
+    case ENCODER_DIFF_CW:    lock_pos += 8; break;
+    case ENCODER_DIFF_CCW:   lock_pos -= 8; break;
+    case ENCODER_DIFF_ENTER: unlocked = (lock_pos == 128); break;
+    default: break;
+  }
+  DWIN_Draw_Box(1, HMI_data.Barfill_Color, 0, 260, DWIN_WIDTH, 20);
+  DWIN_Draw_VLine(Color_Yellow, lock_pos * DWIN_WIDTH / 255, 260, 20);
+  DWIN_UpdateLCD();
+}
+
+#endif // DWIN_CREALITY_LCD_ENHANCED
diff --git a/Marlin/src/lcd/e3v2/enhanced/lockscreen.h b/Marlin/src/lcd/e3v2/enhanced/lockscreen.h
new file mode 100644
index 0000000000..a51c82f34e
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/lockscreen.h
@@ -0,0 +1,46 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * Lock screen implementation for DWIN UI Enhanced implementation
+ * Author: Miguel A. Risco-Castillo
+ * Version: 2.1
+ * Date: 2021/11/09
+ */
+
+#include "../common/encoder.h"
+#include <stdint.h>
+
+class LockScreenClass {
+private:
+  static bool unlocked;
+  static uint8_t lock_pos;
+public:
+  static uint8_t rprocess;
+  static void init();
+  static void onEncoder(EncoderState encoder_diffState);
+  static void draw();
+  static bool isUnlocked() { return unlocked; }
+};
+
+extern LockScreenClass lockScreen;
diff --git a/Marlin/src/lcd/e3v2/enhanced/meshviewer.cpp b/Marlin/src/lcd/e3v2/enhanced/meshviewer.cpp
new file mode 100644
index 0000000000..1ecbbff0aa
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/meshviewer.cpp
@@ -0,0 +1,110 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN Mesh Viewer
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/06
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if BOTH(DWIN_CREALITY_LCD_ENHANCED, HAS_MESH)
+
+#include "meshviewer.h"
+
+#include "../../../core/types.h"
+#include "../../marlinui.h"
+#include "dwin_lcd.h"
+#include "dwinui.h"
+#include "dwin.h"
+#include "../../../feature/bedlevel/bedlevel.h"
+
+MeshViewerClass MeshViewer;
+
+void MeshViewerClass::Draw() {
+  const int8_t mx = 25, my = 25;  // Margins
+  const int16_t stx = (DWIN_WIDTH - 2 * mx) / (GRID_MAX_POINTS_X - 1),  // Steps
+                sty = (DWIN_WIDTH - 2 * my) / (GRID_MAX_POINTS_Y - 1);
+  const int8_t rmax = _MIN(mx - 2, stx / 2);
+  const int8_t rmin = 7;
+  int16_t zmesh[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y], maxz =-32000, minz = 32000;
+  #define px(xp) (mx + (xp) * stx)
+  #define py(yp) (30 + DWIN_WIDTH - my - (yp) * sty)
+  #define rm(z) ((z - minz) * (rmax - rmin) / _MAX(1, (maxz - minz)) + rmin)
+  #define DrawMeshValue(xp, yp, zv) DWINUI::Draw_Signed_Float(font6x12, 1, 2, px(xp) - 12, py(yp) - 6, zv)
+  #define DrawMeshHLine(yp) DWIN_Draw_HLine(HMI_data.SplitLine_Color, px(0), py(yp), DWIN_WIDTH - 2 * mx)
+  #define DrawMeshVLine(xp) DWIN_Draw_VLine(HMI_data.SplitLine_Color, px(xp), py(GRID_MAX_POINTS_Y - 1), DWIN_WIDTH - 2 * my)
+  GRID_LOOP(x, y) {
+    const float v = Z_VALUES(x,y) * 100;
+    zmesh[x][y] = v;
+    NOLESS(maxz, v);
+    NOMORE(minz, v);
+  }
+  Title.ShowCaption(F("Mesh Viewer"));
+  DWINUI::ClearMenuArea();
+  DWINUI::Draw_Icon(ICON_Continue_E, 86, 305);
+  DWIN_Draw_Rectangle(0, HMI_data.SplitLine_Color, px(0), py(0), px(GRID_MAX_POINTS_X - 1), py(GRID_MAX_POINTS_Y - 1));
+  LOOP_S_L_N(x, 1, GRID_MAX_POINTS_X - 1) DrawMeshVLine(x);
+  LOOP_S_L_N(y, 1, GRID_MAX_POINTS_Y - 1) DrawMeshHLine(y);
+  LOOP_L_N(y, GRID_MAX_POINTS_Y) {
+    watchdog_refresh();
+    LOOP_L_N(x, GRID_MAX_POINTS_X) {
+      uint16_t color = DWINUI::RainbowInt(zmesh[x][y], _MIN(-5, minz), _MAX(5, maxz));
+      uint8_t radius = rm(zmesh[x][y]);
+      DWINUI::Draw_FillCircle(color, px(x), py(y), radius);
+      if (GRID_MAX_POINTS_X < 9)
+        DWINUI::Draw_Signed_Float(font6x12, 1, 2, px(x) - 12, py(y) - 6, Z_VALUES(x,y));
+      else {
+        char str_1[9];
+        str_1[0] = 0;
+        switch (zmesh[x][y]) {
+          case -999 ... -100:
+            DWINUI::Draw_Signed_Float(font6x12, 1, 1, px(x) - 12, py(y) - 6, Z_VALUES(x,y));
+            break;
+          case -99 ... -1:
+            sprintf_P(str_1, PSTR("-.%02i"), -zmesh[x][y]);
+            break;
+          case 0:
+            DWIN_Draw_String(false, font6x12, DWINUI::textcolor, DWINUI::backcolor, px(x) - 4, py(y) - 6, "0");;
+            break;
+          case 1 ... 99:
+            sprintf_P(str_1, PSTR(".%02i"), zmesh[x][y]);
+            break;
+          case 100 ... 999:
+            DWINUI::Draw_Signed_Float(font6x12, 1, 1, px(x) - 12, py(y) - 6, Z_VALUES(x,y));
+            break;
+        }
+        if (str_1[0])
+          DWIN_Draw_String(false, font6x12, DWINUI::textcolor, DWINUI::backcolor, px(x) - 12, py(y) - 6, str_1);
+      }
+    }
+  }
+  char str_1[6], str_2[6] = "";
+  ui.status_printf(0, F("Mesh minZ: %s, maxZ: %s"),
+    dtostrf((float)minz / 100, 1, 2, str_1),
+    dtostrf((float)maxz / 100, 1, 2, str_2)
+  );
+}
+
+#endif // DWIN_CREALITY_LCD_ENHANCED && HAS_MESH
diff --git a/Marlin/src/lcd/e3v2/enhanced/meshviewer.h b/Marlin/src/lcd/e3v2/enhanced/meshviewer.h
new file mode 100644
index 0000000000..6e7fe6fd82
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/meshviewer.h
@@ -0,0 +1,36 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN Mesh Viewer
+ * Author: Miguel A. Risco-Castillo
+ * Version: 3.8.1
+ * Date: 2021/11/06
+ */
+
+class MeshViewerClass {
+public:
+  void Draw();
+};
+
+extern MeshViewerClass MeshViewer;
diff --git a/Marlin/src/lcd/e3v2/enhanced/printstats.cpp b/Marlin/src/lcd/e3v2/enhanced/printstats.cpp
new file mode 100644
index 0000000000..a32d698b96
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/printstats.cpp
@@ -0,0 +1,76 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * DWIN Print Stats page
+ * Author: Miguel A. Risco-Castillo
+ * Version: 1.0
+ * Date: 2021/11/21
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if BOTH(DWIN_CREALITY_LCD_ENHANCED, PRINTCOUNTER)
+
+#include "printstats.h"
+
+#include "../../../core/types.h"
+#include "../../marlinui.h"
+#include "../../../module/printcounter.h"
+#include "dwin_lcd.h"
+#include "dwinui.h"
+#include "dwin_popup.h"
+#include "dwin.h"
+
+PrintStatsClass PrintStats;
+
+void PrintStatsClass::Draw() {
+  char buf[50] = "";
+  char str[30] = "";
+  constexpr int8_t MRG = 30;
+
+  Title.ShowCaption(GET_TEXT_F(MSG_INFO_STATS_MENU));
+  DWINUI::ClearMenuArea();
+  Draw_Popup_Bkgd();
+  DWINUI::Draw_Icon(ICON_Continue_E, 86, 250);
+  printStatistics ps = print_job_timer.getStats();
+
+  sprintf_P(buf, PSTR(S_FMT ": %i"), GET_TEXT(MSG_INFO_PRINT_COUNT), ps.totalPrints);
+  DWINUI::Draw_String(MRG, 80, buf);
+  sprintf_P(buf, PSTR(S_FMT ": %i"), GET_TEXT(MSG_INFO_COMPLETED_PRINTS), ps.finishedPrints);
+  DWINUI::Draw_String(MRG, 100, buf);
+  duration_t(print_job_timer.getStats().printTime).toDigital(str, true);
+  sprintf_P(buf, PSTR(S_FMT ": %s"), GET_TEXT(MSG_INFO_PRINT_TIME), str);
+  DWINUI::Draw_String(MRG, 120, buf);
+  duration_t(print_job_timer.getStats().longestPrint).toDigital(str, true);
+  sprintf_P(buf, PSTR(S_FMT ": %s"), GET_TEXT(MSG_INFO_PRINT_LONGEST), str);
+  DWINUI::Draw_String(MRG, 140, buf);
+  sprintf_P(buf, PSTR(S_FMT ": %s m"), GET_TEXT(MSG_INFO_PRINT_FILAMENT), dtostrf(ps.filamentUsed / 1000, 1, 2, str));
+  DWINUI::Draw_String(MRG, 160, buf);
+}
+
+void PrintStatsClass::Reset() {
+  print_job_timer.initStats();
+  HMI_AudioFeedback();
+}
+
+#endif // DWIN_CREALITY_LCD_ENHANCED && PRINTCOUNTER
diff --git a/Marlin/src/lcd/e3v2/enhanced/printstats.h b/Marlin/src/lcd/e3v2/enhanced/printstats.h
new file mode 100644
index 0000000000..5f62a4c268
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/enhanced/printstats.h
@@ -0,0 +1,37 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * DWIN Print Stats page
+ * Author: Miguel A. Risco-Castillo
+ * Version: 1.0
+ * Date: 2021/11/21
+ */
+
+class PrintStatsClass {
+public:
+  void Draw();
+  static void Reset();
+};
+
+extern PrintStatsClass PrintStats;
diff --git a/Marlin/src/lcd/tft/fontdata/fontdata_10x20.cpp b/Marlin/src/lcd/tft/fontdata/fontdata_10x20.cpp
new file mode 100644
index 0000000000..f03366d6f7
--- /dev/null
+++ b/Marlin/src/lcd/tft/fontdata/fontdata_10x20.cpp
@@ -0,0 +1,260 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+  Fontname: -Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO10646-1
+  Copyright: Public domain font.  Share and enjoy.
+  Capital A Height: 13, '1' Height: 13
+  Calculated Max Values w= 9 h=17 x= 4 y=16 dx=10 dy= 0 ascent=16 len=26
+  Font Bounding box     w=10 h=20 x= 0 y=-4
+  Calculated Min Values           x= 0 y=-4 dx= 0 dy= 0
+  Pure Font   ascent =13 descent=-4
+  X Font      ascent =13 descent=-4
+  Max Font    ascent =16 descent=-4
+*/
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include <stdint.h>
+
+extern const uint8_t font10x20[3453] = {
+  0,10,20,0,252,13,2,74,4,153,32,255,252,16,252,13,
+  252,0,0,0,10,0,16,2,13,13,10,4,0,192,192,192,
+  192,192,192,192,192,192,192,0,192,192,6,4,4,10,2,9,
+  204,204,204,72,9,11,22,10,1,1,27,0,27,0,27,0,
+  127,128,54,0,54,0,54,0,255,0,108,0,108,0,108,0,
+  8,13,13,10,1,0,24,126,219,216,216,216,126,27,27,27,
+  219,126,24,9,12,24,10,1,0,115,0,219,0,222,0,118,
+  0,12,0,12,0,24,0,24,0,55,0,61,128,109,128,103,
+  0,9,13,26,10,1,0,56,0,108,0,108,0,108,0,120,
+  0,48,0,112,0,216,0,205,128,199,0,198,0,239,0,121,
+  128,2,5,5,10,4,8,192,192,192,192,128,5,13,13,10,
+  3,0,24,48,96,96,192,192,192,192,192,96,96,48,24,5,
+  13,13,10,2,0,192,96,48,48,24,24,24,24,24,48,48,
+  96,192,8,7,7,10,1,3,102,102,60,255,60,102,102,8,
+  7,7,10,1,3,24,24,24,255,24,24,24,4,3,3,10,
+  3,255,112,112,224,8,1,1,10,1,6,255,3,3,3,10,
+  4,0,224,224,224,7,12,12,10,2,0,6,6,12,12,24,
+  24,48,48,96,96,192,192,8,13,13,10,1,0,24,60,102,
+  102,195,195,195,195,195,102,102,60,24,8,13,13,10,1,0,
+  24,56,120,216,24,24,24,24,24,24,24,24,255,8,13,13,
+  10,1,0,60,102,195,195,3,3,6,28,48,96,192,192,255,
+  8,13,13,10,1,0,60,102,195,195,3,6,28,6,3,195,
+  195,102,60,8,13,13,10,1,0,2,6,14,30,54,102,198,
+  198,255,6,6,6,6,8,13,13,10,1,0,255,192,192,192,
+  192,220,230,3,3,3,195,102,60,8,13,13,10,1,0,60,
+  102,194,192,192,220,230,195,195,195,195,102,60,8,13,13,10,
+  1,0,255,3,3,6,6,12,12,24,24,48,48,96,96,8,
+  13,13,10,1,0,60,102,195,195,195,102,60,102,195,195,195,
+  102,60,8,13,13,10,1,0,60,102,195,195,195,195,103,59,
+  3,3,67,102,60,3,8,8,10,4,0,224,224,0,0,0,
+  0,224,224,4,9,9,10,3,255,112,112,0,0,0,0,112,
+  112,224,7,13,13,10,1,0,2,6,12,24,48,96,192,96,
+  48,24,12,6,2,8,6,6,10,1,3,255,0,0,0,0,
+  255,7,13,13,10,2,0,128,192,96,48,24,12,6,12,24,
+  48,96,192,128,8,13,13,10,1,0,60,102,195,195,195,6,
+  12,24,24,24,0,24,24,8,13,13,10,1,0,60,102,195,
+  207,223,219,219,219,222,204,192,99,62,8,13,13,10,1,0,
+  24,60,102,102,195,195,195,255,195,195,195,195,195,8,13,13,
+  10,1,0,248,204,198,198,198,204,252,198,195,195,195,198,252,
+  8,13,13,10,1,0,60,102,195,192,192,192,192,192,192,192,
+  195,102,60,8,13,13,10,1,0,252,198,195,195,195,195,195,
+  195,195,195,195,198,252,8,13,13,10,1,0,255,192,192,192,
+  192,192,252,192,192,192,192,192,255,8,13,13,10,1,0,255,
+  192,192,192,192,192,252,192,192,192,192,192,192,8,13,13,10,
+  1,0,60,102,195,192,192,192,207,195,195,195,195,103,61,8,
+  13,13,10,1,0,195,195,195,195,195,195,255,195,195,195,195,
+  195,195,8,13,13,10,1,0,255,24,24,24,24,24,24,24,
+  24,24,24,24,255,9,13,26,10,1,0,31,128,6,0,6,
+  0,6,0,6,0,6,0,6,0,6,0,6,0,198,0,198,
+  0,108,0,56,0,8,13,13,10,1,0,195,195,198,198,204,
+  204,248,204,204,198,198,195,195,8,13,13,10,1,0,192,192,
+  192,192,192,192,192,192,192,192,192,192,255,8,13,13,10,1,
+  0,195,195,231,231,255,219,219,219,219,195,195,195,195,8,13,
+  13,10,1,0,195,227,227,243,243,219,219,207,207,199,199,195,
+  195,8,13,13,10,1,0,60,102,195,195,195,195,195,195,195,
+  195,195,102,60,8,13,13,10,1,0,252,198,195,195,195,195,
+  198,252,192,192,192,192,192,8,14,14,10,1,255,60,102,195,
+  195,195,195,195,195,195,219,207,102,62,3,8,13,13,10,1,
+  0,252,198,195,195,195,195,198,252,204,198,198,195,195,8,13,
+  13,10,1,0,60,102,195,192,192,96,60,6,3,3,195,102,
+  60,8,13,13,10,1,0,255,24,24,24,24,24,24,24,24,
+  24,24,24,24,8,13,13,10,1,0,195,195,195,195,195,195,
+  195,195,195,195,195,102,60,8,13,13,10,1,0,195,195,195,
+  195,102,102,102,60,60,60,24,24,24,8,13,13,10,1,0,
+  195,195,195,195,195,219,219,219,219,231,231,195,195,8,13,13,
+  10,1,0,195,195,102,102,60,60,24,60,60,102,102,195,195,
+  8,13,13,10,1,0,195,195,102,102,60,60,24,24,24,24,
+  24,24,24,8,13,13,10,1,0,255,3,3,6,12,12,24,
+  48,48,96,192,192,255,6,13,13,10,2,0,252,192,192,192,
+  192,192,192,192,192,192,192,192,252,7,12,12,10,2,0,192,
+  192,96,96,48,48,24,24,12,12,6,6,6,13,13,10,2,
+  0,252,12,12,12,12,12,12,12,12,12,12,12,252,8,4,
+  4,10,1,9,24,60,102,195,9,1,2,10,1,255,255,128,
+  4,3,3,10,3,10,192,96,48,8,8,8,10,1,0,62,
+  99,3,127,195,195,195,125,8,13,13,10,1,0,192,192,192,
+  192,192,220,230,195,195,195,195,230,220,8,8,8,10,1,0,
+  62,99,192,192,192,192,99,62,8,13,13,10,1,0,3,3,
+  3,3,3,59,103,195,195,195,195,103,59,8,8,8,10,1,
+  0,60,102,195,255,192,192,99,62,8,13,13,10,1,0,30,
+  51,51,48,48,252,48,48,48,48,48,48,48,8,12,12,10,
+  1,252,125,199,198,198,198,124,192,126,195,195,195,126,8,13,
+  13,10,1,0,192,192,192,192,192,220,230,195,195,195,195,195,
+  195,8,11,11,10,1,0,24,24,0,120,24,24,24,24,24,
+  24,255,7,15,15,10,2,252,6,6,0,30,6,6,6,6,
+  6,6,6,198,198,198,124,8,13,13,10,1,0,192,192,192,
+  192,192,198,204,216,240,248,204,198,195,8,13,13,10,1,0,
+  120,24,24,24,24,24,24,24,24,24,24,24,255,8,8,8,
+  10,1,0,182,255,219,219,219,219,219,219,8,8,8,10,1,
+  0,220,230,195,195,195,195,195,195,8,8,8,10,1,0,60,
+  102,195,195,195,195,102,60,8,12,12,10,1,252,220,230,195,
+  195,195,195,230,220,192,192,192,192,8,12,12,10,1,252,59,
+  103,195,195,195,195,103,59,3,3,3,3,8,8,8,10,1,
+  0,222,115,96,96,96,96,96,96,8,8,8,10,1,0,126,
+  195,192,126,3,3,195,126,8,11,11,10,1,0,48,48,48,
+  252,48,48,48,48,48,51,30,8,8,8,10,1,0,195,195,
+  195,195,195,195,103,59,8,8,8,10,1,0,195,195,102,102,
+  60,60,24,24,8,8,8,10,1,0,195,195,195,219,219,219,
+  255,102,8,8,8,10,1,0,195,102,60,24,24,60,102,195,
+  8,12,12,10,1,252,195,195,195,195,195,195,103,59,3,195,
+  102,60,7,8,8,10,2,0,254,6,12,24,48,96,192,254,
+  8,13,13,10,1,0,15,24,24,24,24,24,240,24,24,24,
+  24,24,15,2,13,13,10,4,0,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,8,13,13,10,1,0,240,24,24,24,
+  24,24,15,24,24,24,24,24,240,8,3,3,10,1,10,115,
+  219,206,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
+  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
+  255,255,255,0,0,0,10,0,16,2,13,13,10,4,0,192,
+  192,0,192,192,192,192,192,192,192,192,192,192,7,12,12,10,
+  1,0,24,24,60,102,194,192,192,194,102,60,24,24,9,12,
+  24,10,1,0,30,0,51,0,51,0,48,0,48,0,252,0,
+  48,0,48,0,48,0,248,0,173,128,231,0,9,9,18,10,
+  0,1,128,128,221,128,127,0,99,0,99,0,99,0,127,0,
+  221,128,128,128,8,11,11,10,1,0,129,195,102,60,126,24,
+  126,24,24,24,24,2,13,13,10,4,0,192,192,192,192,192,
+  0,0,0,192,192,192,192,192,8,13,13,10,1,0,60,102,
+  198,96,120,204,102,51,30,6,99,102,60,6,2,2,10,2,
+  11,204,204,8,11,11,10,1,0,60,102,195,189,165,161,165,
+  189,195,102,60,8,9,9,10,1,4,62,67,3,127,195,195,
+  125,0,255,9,11,22,10,0,0,4,128,13,128,27,0,54,
+  0,108,0,216,0,108,0,54,0,27,0,13,128,4,128,8,
+  4,4,10,1,4,255,255,3,3,6,1,1,10,2,6,252,
+  8,11,11,10,1,0,60,102,195,189,165,189,169,173,195,102,
+  60,8,1,1,10,1,13,255,6,6,6,10,2,7,48,120,
+  204,204,120,48,8,7,7,10,1,2,24,24,255,24,24,0,
+  255,5,7,7,10,2,6,112,216,24,48,96,192,248,5,7,
+  7,10,2,6,112,216,24,48,24,216,112,4,3,3,10,3,
+  10,48,96,192,7,10,10,10,1,253,198,198,198,198,198,238,
+  250,192,192,192,8,13,13,10,1,0,127,255,251,251,251,123,
+  27,27,27,27,27,27,27,3,3,3,10,4,5,224,224,224,
+  5,4,4,10,2,252,48,24,216,112,4,7,7,10,2,6,
+  96,224,96,96,96,96,240,7,9,9,10,1,4,56,108,198,
+  198,198,108,56,0,254,9,11,22,10,1,0,144,0,216,0,
+  108,0,54,0,27,0,13,128,27,0,54,0,108,0,216,0,
+  144,0,8,12,12,10,1,1,64,192,65,66,228,8,18,38,
+  74,158,2,2,8,12,12,10,1,1,64,192,65,66,228,8,
+  22,41,65,130,4,15,8,12,12,10,1,1,224,16,97,18,
+  228,8,18,38,74,159,2,2,8,13,13,10,1,0,24,24,
+  0,24,24,24,48,96,195,195,195,102,60,8,15,15,10,1,
+  0,96,48,24,0,24,60,102,195,195,195,255,195,195,195,195,
+  8,15,15,10,1,0,6,12,24,0,24,60,102,195,195,195,
+  255,195,195,195,195,8,15,15,10,1,0,24,60,102,0,24,
+  60,102,195,195,195,255,195,195,195,195,8,15,15,10,1,0,
+  50,126,76,0,24,60,102,195,195,195,255,195,195,195,195,8,
+  15,15,10,1,0,102,102,0,24,60,102,102,195,195,195,255,
+  195,195,195,195,8,16,16,10,1,0,60,102,102,60,0,24,
+  60,102,195,195,195,255,195,195,195,195,8,13,13,10,1,0,
+  31,60,108,108,204,204,255,204,204,204,204,204,207,8,17,17,
+  10,1,252,60,102,195,192,192,192,192,192,192,192,195,102,60,
+  24,12,108,56,8,15,15,10,1,0,96,48,24,0,255,192,
+  192,192,192,252,192,192,192,192,255,8,15,15,10,1,0,12,
+  24,48,0,255,192,192,192,192,252,192,192,192,192,255,8,15,
+  15,10,1,0,24,60,102,0,255,192,192,192,192,252,192,192,
+  192,192,255,8,15,15,10,1,0,102,102,0,0,255,192,192,
+  192,192,252,192,192,192,192,255,6,15,15,10,2,0,96,48,
+  24,0,252,48,48,48,48,48,48,48,48,48,252,6,15,15,
+  10,2,0,24,48,96,0,252,48,48,48,48,48,48,48,48,
+  48,252,6,15,15,10,2,0,48,120,204,0,252,48,48,48,
+  48,48,48,48,48,48,252,6,15,15,10,2,0,204,204,0,
+  252,48,48,48,48,48,48,48,48,48,48,252,9,13,26,10,
+  0,0,126,0,99,0,97,128,97,128,97,128,97,128,249,128,
+  97,128,97,128,97,128,97,128,99,0,126,0,8,15,15,10,
+  1,0,50,126,76,0,195,227,243,243,219,219,207,207,199,195,
+  195,8,15,15,10,1,0,48,24,12,0,60,102,195,195,195,
+  195,195,195,195,102,60,8,15,15,10,1,0,12,24,48,0,
+  60,102,195,195,195,195,195,195,195,102,60,8,15,15,10,1,
+  0,24,60,102,0,60,102,195,195,195,195,195,195,195,102,60,
+  8,15,15,10,1,0,50,126,76,0,60,102,195,195,195,195,
+  195,195,195,102,60,8,15,15,10,1,0,102,102,0,60,102,
+  195,195,195,195,195,195,195,195,102,60,7,8,8,10,1,0,
+  130,198,108,56,56,108,198,130,8,15,15,10,1,255,1,62,
+  102,199,199,203,203,203,211,211,211,227,102,124,128,8,15,15,
+  10,1,0,48,24,12,0,195,195,195,195,195,195,195,195,195,
+  102,60,8,15,15,10,1,0,12,24,48,0,195,195,195,195,
+  195,195,195,195,195,102,60,8,15,15,10,1,0,24,60,102,
+  0,195,195,195,195,195,195,195,195,195,102,60,8,15,15,10,
+  1,0,102,102,0,195,195,195,195,195,195,195,195,195,195,102,
+  60,8,15,15,10,1,0,12,24,48,0,195,195,102,102,60,
+  60,24,24,24,24,24,7,13,13,10,2,0,192,192,192,252,
+  198,198,198,198,198,252,192,192,192,8,13,13,10,1,0,28,
+  54,99,99,102,236,108,102,99,99,99,102,108,8,12,12,10,
+  1,0,48,24,12,0,126,195,3,127,195,195,195,125,8,12,
+  12,10,1,0,12,24,48,0,126,195,3,127,195,195,195,125,
+  8,12,12,10,1,0,24,60,102,0,126,195,3,127,195,195,
+  195,125,8,12,12,10,1,0,50,126,76,0,126,195,3,127,
+  195,195,195,125,8,11,11,10,1,0,102,102,0,126,195,3,
+  127,195,195,195,125,8,13,13,10,1,0,60,102,102,60,0,
+  126,195,3,127,195,195,195,125,8,8,8,10,1,0,118,155,
+  27,30,120,216,217,110,8,12,12,10,1,252,62,99,192,192,
+  192,192,99,62,24,12,108,56,8,12,12,10,1,0,96,48,
+  24,0,60,102,195,255,192,192,99,62,8,12,12,10,1,0,
+  6,12,24,0,60,102,195,255,192,192,99,62,8,12,12,10,
+  1,0,24,60,102,0,60,102,195,255,192,192,99,62,8,11,
+  11,10,1,0,102,102,0,60,102,195,255,192,192,99,62,8,
+  12,12,10,1,0,96,48,24,0,120,24,24,24,24,24,24,
+  255,8,12,12,10,1,0,12,24,48,0,120,24,24,24,24,
+  24,24,255,8,12,12,10,1,0,24,60,102,0,120,24,24,
+  24,24,24,24,255,8,11,11,10,1,0,102,102,0,120,24,
+  24,24,24,24,24,255,8,13,13,10,1,0,136,216,112,112,
+  216,140,62,103,195,195,195,102,60,8,12,12,10,1,0,50,
+  126,76,0,220,230,195,195,195,195,195,195,8,12,12,10,1,
+  0,96,48,24,0,60,102,195,195,195,195,102,60,8,12,12,
+  10,1,0,6,12,24,0,60,102,195,195,195,195,102,60,8,
+  12,12,10,1,0,24,60,102,0,60,102,195,195,195,195,102,
+  60,8,12,12,10,1,0,50,126,76,0,60,102,195,195,195,
+  195,102,60,8,11,11,10,1,0,102,102,0,60,102,195,195,
+  195,195,102,60,8,10,10,10,1,1,24,24,0,0,255,255,
+  0,0,24,24,8,10,10,10,1,255,1,62,102,203,203,211,
+  211,102,124,128,8,12,12,10,1,0,48,24,12,0,195,195,
+  195,195,195,195,103,59,8,12,12,10,1,0,6,12,24,0,
+  195,195,195,195,195,195,103,59,8,12,12,10,1,0,24,60,
+  102,0,195,195,195,195,195,195,103,59,8,11,11,10,1,0,
+  102,102,0,195,195,195,195,195,195,103,59,8,16,16,10,1,
+  252,12,24,48,0,195,195,195,195,195,195,103,59,3,195,102,
+  60,7,17,17,10,2,252,192,192,192,192,192,192,248,204,198,
+  198,198,204,248,192,192,192,192,8,15,15,10,1,252,102,102,
+  0,195,195,195,195,195,195,103,59,3,195,102,60
+};
+
+#endif // HAS_GRAPHICAL_TFT
diff --git a/Marlin/src/lcd/tft/fontdata/fontdata_ISO10646_1.cpp b/Marlin/src/lcd/tft/fontdata/fontdata_ISO10646_1.cpp
new file mode 100644
index 0000000000..21531f5c14
--- /dev/null
+++ b/Marlin/src/lcd/tft/fontdata/fontdata_ISO10646_1.cpp
@@ -0,0 +1,317 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include <stdint.h>
+
+#define STM32_NOT_EXTENDED_ISO10646_1_5X7
+
+#if ENABLED(STM32_NOT_EXTENDED_ISO10646_1_5X7)
+  // reduced font (only symbols 1 - 127) - saves about 1278 bytes of FLASH
+
+/*
+  Fontname: -Marlin6x12-Fixed-Medium-R-SemiCondensed--12-90-100-100-C-111-ISO10646-1
+  Copyright: Public domain terminal emulator font.  Share and enjoy. original font -Misc-Fixed-Medium-R-SemiCondensed--12-110-75-75-C-60-ISO10646-1
+  Capital A Height: 7, '1' Height: 7
+  Calculated Max Values w= 5 h=10 x= 5 y= 5 dx= 6 dy= 0 ascent= 8 len=10
+  Font Bounding box     w=12 h=13 x= 0 y=-2
+  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0
+  Pure Font   ascent = 7 descent=-2
+  X Font      ascent = 8 descent=-2
+  Max Font    ascent = 8 descent=-2
+*/
+extern const uint8_t ISO10646_1_5x7[1325] = {
+  0x00,0x0C,0x0D,0x00,0xFE,0x07,0x02,0x26,0x03,0xBC,0x01,0x7F,0xFE,0x0A,0xFE,0x08,
+  0xFE,0x05,0x08,0x08,0x06,0x00,0x00,0x40,0xF0,0xC8,0x88,0x88,0x98,0x78,0x10,0x05,
+  0x08,0x08,0x06,0x00,0x00,0xC0,0xF8,0x88,0x88,0x88,0x88,0x88,0xF8,0x05,0x05,0x05,
+  0x06,0x00,0x01,0x20,0x30,0xF8,0x30,0x20,0x05,0x08,0x08,0x06,0x00,0x00,0x20,0x70,
+  0xF8,0x20,0x20,0x20,0x20,0xE0,0x05,0x09,0x09,0x06,0x00,0xFF,0x20,0x70,0xA8,0xA8,
+  0xB8,0x88,0x88,0x70,0x20,0x07,0x06,0x06,0x08,0x00,0x01,0xE0,0x8C,0xEA,0x8C,0x8A,
+  0x0A,0x05,0x09,0x09,0x06,0x00,0xFF,0xF8,0xA8,0x88,0x88,0x88,0x88,0x88,0xA8,0xF8,
+  0x05,0x0A,0x0A,0x06,0x00,0xFE,0x20,0x50,0x50,0x50,0x50,0x88,0xA8,0xA8,0x88,0x70,
+  0x03,0x03,0x03,0x06,0x00,0x06,0x40,0xA0,0x40,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
+  0x00,0x00,0x06,0x05,0xFF,0x01,0x07,0x07,0x06,0x02,0x00,0x80,0x80,0x80,0x80,0x80,
+  0x00,0x80,0x03,0x03,0x03,0x06,0x01,0x05,0xA0,0xA0,0xA0,0x05,0x06,0x06,0x06,0x00,
+  0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x05,0x09,0x09,0x06,0x00,0xFF,0x20,0x70,0xA8,
+  0xA0,0x70,0x28,0xA8,0x70,0x20,0x05,0x07,0x07,0x06,0x00,0x00,0xC8,0xC8,0x10,0x20,
+  0x40,0x98,0x98,0x05,0x07,0x07,0x06,0x00,0x00,0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,
+  0x01,0x03,0x03,0x06,0x02,0x05,0x80,0x80,0x80,0x03,0x09,0x09,0x06,0x01,0xFF,0x20,
+  0x40,0x40,0x80,0x80,0x80,0x40,0x40,0x20,0x03,0x09,0x09,0x06,0x01,0xFF,0x80,0x40,
+  0x40,0x20,0x20,0x20,0x40,0x40,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x20,0xA8,0x70,
+  0x20,0x70,0xA8,0x20,0x05,0x05,0x05,0x06,0x00,0x01,0x20,0x20,0xF8,0x20,0x20,0x02,
+  0x03,0x03,0x06,0x01,0xFF,0xC0,0x40,0x80,0x05,0x01,0x01,0x06,0x00,0x03,0xF8,0x02,
+  0x02,0x02,0x06,0x01,0x00,0xC0,0xC0,0x05,0x07,0x07,0x06,0x00,0x00,0x08,0x10,0x10,
+  0x20,0x40,0x40,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x98,0xA8,0xC8,0x88,
+  0x70,0x03,0x07,0x07,0x06,0x01,0x00,0x40,0xC0,0x40,0x40,0x40,0x40,0xE0,0x05,0x07,
+  0x07,0x06,0x00,0x00,0x70,0x88,0x08,0x10,0x20,0x40,0xF8,0x05,0x07,0x07,0x06,0x00,
+  0x00,0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x10,0x30,
+  0x50,0x90,0xF8,0x10,0x10,0x05,0x07,0x07,0x06,0x00,0x00,0xF8,0x80,0xF0,0x08,0x08,
+  0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x30,0x40,0x80,0xF0,0x88,0x88,0x70,0x05,
+  0x07,0x07,0x06,0x00,0x00,0xF8,0x08,0x10,0x10,0x20,0x20,0x20,0x05,0x07,0x07,0x06,
+  0x00,0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x70,
+  0x88,0x88,0x78,0x08,0x10,0x60,0x02,0x05,0x05,0x06,0x01,0x00,0xC0,0xC0,0x00,0xC0,
+  0xC0,0x02,0x06,0x06,0x06,0x01,0xFF,0xC0,0xC0,0x00,0xC0,0x40,0x80,0x03,0x05,0x05,
+  0x06,0x01,0x01,0x20,0x40,0x80,0x40,0x20,0x05,0x03,0x03,0x06,0x00,0x02,0xF8,0x00,
+  0xF8,0x03,0x05,0x05,0x06,0x01,0x01,0x80,0x40,0x20,0x40,0x80,0x05,0x07,0x07,0x06,
+  0x00,0x00,0x70,0x88,0x10,0x20,0x20,0x00,0x20,0x05,0x07,0x07,0x06,0x00,0x00,0x70,
+  0x88,0xB8,0xA8,0xB8,0x80,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x88,0xF8,
+  0x88,0x88,0x88,0x05,0x07,0x07,0x06,0x00,0x00,0xF0,0x48,0x48,0x70,0x48,0x48,0xF0,
+  0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x05,0x07,0x07,
+  0x06,0x00,0x00,0xF0,0x48,0x48,0x48,0x48,0x48,0xF0,0x05,0x07,0x07,0x06,0x00,0x00,
+  0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x05,0x07,0x07,0x06,0x00,0x00,0xF8,0x80,0x80,
+  0xF0,0x80,0x80,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x80,0x80,0x98,0x88,
+  0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x03,0x07,
+  0x07,0x06,0x01,0x00,0xE0,0x40,0x40,0x40,0x40,0x40,0xE0,0x05,0x07,0x07,0x06,0x00,
+  0x00,0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x90,
+  0xA0,0xC0,0xA0,0x90,0x88,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x80,0x80,0x80,0x80,
+  0x80,0xF8,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0xD8,0xA8,0x88,0x88,0x88,0x88,0x05,
+  0x07,0x07,0x06,0x00,0x00,0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x05,0x07,0x07,0x06,
+  0x00,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0xF0,
+  0x88,0x88,0xF0,0x80,0x80,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x88,0x88,
+  0xA8,0x90,0x68,0x05,0x07,0x07,0x06,0x00,0x00,0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,
+  0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x05,0x07,0x07,
+  0x06,0x00,0x00,0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x05,0x07,0x07,0x06,0x00,0x00,
+  0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x88,
+  0x88,0x50,0x50,0x20,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x88,0x88,0xA8,0xA8,
+  0x50,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x05,0x07,
+  0x07,0x06,0x00,0x00,0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x05,0x07,0x07,0x06,0x00,
+  0x00,0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x03,0x09,0x09,0x06,0x01,0xFF,0xE0,0x80,
+  0x80,0x80,0x80,0x80,0x80,0x80,0xE0,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x40,0x40,
+  0x20,0x10,0x10,0x08,0x03,0x09,0x09,0x06,0x01,0xFF,0xE0,0x20,0x20,0x20,0x20,0x20,
+  0x20,0x20,0xE0,0x05,0x03,0x03,0x06,0x00,0x05,0x20,0x50,0x88,0x05,0x01,0x01,0x06,
+  0x00,0xFE,0xF8,0x03,0x03,0x03,0x06,0x01,0x05,0x80,0x40,0x20,0x05,0x05,0x05,0x06,
+  0x00,0x00,0x70,0x08,0x78,0x88,0x78,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x80,0xF0,
+  0x88,0x88,0x88,0xF0,0x05,0x05,0x05,0x06,0x00,0x00,0x70,0x80,0x80,0x88,0x70,0x05,
+  0x07,0x07,0x06,0x00,0x00,0x08,0x08,0x78,0x88,0x88,0x88,0x78,0x05,0x05,0x05,0x06,
+  0x00,0x00,0x70,0x88,0xF0,0x80,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x30,0x48,0x40,
+  0xE0,0x40,0x40,0x40,0x05,0x07,0x07,0x06,0x00,0xFE,0x70,0x88,0x88,0x88,0x78,0x08,
+  0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x88,0x03,0x07,
+  0x07,0x06,0x01,0x00,0x40,0x00,0xC0,0x40,0x40,0x40,0xE0,0x04,0x09,0x09,0x06,0x01,
+  0xFE,0x10,0x00,0x30,0x10,0x10,0x10,0x10,0x90,0x60,0x05,0x07,0x07,0x06,0x00,0x00,
+  0x80,0x80,0x88,0x90,0xE0,0x90,0x88,0x03,0x07,0x07,0x06,0x01,0x00,0xC0,0x40,0x40,
+  0x40,0x40,0x40,0xE0,0x05,0x05,0x05,0x06,0x00,0x00,0xD0,0xA8,0xA8,0xA8,0xA8,0x05,
+  0x05,0x05,0x06,0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x05,0x05,0x05,0x06,0x00,0x00,
+  0x70,0x88,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0xFE,0xF0,0x88,0x88,0x88,0xF0,
+  0x80,0x80,0x05,0x07,0x07,0x06,0x00,0xFE,0x78,0x88,0x88,0x88,0x78,0x08,0x08,0x05,
+  0x05,0x05,0x06,0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x05,0x05,0x05,0x06,0x00,0x00,
+  0x78,0x80,0x70,0x08,0xF0,0x05,0x07,0x07,0x06,0x00,0x00,0x20,0x20,0xF8,0x20,0x20,
+  0x20,0x18,0x05,0x05,0x05,0x06,0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x05,0x05,0x05,
+  0x06,0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x05,0x05,0x05,0x06,0x00,0x00,0x88,0x88,
+  0xA8,0xA8,0x50,0x05,0x05,0x05,0x06,0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x05,0x07,
+  0x07,0x06,0x00,0xFE,0x88,0x88,0x88,0x50,0x20,0x40,0x80,0x05,0x05,0x05,0x06,0x00,
+  0x00,0xF8,0x10,0x20,0x40,0xF8,0x03,0x09,0x09,0x06,0x01,0xFF,0x20,0x40,0x40,0x40,
+  0x80,0x40,0x40,0x40,0x20,0x01,0x09,0x09,0x06,0x02,0xFF,0x80,0x80,0x80,0x80,0x80,
+  0x80,0x80,0x80,0x80,0x03,0x09,0x09,0x06,0x01,0xFF,0x80,0x40,0x40,0x40,0x20,0x40,
+  0x40,0x40,0x80,0x05,0x03,0x03,0x06,0x00,0x02,0x48,0xA8,0x90,0xFF
+};
+
+#else // !STM32_NOT_EXTENDED_ISO10646_1_5X7
+
+  // extended (original) font (symbols 1 - 255)
+
+/*
+  Fontname: -Marlin6x12-Fixed-Medium-R-SemiCondensed--12-90-100-100-C-111-ISO10646-1
+  Copyright: Public domain terminal emulator font.  Share and enjoy. original font -Misc-Fixed-Medium-R-SemiCondensed--12-110-75-75-C-60-ISO10646-1
+  Capital A Height: 7, '1' Height: 7
+  Calculated Max Values w= 6 h=10 x= 5 y= 7 dx= 6 dy= 0 ascent=10 len=10
+  Font Bounding box     w=12 h=13 x= 0 y=-2
+  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0
+  Pure Font   ascent = 7 descent=-2
+  X Font      ascent = 8 descent=-2
+  Max Font    ascent =10 descent=-2
+*/
+extern const uint8_t ISO10646_1_5x7[2648] = {
+  0x00,0x0C,0x0D,0x00,0xFE,0x07,0x02,0x26,0x03,0xBC,0x01,0xFF,0xFE,0x0A,0xFE,0x08,
+  0xFE,0x05,0x08,0x08,0x06,0x00,0x00,0x40,0xF0,0xC8,0x88,0x88,0x98,0x78,0x10,0x05,
+  0x08,0x08,0x06,0x00,0x00,0xC0,0xF8,0x88,0x88,0x88,0x88,0x88,0xF8,0x05,0x05,0x05,
+  0x06,0x00,0x01,0x20,0x30,0xF8,0x30,0x20,0x05,0x08,0x08,0x06,0x00,0x00,0x20,0x70,
+  0xF8,0x20,0x20,0x20,0x20,0xE0,0x05,0x09,0x09,0x06,0x00,0xFF,0x20,0x70,0xA8,0xA8,
+  0xB8,0x88,0x88,0x70,0x20,0x07,0x06,0x06,0x08,0x00,0x01,0xE0,0x8C,0xEA,0x8C,0x8A,
+  0x0A,0x05,0x09,0x09,0x06,0x00,0xFF,0xF8,0xA8,0x88,0x88,0x88,0x88,0x88,0xA8,0xF8,
+  0x05,0x0A,0x0A,0x06,0x00,0xFE,0x20,0x50,0x50,0x50,0x50,0x88,0xA8,0xA8,0x88,0x70,
+  0x03,0x03,0x03,0x06,0x00,0x06,0x40,0xA0,0x40,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
+  0x00,0x00,0x06,0x05,0xFF,0x01,0x07,0x07,0x06,0x02,0x00,0x80,0x80,0x80,0x80,0x80,
+  0x00,0x80,0x03,0x03,0x03,0x06,0x01,0x05,0xA0,0xA0,0xA0,0x05,0x06,0x06,0x06,0x00,
+  0x00,0x50,0xF8,0x50,0x50,0xF8,0x50,0x05,0x09,0x09,0x06,0x00,0xFF,0x20,0x70,0xA8,
+  0xA0,0x70,0x28,0xA8,0x70,0x20,0x05,0x07,0x07,0x06,0x00,0x00,0xC8,0xC8,0x10,0x20,
+  0x40,0x98,0x98,0x05,0x07,0x07,0x06,0x00,0x00,0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,
+  0x01,0x03,0x03,0x06,0x02,0x05,0x80,0x80,0x80,0x03,0x09,0x09,0x06,0x01,0xFF,0x20,
+  0x40,0x40,0x80,0x80,0x80,0x40,0x40,0x20,0x03,0x09,0x09,0x06,0x01,0xFF,0x80,0x40,
+  0x40,0x20,0x20,0x20,0x40,0x40,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x20,0xA8,0x70,
+  0x20,0x70,0xA8,0x20,0x05,0x05,0x05,0x06,0x00,0x01,0x20,0x20,0xF8,0x20,0x20,0x02,
+  0x03,0x03,0x06,0x01,0xFF,0xC0,0x40,0x80,0x05,0x01,0x01,0x06,0x00,0x03,0xF8,0x02,
+  0x02,0x02,0x06,0x01,0x00,0xC0,0xC0,0x05,0x07,0x07,0x06,0x00,0x00,0x08,0x10,0x10,
+  0x20,0x40,0x40,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x98,0xA8,0xC8,0x88,
+  0x70,0x03,0x07,0x07,0x06,0x01,0x00,0x40,0xC0,0x40,0x40,0x40,0x40,0xE0,0x05,0x07,
+  0x07,0x06,0x00,0x00,0x70,0x88,0x08,0x10,0x20,0x40,0xF8,0x05,0x07,0x07,0x06,0x00,
+  0x00,0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x10,0x30,
+  0x50,0x90,0xF8,0x10,0x10,0x05,0x07,0x07,0x06,0x00,0x00,0xF8,0x80,0xF0,0x08,0x08,
+  0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x30,0x40,0x80,0xF0,0x88,0x88,0x70,0x05,
+  0x07,0x07,0x06,0x00,0x00,0xF8,0x08,0x10,0x10,0x20,0x20,0x20,0x05,0x07,0x07,0x06,
+  0x00,0x00,0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x70,
+  0x88,0x88,0x78,0x08,0x10,0x60,0x02,0x05,0x05,0x06,0x01,0x00,0xC0,0xC0,0x00,0xC0,
+  0xC0,0x02,0x06,0x06,0x06,0x01,0xFF,0xC0,0xC0,0x00,0xC0,0x40,0x80,0x03,0x05,0x05,
+  0x06,0x01,0x01,0x20,0x40,0x80,0x40,0x20,0x05,0x03,0x03,0x06,0x00,0x02,0xF8,0x00,
+  0xF8,0x03,0x05,0x05,0x06,0x01,0x01,0x80,0x40,0x20,0x40,0x80,0x05,0x07,0x07,0x06,
+  0x00,0x00,0x70,0x88,0x10,0x20,0x20,0x00,0x20,0x05,0x07,0x07,0x06,0x00,0x00,0x70,
+  0x88,0xB8,0xA8,0xB8,0x80,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x88,0xF8,
+  0x88,0x88,0x88,0x05,0x07,0x07,0x06,0x00,0x00,0xF0,0x48,0x48,0x70,0x48,0x48,0xF0,
+  0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x05,0x07,0x07,
+  0x06,0x00,0x00,0xF0,0x48,0x48,0x48,0x48,0x48,0xF0,0x05,0x07,0x07,0x06,0x00,0x00,
+  0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x05,0x07,0x07,0x06,0x00,0x00,0xF8,0x80,0x80,
+  0xF0,0x80,0x80,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x80,0x80,0x98,0x88,
+  0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x03,0x07,
+  0x07,0x06,0x01,0x00,0xE0,0x40,0x40,0x40,0x40,0x40,0xE0,0x05,0x07,0x07,0x06,0x00,
+  0x00,0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x90,
+  0xA0,0xC0,0xA0,0x90,0x88,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x80,0x80,0x80,0x80,
+  0x80,0xF8,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0xD8,0xA8,0x88,0x88,0x88,0x88,0x05,
+  0x07,0x07,0x06,0x00,0x00,0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x05,0x07,0x07,0x06,
+  0x00,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0xF0,
+  0x88,0x88,0xF0,0x80,0x80,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x88,0x88,
+  0xA8,0x90,0x68,0x05,0x07,0x07,0x06,0x00,0x00,0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,
+  0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x05,0x07,0x07,
+  0x06,0x00,0x00,0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0x05,0x07,0x07,0x06,0x00,0x00,
+  0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x88,
+  0x88,0x50,0x50,0x20,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x88,0x88,0xA8,0xA8,
+  0x50,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x05,0x07,
+  0x07,0x06,0x00,0x00,0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x05,0x07,0x07,0x06,0x00,
+  0x00,0xF8,0x08,0x10,0x20,0x40,0x80,0xF8,0x03,0x09,0x09,0x06,0x01,0xFF,0xE0,0x80,
+  0x80,0x80,0x80,0x80,0x80,0x80,0xE0,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x40,0x40,
+  0x20,0x10,0x10,0x08,0x03,0x09,0x09,0x06,0x01,0xFF,0xE0,0x20,0x20,0x20,0x20,0x20,
+  0x20,0x20,0xE0,0x05,0x03,0x03,0x06,0x00,0x05,0x20,0x50,0x88,0x05,0x01,0x01,0x06,
+  0x00,0xFE,0xF8,0x03,0x03,0x03,0x06,0x01,0x05,0x80,0x40,0x20,0x05,0x05,0x05,0x06,
+  0x00,0x00,0x70,0x08,0x78,0x88,0x78,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x80,0xF0,
+  0x88,0x88,0x88,0xF0,0x05,0x05,0x05,0x06,0x00,0x00,0x70,0x80,0x80,0x88,0x70,0x05,
+  0x07,0x07,0x06,0x00,0x00,0x08,0x08,0x78,0x88,0x88,0x88,0x78,0x05,0x05,0x05,0x06,
+  0x00,0x00,0x70,0x88,0xF0,0x80,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x30,0x48,0x40,
+  0xE0,0x40,0x40,0x40,0x05,0x07,0x07,0x06,0x00,0xFE,0x70,0x88,0x88,0x88,0x78,0x08,
+  0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x88,0x03,0x07,
+  0x07,0x06,0x01,0x00,0x40,0x00,0xC0,0x40,0x40,0x40,0xE0,0x04,0x09,0x09,0x06,0x01,
+  0xFE,0x10,0x00,0x30,0x10,0x10,0x10,0x10,0x90,0x60,0x05,0x07,0x07,0x06,0x00,0x00,
+  0x80,0x80,0x88,0x90,0xE0,0x90,0x88,0x03,0x07,0x07,0x06,0x01,0x00,0xC0,0x40,0x40,
+  0x40,0x40,0x40,0xE0,0x05,0x05,0x05,0x06,0x00,0x00,0xD0,0xA8,0xA8,0xA8,0xA8,0x05,
+  0x05,0x05,0x06,0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x05,0x05,0x05,0x06,0x00,0x00,
+  0x70,0x88,0x88,0x88,0x70,0x05,0x07,0x07,0x06,0x00,0xFE,0xF0,0x88,0x88,0x88,0xF0,
+  0x80,0x80,0x05,0x07,0x07,0x06,0x00,0xFE,0x78,0x88,0x88,0x88,0x78,0x08,0x08,0x05,
+  0x05,0x05,0x06,0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x05,0x05,0x05,0x06,0x00,0x00,
+  0x78,0x80,0x70,0x08,0xF0,0x05,0x07,0x07,0x06,0x00,0x00,0x20,0x20,0xF8,0x20,0x20,
+  0x20,0x18,0x05,0x05,0x05,0x06,0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x05,0x05,0x05,
+  0x06,0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x05,0x05,0x05,0x06,0x00,0x00,0x88,0x88,
+  0xA8,0xA8,0x50,0x05,0x05,0x05,0x06,0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x05,0x07,
+  0x07,0x06,0x00,0xFE,0x88,0x88,0x88,0x50,0x20,0x40,0x80,0x05,0x05,0x05,0x06,0x00,
+  0x00,0xF8,0x10,0x20,0x40,0xF8,0x03,0x09,0x09,0x06,0x01,0xFF,0x20,0x40,0x40,0x40,
+  0x80,0x40,0x40,0x40,0x20,0x01,0x09,0x09,0x06,0x02,0xFF,0x80,0x80,0x80,0x80,0x80,
+  0x80,0x80,0x80,0x80,0x03,0x09,0x09,0x06,0x01,0xFF,0x80,0x40,0x40,0x40,0x20,0x40,
+  0x40,0x40,0x80,0x05,0x03,0x03,0x06,0x00,0x02,0x48,0xA8,0x90,0xFF,0xFF,0xFF,0xFF,
+  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
+  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,
+  0x06,0x05,0xFF,0x01,0x07,0x07,0x06,0x02,0x00,0x80,0x00,0x80,0x80,0x80,0x80,0x80,
+  0x05,0x07,0x07,0x06,0x00,0xFF,0x20,0x70,0xA8,0xA0,0xA8,0x70,0x20,0x05,0x07,0x07,
+  0x06,0x00,0x00,0x30,0x48,0x40,0xE0,0x40,0x48,0xB0,0x05,0x05,0x05,0x06,0x00,0x00,
+  0xA8,0x50,0x88,0x50,0xA8,0x05,0x07,0x07,0x06,0x00,0x00,0x88,0x50,0xF8,0x20,0xF8,
+  0x20,0x20,0x01,0x07,0x07,0x06,0x02,0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x04,
+  0x08,0x08,0x06,0x01,0x00,0x70,0x80,0x60,0x90,0x90,0x60,0x10,0xE0,0x03,0x01,0x01,
+  0x06,0x01,0x07,0xA0,0x06,0x07,0x07,0x06,0x00,0x00,0x78,0x84,0xB4,0xA4,0xB4,0x84,
+  0x78,0x03,0x05,0x05,0x06,0x01,0x04,0x60,0xA0,0x60,0x00,0xE0,0x05,0x05,0x05,0x06,
+  0x00,0x00,0x28,0x50,0xA0,0x50,0x28,0x05,0x03,0x03,0x06,0x00,0x01,0xF8,0x08,0x08,
+  0x03,0x01,0x01,0x06,0x01,0x03,0xE0,0x06,0x07,0x07,0x06,0x00,0x00,0x78,0x84,0xB4,
+  0xA4,0xA4,0x84,0x78,0x05,0x01,0x01,0x06,0x00,0x07,0xF8,0x04,0x04,0x04,0x06,0x01,
+  0x05,0x60,0x90,0x90,0x60,0x05,0x07,0x07,0x06,0x00,0x00,0x20,0x20,0xF8,0x20,0x20,
+  0x00,0xF8,0x03,0x05,0x05,0x06,0x01,0x04,0x40,0xA0,0x20,0x40,0xE0,0x03,0x05,0x05,
+  0x06,0x01,0x04,0xC0,0x20,0x40,0x20,0xC0,0x03,0x03,0x03,0x06,0x01,0x05,0x20,0x40,
+  0x80,0x05,0x07,0x07,0x06,0x00,0xFE,0x88,0x88,0x88,0x98,0xE8,0x80,0x80,0x05,0x08,
+  0x08,0x06,0x00,0x00,0x78,0xE8,0xE8,0xE8,0x68,0x28,0x28,0x28,0x02,0x02,0x02,0x06,
+  0x02,0x03,0xC0,0xC0,0x03,0x02,0x02,0x06,0x01,0xFE,0x20,0xC0,0x03,0x05,0x05,0x06,
+  0x01,0x04,0x40,0xC0,0x40,0x40,0xE0,0x03,0x05,0x05,0x06,0x01,0x05,0x40,0xA0,0x40,
+  0x00,0xE0,0x05,0x05,0x05,0x06,0x00,0x00,0xA0,0x50,0x28,0x50,0xA0,0x05,0x0A,0x0A,
+  0x06,0x00,0x00,0x40,0xC0,0x48,0x50,0x60,0x50,0xB0,0x50,0x78,0x10,0x05,0x0A,0x0A,
+  0x06,0x00,0x00,0x40,0xC0,0x48,0x50,0x60,0x50,0xA8,0x08,0x10,0x38,0x05,0x0A,0x0A,
+  0x06,0x00,0x00,0xC0,0x20,0x48,0x30,0xE0,0x50,0xB0,0x50,0x78,0x10,0x05,0x07,0x07,
+  0x06,0x00,0x00,0x20,0x00,0x20,0x20,0x40,0x88,0x70,0x05,0x0A,0x0A,0x06,0x00,0x00,
+  0x40,0x20,0x00,0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x05,0x0A,0x0A,0x06,0x00,0x00,
+  0x10,0x20,0x00,0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x05,0x0A,0x0A,0x06,0x00,0x00,
+  0x20,0x50,0x00,0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x05,0x0A,0x0A,0x06,0x00,0x00,
+  0x68,0xB0,0x00,0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x05,0x09,0x09,0x06,0x00,0x00,
+  0x50,0x00,0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x05,0x0A,0x0A,0x06,0x00,0x00,0x20,
+  0x50,0x20,0x70,0x88,0x88,0xF8,0x88,0x88,0x88,0x05,0x07,0x07,0x06,0x00,0x00,0x78,
+  0xA0,0xA0,0xF0,0xA0,0xA0,0xB8,0x05,0x09,0x09,0x06,0x00,0xFE,0x70,0x88,0x80,0x80,
+  0x80,0x88,0x70,0x10,0x60,0x05,0x0A,0x0A,0x06,0x00,0x00,0x40,0x20,0x00,0xF8,0x80,
+  0x80,0xF0,0x80,0x80,0xF8,0x05,0x0A,0x0A,0x06,0x00,0x00,0x10,0x20,0x00,0xF8,0x80,
+  0x80,0xF0,0x80,0x80,0xF8,0x05,0x0A,0x0A,0x06,0x00,0x00,0x20,0x50,0x00,0xF8,0x80,
+  0x80,0xF0,0x80,0x80,0xF8,0x05,0x09,0x09,0x06,0x00,0x00,0x50,0x00,0xF8,0x80,0x80,
+  0xF0,0x80,0x80,0xF8,0x03,0x0A,0x0A,0x06,0x01,0x00,0x80,0x40,0x00,0xE0,0x40,0x40,
+  0x40,0x40,0x40,0xE0,0x03,0x0A,0x0A,0x06,0x01,0x00,0x20,0x40,0x00,0xE0,0x40,0x40,
+  0x40,0x40,0x40,0xE0,0x03,0x0A,0x0A,0x06,0x01,0x00,0x40,0xA0,0x00,0xE0,0x40,0x40,
+  0x40,0x40,0x40,0xE0,0x03,0x09,0x09,0x06,0x01,0x00,0xA0,0x00,0xE0,0x40,0x40,0x40,
+  0x40,0x40,0xE0,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x48,0x48,0xE8,0x48,0x48,0x70,
+  0x05,0x0A,0x0A,0x06,0x00,0x00,0x68,0xB0,0x00,0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,
+  0x05,0x0A,0x0A,0x06,0x00,0x00,0x40,0x20,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,
+  0x05,0x0A,0x0A,0x06,0x00,0x00,0x10,0x20,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,
+  0x05,0x0A,0x0A,0x06,0x00,0x00,0x20,0x50,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,
+  0x05,0x0A,0x0A,0x06,0x00,0x00,0x68,0xB0,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,
+  0x05,0x09,0x09,0x06,0x00,0x00,0x50,0x00,0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x05,
+  0x05,0x05,0x06,0x00,0x01,0x88,0x50,0x20,0x50,0x88,0x05,0x09,0x09,0x06,0x00,0xFF,
+  0x08,0x70,0x98,0xA8,0xA8,0xA8,0xC8,0x70,0x80,0x05,0x0A,0x0A,0x06,0x00,0x00,0x40,
+  0x20,0x00,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x0A,0x0A,0x06,0x00,0x00,0x10,
+  0x20,0x00,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x0A,0x0A,0x06,0x00,0x00,0x20,
+  0x50,0x00,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x09,0x09,0x06,0x00,0x00,0x50,
+  0x00,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x05,0x0A,0x0A,0x06,0x00,0x00,0x10,0x20,
+  0x00,0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x04,0x07,0x07,0x06,0x01,0x00,0x80,0xE0,
+  0x90,0x90,0x90,0xE0,0x80,0x05,0x07,0x07,0x06,0x00,0x00,0x70,0x88,0x90,0xA0,0x90,
+  0x88,0xB0,0x05,0x08,0x08,0x06,0x00,0x00,0x40,0x20,0x00,0x70,0x08,0x78,0x88,0x78,
+  0x05,0x08,0x08,0x06,0x00,0x00,0x10,0x20,0x00,0x70,0x08,0x78,0x88,0x78,0x05,0x08,
+  0x08,0x06,0x00,0x00,0x20,0x50,0x00,0x70,0x08,0x78,0x88,0x78,0x05,0x08,0x08,0x06,
+  0x00,0x00,0x68,0xB0,0x00,0x70,0x08,0x78,0x88,0x78,0x05,0x07,0x07,0x06,0x00,0x00,
+  0x50,0x00,0x70,0x08,0x78,0x88,0x78,0x05,0x08,0x08,0x06,0x00,0x00,0x20,0x50,0x20,
+  0x70,0x08,0x78,0x88,0x78,0x05,0x05,0x05,0x06,0x00,0x00,0x70,0x28,0x70,0xA0,0x78,
+  0x05,0x07,0x07,0x06,0x00,0xFE,0x70,0x88,0x80,0x88,0x70,0x10,0x60,0x05,0x08,0x08,
+  0x06,0x00,0x00,0x40,0x20,0x00,0x70,0x88,0xF0,0x80,0x70,0x05,0x08,0x08,0x06,0x00,
+  0x00,0x10,0x20,0x00,0x70,0x88,0xF0,0x80,0x70,0x05,0x08,0x08,0x06,0x00,0x00,0x20,
+  0x50,0x00,0x70,0x88,0xF0,0x80,0x70,0x05,0x07,0x07,0x06,0x00,0x00,0x50,0x00,0x70,
+  0x88,0xF0,0x80,0x70,0x03,0x08,0x08,0x06,0x01,0x00,0x80,0x40,0x00,0xC0,0x40,0x40,
+  0x40,0xE0,0x03,0x08,0x08,0x06,0x01,0x00,0x20,0x40,0x00,0xC0,0x40,0x40,0x40,0xE0,
+  0x03,0x08,0x08,0x06,0x01,0x00,0x40,0xA0,0x00,0xC0,0x40,0x40,0x40,0xE0,0x03,0x07,
+  0x07,0x06,0x01,0x00,0xA0,0x00,0xC0,0x40,0x40,0x40,0xE0,0x05,0x09,0x09,0x06,0x00,
+  0x00,0x50,0x20,0x50,0x08,0x78,0x88,0x88,0x88,0x70,0x05,0x08,0x08,0x06,0x00,0x00,
+  0x68,0xB0,0x00,0xB0,0xC8,0x88,0x88,0x88,0x05,0x08,0x08,0x06,0x00,0x00,0x40,0x20,
+  0x00,0x70,0x88,0x88,0x88,0x70,0x05,0x08,0x08,0x06,0x00,0x00,0x10,0x20,0x00,0x70,
+  0x88,0x88,0x88,0x70,0x05,0x08,0x08,0x06,0x00,0x00,0x20,0x50,0x00,0x70,0x88,0x88,
+  0x88,0x70,0x05,0x08,0x08,0x06,0x00,0x00,0x68,0xB0,0x00,0x70,0x88,0x88,0x88,0x70,
+  0x05,0x07,0x07,0x06,0x00,0x00,0x50,0x00,0x70,0x88,0x88,0x88,0x70,0x05,0x05,0x05,
+  0x06,0x00,0x01,0x20,0x00,0xF8,0x00,0x20,0x05,0x05,0x05,0x06,0x00,0x00,0x78,0x98,
+  0xA8,0xC8,0xF0,0x05,0x08,0x08,0x06,0x00,0x00,0x40,0x20,0x00,0x88,0x88,0x88,0x88,
+  0x70,0x05,0x08,0x08,0x06,0x00,0x00,0x10,0x20,0x00,0x88,0x88,0x88,0x88,0x70,0x05,
+  0x08,0x08,0x06,0x00,0x00,0x20,0x50,0x00,0x88,0x88,0x88,0x88,0x70,0x05,0x07,0x07,
+  0x06,0x00,0x00,0x50,0x00,0x88,0x88,0x88,0x88,0x70,0x05,0x0A,0x0A,0x06,0x00,0xFE,
+  0x10,0x20,0x00,0x88,0x88,0x88,0x50,0x20,0x40,0x80,0x05,0x09,0x09,0x06,0x00,0xFE,
+  0x80,0x80,0xF0,0x88,0x88,0x88,0xF0,0x80,0x80,0x05,0x09,0x09,0x06,0x00,0xFE,0x50,
+  0x00,0x88,0x88,0x88,0x50,0x20,0x40,0x80
+};
+
+#endif // !STM32_NOT_EXTENDED_ISO10646_1_5X7
+
+#endif // HAS_GRAPHICAL_TFT
diff --git a/Marlin/src/lcd/tft/fontdata/helvetica_12_bold.cpp b/Marlin/src/lcd/tft/fontdata/helvetica_12_bold.cpp
new file mode 100644
index 0000000000..e7411ea9ed
--- /dev/null
+++ b/Marlin/src/lcd/tft/fontdata/helvetica_12_bold.cpp
@@ -0,0 +1,305 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+  Fontname: Helvetica
+  Copyright: Copyright (c) 1984, 1987 Adobe Systems Incorporated. All Rights Reserved. Copyright (c) 1988, 1991 Digital Equipment Corporation. All Rights Reserved.
+  Capital A Height: 12, '1' Height: 12
+  Calculated Max Values w=14 h=17 x= 2 y=10 dx=16 dy= 0 ascent=14 len=32
+  Font Bounding box     w=16 h=17 x= 0 y=-4
+  Calculated Min Values           x= 0 y=-4 dx= 0 dy= 0
+  Pure Font   ascent =12 descent=-4
+  X Font      ascent =12 descent=-4
+  Max Font    ascent =14 descent=-4
+*/
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include <stdint.h>
+
+extern const uint8_t Helvetica12Bold[4172] = {
+  0,16,17,0,252,12,2,74,5,106,32,255,252,14,252,12,
+  252,0,0,0,5,0,0,2,12,12,6,2,0,192,192,192,
+  192,192,192,192,192,192,0,192,192,5,4,4,8,1,8,216,
+  216,216,72,9,12,24,9,0,0,27,0,27,0,27,0,127,
+  128,127,128,54,0,54,0,255,0,255,0,108,0,108,0,108,
+  0,7,14,14,9,1,255,16,124,254,214,208,240,120,60,30,
+  22,214,254,124,16,13,12,24,14,0,0,48,64,120,128,204,
+  128,205,0,121,0,50,0,2,96,4,240,5,152,9,152,8,
+  240,16,96,10,12,24,12,1,0,60,0,126,0,102,0,102,
+  0,60,0,56,192,125,192,207,128,199,0,199,0,127,128,57,
+  192,2,4,4,4,1,8,192,192,192,64,4,15,15,6,1,
+  253,48,112,96,192,192,192,192,192,192,192,192,192,96,112,48,
+  4,15,15,6,0,253,192,224,96,48,48,48,48,48,48,48,
+  48,48,96,224,192,5,5,5,6,0,7,32,168,112,112,136,
+  8,8,8,10,1,0,24,24,24,255,255,24,24,24,2,5,
+  5,4,1,253,192,192,64,64,128,4,2,2,5,0,3,240,
+  240,2,2,2,4,1,0,192,192,4,12,12,5,0,0,16,
+  16,48,32,32,96,64,64,192,128,128,128,8,12,12,9,0,
+  0,60,126,231,195,195,195,195,195,195,231,126,60,5,12,12,
+  9,1,0,8,24,248,248,24,24,24,24,24,24,24,24,8,
+  12,12,9,0,0,60,126,231,195,195,7,14,28,56,112,255,
+  255,8,12,12,9,0,0,60,126,231,195,7,30,30,7,195,
+  231,126,60,8,12,12,9,0,0,14,30,54,54,102,102,198,
+  255,255,6,6,6,8,12,12,9,0,0,63,63,48,48,124,
+  126,71,3,3,231,126,60,8,12,12,9,0,0,60,126,231,
+  192,220,254,231,195,195,231,126,60,8,12,12,9,0,0,255,
+  255,6,6,12,12,24,24,24,48,48,48,8,12,12,9,0,
+  0,60,126,231,195,102,60,126,231,195,231,126,60,8,12,12,
+  9,0,0,60,126,231,195,195,231,127,59,3,231,126,60,2,
+  8,8,5,2,0,192,192,0,0,0,0,192,192,2,11,11,
+  5,2,253,192,192,0,0,0,0,192,192,64,64,128,8,8,
+  8,10,1,0,3,15,60,224,224,60,15,3,8,6,6,10,
+  1,1,255,255,0,0,255,255,8,8,8,10,1,0,192,240,
+  60,7,7,60,240,192,7,12,12,10,1,0,124,254,198,198,
+  6,14,12,24,24,0,24,24,13,14,28,16,1,254,15,192,
+  56,96,96,16,71,216,204,72,136,200,152,200,152,136,153,152,
+  201,144,70,96,96,0,56,192,15,128,11,12,24,12,0,0,
+  14,0,14,0,31,0,27,0,59,128,49,128,113,192,96,192,
+  127,192,255,224,192,96,192,96,9,12,24,11,1,0,254,0,
+  255,0,195,128,193,128,195,128,255,0,255,0,195,128,193,128,
+  195,128,255,0,254,0,10,12,24,12,1,0,31,0,63,128,
+  113,192,96,192,224,0,192,0,192,0,224,0,96,192,113,192,
+  63,128,31,0,10,12,24,12,1,0,252,0,255,0,195,128,
+  193,128,193,192,192,192,192,192,193,192,193,128,195,128,255,0,
+  252,0,8,12,12,10,1,0,255,255,192,192,192,254,254,192,
+  192,192,255,255,8,12,12,10,1,0,255,255,192,192,192,254,
+  254,192,192,192,192,192,10,12,24,12,1,0,31,0,63,128,
+  113,192,96,192,224,0,192,0,195,192,227,192,96,192,113,192,
+  63,192,30,192,10,12,24,12,1,0,192,192,192,192,192,192,
+  192,192,255,192,255,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,2,12,12,4,1,0,192,192,192,192,192,192,192,192,
+  192,192,192,192,7,12,12,9,1,0,6,6,6,6,6,6,
+  6,6,198,198,254,124,10,12,24,12,1,0,193,192,195,128,
+  199,0,206,0,220,0,248,0,252,0,206,0,199,0,195,128,
+  193,192,192,192,8,12,12,10,1,0,192,192,192,192,192,192,
+  192,192,192,192,255,255,11,12,24,13,1,0,224,224,224,224,
+  224,224,241,224,241,224,209,96,219,96,219,96,202,96,206,96,
+  206,96,196,96,10,12,24,12,1,0,224,192,240,192,240,192,
+  216,192,216,192,204,192,204,192,198,192,198,192,195,192,195,192,
+  193,192,11,12,24,13,1,0,31,0,63,128,113,192,96,192,
+  224,224,192,96,192,96,224,224,96,192,113,192,63,128,31,0,
+  9,12,24,11,1,0,254,0,255,0,195,128,193,128,193,128,
+  195,128,255,0,254,0,192,0,192,0,192,0,192,0,11,13,
+  26,13,1,255,31,0,63,128,113,192,96,192,224,224,192,96,
+  192,96,226,96,103,192,115,192,63,128,31,192,0,128,10,12,
+  24,12,1,0,255,0,255,128,193,128,193,128,195,128,255,0,
+  255,0,195,128,193,128,193,128,193,192,193,192,9,12,24,11,
+  1,0,62,0,127,0,227,128,193,128,240,0,126,0,31,0,
+  3,128,193,128,227,128,127,0,62,0,10,12,24,10,0,0,
+  255,192,255,192,12,0,12,0,12,0,12,0,12,0,12,0,
+  12,0,12,0,12,0,12,0,10,12,24,12,1,0,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  225,192,127,128,63,0,10,12,24,11,0,0,192,192,192,192,
+  97,128,97,128,97,128,51,0,51,0,51,0,30,0,30,0,
+  12,0,12,0,14,12,24,15,0,0,195,12,195,12,195,12,
+  99,24,103,152,103,152,52,176,60,240,60,240,24,96,24,96,
+  24,96,9,12,24,11,1,0,193,128,227,128,99,0,54,0,
+  62,0,28,0,28,0,62,0,54,0,99,0,227,128,193,128,
+  10,12,24,11,0,0,192,192,225,192,97,128,51,0,51,0,
+  30,0,30,0,12,0,12,0,12,0,12,0,12,0,8,12,
+  12,10,1,0,255,255,7,6,12,28,56,48,96,224,255,255,
+  4,15,15,6,1,253,240,240,192,192,192,192,192,192,192,192,
+  192,192,192,240,240,4,12,12,5,0,0,128,128,192,64,64,
+  96,32,32,48,16,16,16,4,15,15,6,0,253,240,240,48,
+  48,48,48,48,48,48,48,48,48,48,240,240,8,7,7,10,
+  1,5,24,24,60,102,102,195,195,9,1,2,9,0,253,255,
+  128,3,3,3,6,2,10,128,192,32,8,9,9,9,1,0,
+  124,254,198,14,126,230,198,254,119,8,12,12,10,1,0,192,
+  192,192,220,254,231,195,195,195,231,254,220,8,9,9,9,1,
+  0,60,126,231,192,192,192,231,126,60,8,12,12,10,1,0,
+  3,3,3,63,127,231,195,195,195,231,127,59,8,9,9,10,
+  1,0,60,126,195,255,255,192,231,126,60,4,12,12,6,1,
+  0,48,112,96,240,240,96,96,96,96,96,96,96,8,13,13,
+  10,1,252,59,127,231,195,195,195,231,127,59,3,231,126,60,
+  8,12,12,10,1,0,192,192,192,222,255,227,195,195,195,195,
+  195,195,2,12,12,4,1,0,192,192,0,192,192,192,192,192,
+  192,192,192,192,3,16,16,5,1,252,96,96,0,96,96,96,
+  96,96,96,96,96,96,96,96,224,192,8,12,12,9,1,0,
+  192,192,192,199,206,220,248,252,236,206,198,199,2,12,12,4,
+  1,0,192,192,192,192,192,192,192,192,192,192,192,192,12,9,
+  18,14,1,0,222,224,255,240,231,48,198,48,198,48,198,48,
+  198,48,198,48,198,48,8,9,9,10,1,0,222,255,227,195,
+  195,195,195,195,195,8,9,9,10,1,0,60,126,231,195,195,
+  195,231,126,60,8,13,13,10,1,252,220,254,231,195,195,195,
+  231,254,220,192,192,192,192,8,13,13,10,1,252,59,127,231,
+  195,195,195,231,127,59,3,3,3,3,5,9,9,6,1,0,
+  216,248,224,192,192,192,192,192,192,7,9,9,9,1,0,124,
+  254,198,240,124,14,198,254,124,4,11,11,6,1,0,96,96,
+  240,240,96,96,96,96,96,112,48,8,9,9,10,1,0,195,
+  195,195,195,195,195,199,255,123,8,9,9,9,0,0,195,195,
+  102,102,102,60,60,24,24,12,9,18,13,0,0,198,48,198,
+  48,102,96,102,96,111,96,63,192,57,192,25,128,25,128,7,
+  9,9,9,1,0,198,198,108,124,56,124,108,198,198,8,13,
+  13,9,0,252,195,195,99,102,54,54,60,28,24,24,24,112,
+  96,7,9,9,8,0,0,254,254,14,28,24,56,112,254,254,
+  4,15,15,6,1,253,48,112,96,96,96,96,96,192,96,96,
+  96,96,96,112,48,1,16,16,4,1,252,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,128,128,128,4,15,15,6,1,
+  253,192,224,96,96,96,96,96,48,96,96,96,96,96,224,192,
+  8,3,3,10,1,3,113,153,142,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,5,0,0,2,12,12,6,1,253,192,192,0,64,64,
+  64,192,192,192,192,192,192,8,11,11,9,0,255,4,60,126,
+  239,200,216,208,247,126,60,32,8,12,12,9,0,0,28,62,
+  99,99,96,48,124,48,48,32,127,255,7,7,7,9,1,2,
+  186,124,198,198,198,124,186,8,12,12,9,0,0,195,195,102,
+  102,60,24,126,24,126,24,24,24,1,16,16,5,2,252,128,
+  128,128,128,128,128,128,0,0,128,128,128,128,128,128,128,8,
+  15,15,9,0,253,60,126,102,96,120,126,199,195,243,126,30,
+  6,102,126,60,5,2,2,6,0,10,216,216,12,12,24,12,
+  0,0,15,0,57,192,96,96,79,32,217,176,144,16,144,16,
+  217,176,79,32,96,32,57,192,15,0,5,7,7,6,1,5,
+  96,144,112,144,120,0,248,8,6,6,9,0,2,51,102,204,
+  204,102,51,8,5,5,10,0,2,255,255,3,3,3,4,2,
+  2,5,0,3,240,240,12,12,24,12,0,0,15,0,57,192,
+  96,96,95,32,217,176,153,144,158,16,219,48,91,32,96,96,
+  57,192,15,0,5,1,1,6,0,10,248,4,5,5,7,1,
+  7,96,144,144,144,96,8,11,11,10,1,0,24,24,24,255,
+  255,24,24,24,0,255,255,5,7,7,6,0,5,112,216,216,
+  48,96,248,248,5,7,7,6,0,5,112,216,24,48,24,216,
+  112,3,3,3,6,1,10,32,96,128,8,12,12,10,1,253,
+  195,195,195,195,195,195,199,255,251,192,192,192,8,15,15,9,
+  0,253,127,242,242,242,242,242,114,18,18,18,18,18,18,18,
+  18,2,2,2,5,1,4,192,192,5,4,4,6,0,252,32,
+  48,152,112,4,7,7,6,1,5,48,240,240,48,48,48,48,
+  5,7,7,6,0,5,112,216,136,216,112,0,248,8,6,6,
+  9,1,2,204,102,51,51,102,204,13,12,24,14,1,0,48,
+  192,240,128,241,128,49,0,51,48,50,112,54,240,4,176,13,
+  176,9,248,24,48,16,48,12,12,24,14,0,0,48,128,241,
+  128,241,0,51,0,50,0,54,224,53,176,13,176,8,96,24,
+  192,17,240,49,240,13,12,24,14,0,0,112,64,216,192,24,
+  128,49,128,25,48,219,112,114,240,6,176,5,176,13,248,8,
+  48,24,48,7,12,12,10,1,253,48,48,0,48,48,96,224,
+  192,198,198,254,124,11,14,28,12,0,0,4,0,0,0,14,
+  0,14,0,31,0,27,0,59,128,49,128,113,192,96,192,127,
+  192,255,224,192,96,192,96,11,14,28,12,0,0,8,0,0,
+  0,14,0,14,0,31,0,27,0,59,128,49,128,113,192,96,
+  192,127,192,255,224,192,96,192,96,11,14,28,12,0,0,17,
+  0,0,0,14,0,14,0,31,0,27,0,59,128,49,128,113,
+  192,96,192,127,192,255,224,192,96,192,96,11,14,28,12,0,
+  0,23,0,0,0,14,0,14,0,31,0,27,0,59,128,49,
+  128,113,192,96,192,127,192,255,224,192,96,192,96,11,14,28,
+  12,0,0,49,128,0,0,14,0,14,0,31,0,27,0,59,
+  128,49,128,113,192,96,192,127,192,255,224,192,96,192,96,11,
+  14,28,12,0,0,18,0,12,0,14,0,14,0,31,0,27,
+  0,59,128,49,128,113,192,96,192,127,192,255,224,192,96,192,
+  96,14,12,24,15,0,0,31,252,31,252,27,0,51,0,51,
+  0,51,248,99,248,127,0,127,0,195,0,195,252,195,252,10,
+  16,32,12,1,252,31,0,63,128,113,192,96,192,224,0,192,
+  0,192,0,224,0,96,192,113,192,63,128,31,0,4,0,6,
+  0,19,0,14,0,8,14,14,10,1,0,8,0,255,255,192,
+  192,192,254,254,192,192,192,255,255,8,14,14,10,1,0,16,
+  0,255,255,192,192,192,254,254,192,192,192,255,255,8,14,14,
+  10,1,0,34,0,255,255,192,192,192,254,254,192,192,192,255,
+  255,8,14,14,10,1,0,102,0,255,255,192,192,192,254,254,
+  192,192,192,255,255,2,14,14,4,1,0,64,0,192,192,192,
+  192,192,192,192,192,192,192,192,192,2,14,14,4,1,0,128,
+  0,192,192,192,192,192,192,192,192,192,192,192,192,5,14,14,
+  5,0,0,136,0,96,96,96,96,96,96,96,96,96,96,96,
+  96,5,14,14,5,0,0,152,0,96,96,96,96,96,96,96,
+  96,96,96,96,96,12,12,24,12,0,0,63,0,63,192,48,
+  224,48,96,48,112,252,48,252,48,48,112,48,96,48,224,63,
+  192,63,0,10,14,28,12,1,0,46,0,0,0,224,192,240,
+  192,240,192,216,192,216,192,204,192,204,192,198,192,198,192,195,
+  192,195,192,193,192,11,14,28,13,1,0,2,0,0,0,31,
+  0,63,128,113,192,96,192,224,224,192,96,192,96,224,224,96,
+  192,113,192,63,128,31,0,11,14,28,13,1,0,4,0,0,
+  0,31,0,63,128,113,192,96,192,224,224,192,96,192,96,224,
+  224,96,192,113,192,63,128,31,0,11,14,28,13,1,0,17,
+  0,0,0,31,0,63,128,113,192,96,192,224,224,192,96,192,
+  96,224,224,96,192,113,192,63,128,31,0,11,14,28,13,1,
+  0,23,0,0,0,31,0,63,128,113,192,96,192,224,224,192,
+  96,192,96,224,224,96,192,113,192,63,128,31,0,11,14,28,
+  13,1,0,25,128,0,0,31,0,63,128,113,192,96,192,224,
+  224,192,96,192,96,224,224,96,192,113,192,63,128,31,0,9,
+  9,18,10,0,0,65,0,227,128,119,0,62,0,28,0,62,
+  0,119,0,227,128,65,0,11,12,24,13,1,0,31,32,63,
+  192,112,192,97,192,227,96,198,96,204,96,216,224,112,192,97,
+  192,127,128,159,0,10,14,28,12,1,0,4,0,0,0,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,225,192,127,128,63,0,10,14,28,12,1,0,8,0,0,
+  0,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,225,192,127,128,63,0,10,14,28,12,1,0,17,
+  0,0,0,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,225,192,127,128,63,0,10,14,28,12,1,
+  0,51,0,0,0,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,225,192,127,128,63,0,10,14,28,
+  11,0,0,8,0,0,0,192,192,225,192,97,128,51,0,51,
+  0,30,0,30,0,12,0,12,0,12,0,12,0,12,0,9,
+  12,24,11,1,0,192,0,254,0,255,0,195,128,193,128,193,
+  128,195,128,255,0,254,0,192,0,192,0,192,0,8,12,12,
+  10,1,0,124,254,198,198,220,222,195,195,195,195,222,220,8,
+  13,13,9,1,0,32,48,8,0,124,254,198,14,126,230,198,
+  254,119,8,13,13,9,1,0,4,12,16,0,124,254,198,14,
+  126,230,198,254,119,8,13,13,9,1,0,16,56,68,0,124,
+  254,198,14,126,230,198,254,119,8,12,12,9,1,0,58,92,
+  0,124,254,198,14,126,230,198,254,119,8,12,12,9,1,0,
+  108,108,0,124,254,198,14,126,230,198,254,119,8,13,13,9,
+  1,0,24,36,36,24,124,254,198,14,126,230,198,254,119,13,
+  9,18,15,1,0,125,224,255,240,198,24,15,248,127,248,230,
+  0,207,56,255,240,121,224,8,13,13,9,1,252,60,126,231,
+  192,192,192,231,126,60,16,24,76,56,8,13,13,10,1,0,
+  32,48,8,0,60,126,195,255,255,192,231,126,60,8,13,13,
+  10,1,0,4,12,16,0,60,126,195,255,255,192,231,126,60,
+  8,13,13,10,1,0,8,28,34,0,60,126,195,255,255,192,
+  231,126,60,8,12,12,10,1,0,54,54,0,60,126,195,255,
+  255,192,231,126,60,3,13,13,4,0,0,128,192,32,0,96,
+  96,96,96,96,96,96,96,96,3,13,13,4,1,0,32,96,
+  128,0,192,192,192,192,192,192,192,192,192,5,13,13,5,0,
+  0,32,112,136,0,96,96,96,96,96,96,96,96,96,5,12,
+  12,5,0,0,216,216,0,96,96,96,96,96,96,96,96,96,
+  8,12,12,10,1,0,96,124,248,28,126,231,195,195,195,231,
+  126,60,8,12,12,10,1,0,58,92,0,222,255,227,195,195,
+  195,195,195,195,8,13,13,10,1,0,32,48,8,0,60,126,
+  231,195,195,195,231,126,60,8,13,13,10,1,0,8,24,32,
+  0,60,126,231,195,195,195,231,126,60,8,13,13,10,1,0,
+  16,56,68,0,60,126,231,195,195,195,231,126,60,8,12,12,
+  10,1,0,58,92,0,60,126,231,195,195,195,231,126,60,8,
+  12,12,10,1,0,108,108,0,60,126,231,195,195,195,231,126,
+  60,8,8,8,10,1,0,24,24,0,255,255,0,24,24,8,
+  9,9,10,1,0,61,127,231,207,219,243,231,254,188,8,13,
+  13,10,1,0,32,48,8,0,195,195,195,195,195,195,199,255,
+  123,8,13,13,10,1,0,8,24,32,0,195,195,195,195,195,
+  195,199,255,123,8,13,13,10,1,0,16,56,68,0,195,195,
+  195,195,195,195,199,255,123,8,12,12,10,1,0,108,108,0,
+  195,195,195,195,195,195,199,255,123,8,17,17,9,0,252,4,
+  12,16,0,195,195,99,102,54,54,60,28,24,24,24,112,96,
+  8,16,16,10,1,252,192,192,192,220,254,231,195,195,195,231,
+  254,220,192,192,192,192,8,16,16,9,0,252,54,54,0,195,
+  195,99,102,54,54,60,28,24,24,24,112,96
+};
+
+#endif // HAS_GRAPHICAL_TFT
diff --git a/Marlin/src/lcd/tft/fontdata/helvetica_14.cpp b/Marlin/src/lcd/tft/fontdata/helvetica_14.cpp
new file mode 100644
index 0000000000..87e7135e37
--- /dev/null
+++ b/Marlin/src/lcd/tft/fontdata/helvetica_14.cpp
@@ -0,0 +1,381 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/*
+  Fontname: Helvetica
+  Copyright: Copyright (c) 1984, 1987 Adobe Systems Incorporated. All Rights Reserved. Copyright (c) 1988, 1991 Digital Equipment Corporation. All Rights Reserved.
+  Capital A Height: 14, '1' Height: 13
+  Calculated Max Values w=16 h=18 x= 2 y=12 dx=18 dy= 0 ascent=16 len=36
+  Font Bounding box     w=18 h=19 x= 0 y=-4
+  Calculated Min Values           x= 0 y=-4 dx= 0 dy= 0
+  Pure Font   ascent =14 descent=-4
+  X Font      ascent =14 descent=-4
+  Max Font    ascent =16 descent=-4
+*/
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include <stdint.h>
+
+/*
+typedef struct __attribute__((__packed__)) {
+  uint8_t BBXWidth;
+  uint8_t BBXHeight;
+  uint8_t DataSize;
+   int8_t DWidth;
+   int8_t BBXOffsetX;
+   int8_t BBXOffsetY;
+} tGlyph;
+*/
+
+extern const uint8_t Helvetica14_symbols[63] = {
+  0,18,19,0,252,14,0,0,0,0,1,9,252,16,252,14,252, // tFont
+  0,0,0,0,0,0,  // 0x01 - LCD_STR_REFRESH
+  0,0,0,0,0,0,  // 0x02 - LCD_STR_FOLDER
+  255,  // 0x03 - LCD_STR_ARROW_RIGHT
+  255,  // 0x04 - LCD_STR_UPLEVEL
+  255,  // 0x05 - LCD_STR_CLOCK
+  255,  // 0x06 - LCD_STR_FEEDRATE
+  255,  // 0x07 - LCD_STR_BEDTEMP
+  5,12,12,6,0,1,32,80,80,80,80,80,80,80,136,136,136,112,  // 0x08 - LCD_STR_THERMOMETER
+  5,5,5,5,0,11,112,216,136,216,112,  // 0x09 - LCD_STR_DEGREE
+};
+
+extern const uint8_t Helvetica14[5005] = {
+  0,18,19,0,252,14,2,150,6,83,32,255,252,16,252,14,252,  // tFont
+  0,0,0,5,0,0,2,14,14,6,2,0,192,192,192,
+  192,192,192,192,192,192,192,0,0,192,192,5,5,5,5,0,
+  9,216,216,216,216,216,10,13,26,10,0,0,9,0,9,0,
+  9,0,127,192,127,192,18,0,18,0,18,0,255,128,255,128,
+  36,0,36,0,36,0,9,16,32,10,1,254,8,0,62,0,
+  127,0,203,0,200,0,232,0,120,0,62,0,15,0,9,128,
+  201,128,235,128,127,0,62,0,8,0,8,0,14,13,26,16,
+  1,0,120,96,204,192,204,192,205,128,205,128,123,0,3,0,
+  6,120,6,204,12,204,12,204,24,204,24,120,12,13,26,13,
+  1,0,60,0,126,0,102,0,102,0,60,0,124,0,238,192,
+  198,192,195,192,195,128,231,192,126,224,60,112,2,5,5,4,
+  1,9,192,192,192,192,192,4,18,18,6,0,252,16,48,96,
+  96,192,192,192,192,192,192,192,192,192,192,96,96,48,16,4,
+  18,18,6,1,252,128,192,96,96,48,48,48,48,48,48,48,
+  48,48,48,96,96,192,128,5,7,7,7,1,7,32,168,248,
+  32,248,168,32,8,10,10,10,1,0,24,24,24,24,255,255,
+  24,24,24,24,2,5,5,5,1,253,192,192,64,64,128,5,
+  2,2,6,0,4,248,248,2,2,2,5,1,0,192,192,5,
+  14,14,5,0,0,24,24,24,24,48,48,48,96,96,96,192,
+  192,192,192,8,13,13,10,1,0,60,126,102,195,195,195,195,
+  195,195,195,102,126,60,5,13,13,10,2,0,24,248,248,24,
+  24,24,24,24,24,24,24,24,24,8,13,13,10,1,0,60,
+  254,195,3,7,14,28,56,112,224,192,255,255,8,13,13,10,
+  1,0,62,127,195,195,6,28,30,7,3,195,199,126,60,9,
+  13,26,10,0,0,3,0,7,0,15,0,27,0,51,0,51,
+  0,99,0,195,0,255,128,255,128,3,0,3,0,3,0,8,
+  13,13,10,1,0,254,254,192,192,252,254,199,3,3,195,199,
+  254,124,8,13,13,10,1,0,60,127,99,192,192,220,254,195,
+  195,195,227,126,60,8,13,13,10,1,0,255,255,3,6,12,
+  12,24,24,48,48,96,96,96,8,13,13,10,1,0,60,126,
+  231,195,195,102,126,231,195,195,231,126,60,8,13,13,10,1,
+  0,60,126,199,195,195,195,127,59,3,3,198,254,124,2,10,
+  10,5,1,0,192,192,0,0,0,0,0,0,192,192,2,13,
+  13,5,1,253,192,192,0,0,0,0,0,0,192,192,64,64,
+  128,8,9,9,10,1,0,3,15,60,112,192,112,60,15,3,
+  7,5,5,11,2,2,254,254,0,254,254,8,9,9,10,1,
+  0,192,240,60,14,3,14,60,240,192,7,14,14,10,1,0,
+  124,254,198,198,14,28,56,48,48,48,0,0,48,48,16,17,
+  34,18,1,253,3,240,15,252,28,14,48,6,99,211,103,115,
+  198,51,204,99,204,102,204,102,204,204,207,248,103,112,112,0,
+  56,0,31,240,7,224,12,14,28,13,0,0,6,0,6,0,
+  15,0,15,0,25,128,25,128,48,192,48,192,63,192,127,224,
+  96,96,96,96,192,48,192,48,11,14,28,13,1,0,255,0,
+  255,128,193,192,192,192,192,192,193,128,255,128,255,192,192,224,
+  192,96,192,96,192,224,255,192,255,128,12,14,28,14,1,0,
+  15,128,63,224,112,112,96,48,224,0,192,0,192,0,192,0,
+  192,0,224,0,96,48,112,112,63,224,15,128,12,14,28,14,
+  1,0,255,128,255,192,192,224,192,96,192,48,192,48,192,48,
+  192,48,192,48,192,48,192,96,192,224,255,192,255,128,10,14,
+  28,13,2,0,255,192,255,192,192,0,192,0,192,0,192,0,
+  255,128,255,128,192,0,192,0,192,0,192,0,255,192,255,192,
+  9,14,28,12,2,0,255,128,255,128,192,0,192,0,192,0,
+  192,0,255,0,255,0,192,0,192,0,192,0,192,0,192,0,
+  192,0,13,14,28,15,1,0,15,192,63,240,112,56,96,24,
+  224,24,192,0,192,0,192,248,192,248,224,24,96,24,112,56,
+  63,248,15,216,11,14,28,14,1,0,192,96,192,96,192,96,
+  192,96,192,96,192,96,255,224,255,224,192,96,192,96,192,96,
+  192,96,192,96,192,96,2,14,14,6,2,0,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,8,14,14,10,0,0,
+  3,3,3,3,3,3,3,3,3,195,195,231,126,60,11,14,
+  28,14,2,0,192,224,193,192,195,128,199,0,206,0,220,0,
+  248,0,252,0,206,0,199,0,195,128,193,192,192,224,192,96,
+  9,14,28,11,1,0,192,0,192,0,192,0,192,0,192,0,
+  192,0,192,0,192,0,192,0,192,0,192,0,192,0,255,128,
+  255,128,14,14,28,16,1,0,192,12,192,12,224,28,224,28,
+  240,60,240,60,216,108,216,108,204,204,204,204,196,140,199,140,
+  195,12,195,12,11,14,28,14,1,0,192,96,224,96,240,96,
+  240,96,216,96,204,96,204,96,198,96,198,96,195,96,193,224,
+  193,224,192,224,192,96,13,14,28,15,1,0,15,128,63,224,
+  112,112,96,48,224,56,192,24,192,24,192,24,192,24,224,56,
+  96,48,112,112,63,224,15,128,10,14,28,13,2,0,255,0,
+  255,128,193,192,192,192,192,192,193,192,255,128,255,0,192,0,
+  192,0,192,0,192,0,192,0,192,0,13,15,30,15,1,255,
+  15,128,63,224,112,112,96,48,224,56,192,24,192,24,192,24,
+  192,24,225,184,97,176,112,240,63,224,15,176,0,48,11,14,
+  28,14,1,0,255,128,255,192,192,224,192,96,192,96,192,224,
+  255,192,255,128,192,192,192,192,192,96,192,96,192,96,192,96,
+  10,14,28,13,1,0,30,0,127,128,225,192,192,192,224,0,
+  124,0,31,0,3,128,1,192,0,192,192,192,225,192,127,128,
+  63,0,10,14,28,12,1,0,255,192,255,192,12,0,12,0,
+  12,0,12,0,12,0,12,0,12,0,12,0,12,0,12,0,
+  12,0,12,0,11,14,28,14,1,0,192,96,192,96,192,96,
+  192,96,192,96,192,96,192,96,192,96,192,96,192,96,192,96,
+  96,192,127,192,31,0,12,14,28,13,0,0,192,48,192,48,
+  96,96,96,96,96,96,48,192,48,192,48,192,25,128,25,128,
+  25,128,15,0,15,0,6,0,16,14,28,18,1,0,193,131,
+  193,131,193,131,195,195,99,198,98,70,102,102,102,102,54,108,
+  54,108,52,44,28,56,24,24,24,24,11,14,28,13,1,0,
+  192,96,192,96,96,192,113,192,49,128,27,0,14,0,14,0,
+  27,0,49,128,113,192,96,192,192,96,192,96,12,14,28,13,
+  0,0,192,48,192,48,96,96,96,96,48,192,57,192,25,128,
+  15,0,6,0,6,0,6,0,6,0,6,0,6,0,10,14,
+  28,12,1,0,255,192,255,192,0,192,1,128,3,0,6,0,
+  12,0,28,0,24,0,48,0,96,0,192,0,255,192,255,192,
+  4,18,18,5,0,252,240,240,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,240,240,5,14,14,5,0,0,192,192,
+  192,96,96,96,48,48,48,48,24,24,24,24,4,18,18,5,
+  0,252,240,240,48,48,48,48,48,48,48,48,48,48,48,48,
+  48,48,240,240,7,6,6,9,1,7,16,56,108,108,198,198,
+  11,2,4,11,0,252,255,224,255,224,4,3,3,4,0,11,
+  192,96,48,9,10,20,11,1,0,126,0,231,0,195,0,7,
+  0,127,0,227,0,195,0,195,0,231,128,121,128,9,14,28,
+  11,1,0,192,0,192,0,192,0,192,0,222,0,255,0,227,
+  0,193,128,193,128,193,128,193,128,227,0,255,0,222,0,8,
+  10,10,10,1,0,62,127,99,192,192,192,192,99,127,62,9,
+  14,28,11,1,0,1,128,1,128,1,128,1,128,61,128,127,
+  128,99,128,193,128,193,128,193,128,193,128,99,128,127,128,61,
+  128,8,10,10,10,1,0,60,126,195,195,255,192,192,227,127,
+  60,6,14,14,6,0,0,28,60,48,48,252,252,48,48,48,
+  48,48,48,48,48,9,14,28,11,1,252,61,128,127,128,97,
+  128,193,128,193,128,193,128,193,128,99,128,127,128,61,128,1,
+  128,99,0,127,0,28,0,8,14,14,10,1,0,192,192,192,
+  192,222,255,227,195,195,195,195,195,195,195,2,14,14,4,1,
+  0,192,192,0,0,192,192,192,192,192,192,192,192,192,192,3,
+  18,18,4,0,252,96,96,0,0,96,96,96,96,96,96,96,
+  96,96,96,96,96,224,192,8,14,14,9,1,0,192,192,192,
+  192,198,204,216,240,248,216,204,206,198,199,2,14,14,4,1,
+  0,192,192,192,192,192,192,192,192,192,192,192,192,192,192,14,
+  10,20,16,1,0,222,120,255,252,227,140,195,12,195,12,195,
+  12,195,12,195,12,195,12,195,12,8,10,10,10,1,0,222,
+  255,227,195,195,195,195,195,195,195,9,10,20,11,1,0,62,
+  0,127,0,99,0,193,128,193,128,193,128,193,128,99,0,127,
+  0,62,0,9,14,28,11,1,252,222,0,255,0,227,0,193,
+  128,193,128,193,128,193,128,227,0,255,0,222,0,192,0,192,
+  0,192,0,192,0,9,14,28,11,1,252,61,128,127,128,99,
+  128,193,128,193,128,193,128,193,128,99,128,127,128,61,128,1,
+  128,1,128,1,128,1,128,5,10,10,6,1,0,216,216,224,
+  192,192,192,192,192,192,192,7,10,10,9,1,0,60,126,198,
+  192,252,62,6,198,252,120,6,13,13,6,0,0,48,48,48,
+  252,252,48,48,48,48,48,48,60,28,8,10,10,10,1,0,
+  195,195,195,195,195,195,195,199,255,123,8,10,10,10,1,0,
+  195,195,195,102,102,102,36,60,24,24,12,10,20,14,1,0,
+  198,48,198,48,198,48,102,96,102,96,105,96,41,64,57,192,
+  25,128,25,128,8,10,10,10,1,0,195,231,102,60,24,24,
+  60,102,231,195,8,14,14,10,1,252,195,195,195,102,102,102,
+  36,60,24,24,24,24,112,112,7,10,10,9,1,0,254,254,
+  6,12,24,48,96,192,254,254,5,18,18,6,0,252,24,48,
+  96,96,96,96,96,192,128,192,96,96,96,96,96,96,48,24,
+  2,18,18,5,1,252,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,6,18,18,6,0,252,192,96,
+  48,48,48,48,48,24,12,24,48,48,48,48,48,48,96,192,
+  8,3,3,10,1,4,115,255,206,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,
+  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,
+  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,
+  0,0,5,0,0,2,14,14,6,2,252,192,192,0,0,64,
+  64,192,192,192,192,192,192,192,192,8,14,14,10,1,254,4,
+  4,62,127,107,200,200,200,200,107,127,62,16,16,9,13,26,
+  10,0,0,30,0,63,0,97,128,97,128,96,0,48,0,126,
+  0,24,0,24,0,48,0,96,128,255,128,223,0,8,7,7,
+  10,1,3,195,255,102,102,102,255,195,8,13,13,10,1,0,
+  195,195,102,102,102,60,255,24,255,24,24,24,24,2,18,18,
+  5,1,252,192,192,192,192,192,192,192,0,0,0,0,192,192,
+  192,192,192,192,192,8,18,18,10,1,252,60,126,195,195,240,
+  124,110,199,195,227,115,62,14,7,195,195,126,60,5,2,2,
+  6,0,12,216,216,13,14,28,15,1,0,15,128,48,96,64,
+  16,71,16,136,136,144,136,144,8,144,8,144,8,136,136,71,
+  16,64,16,48,96,15,128,5,8,8,7,1,6,112,152,56,
+  72,216,104,0,248,7,6,6,9,1,2,54,108,216,216,108,
+  54,9,5,10,11,1,3,255,128,255,128,1,128,1,128,1,
+  128,5,1,1,6,0,5,248,13,14,28,14,0,0,15,128,
+  48,96,64,16,79,144,136,72,136,72,136,72,143,136,137,8,
+  136,136,72,80,64,16,48,96,15,128,5,1,1,5,0,12,
+  248,5,5,5,7,1,8,112,216,136,216,112,8,11,11,10,
+  1,0,24,24,24,255,255,24,24,24,0,255,255,5,8,8,
+  6,0,5,112,248,152,24,48,96,248,248,5,8,8,6,0,
+  5,112,248,152,48,48,152,248,112,4,3,3,4,0,11,48,
+  96,192,8,14,14,10,1,252,195,195,195,195,195,195,195,231,
+  255,219,192,192,192,192,8,18,18,10,1,252,63,114,242,242,
+  242,242,242,114,50,18,18,18,18,18,18,18,18,18,2,2,
+  2,4,1,4,192,192,5,5,5,5,0,252,96,112,24,216,
+  240,4,8,8,6,0,5,48,240,240,48,48,48,48,48,5,
+  8,8,7,1,6,112,216,136,136,216,112,0,248,7,6,6,
+  9,1,2,216,108,54,54,108,216,14,13,26,15,0,0,48,
+  48,240,48,240,96,48,192,48,192,49,136,49,24,51,56,6,
+  120,6,216,12,252,24,24,24,24,14,13,26,15,0,0,48,
+  48,240,48,240,96,48,192,48,192,49,184,49,124,51,76,6,
+  12,6,24,12,48,24,124,24,124,14,13,26,15,0,0,112,
+  48,248,48,152,96,48,192,48,192,153,136,249,24,115,56,6,
+  120,6,216,12,252,24,24,24,24,7,14,14,10,1,252,24,
+  24,0,0,24,24,24,56,112,224,198,198,254,124,12,16,32,
+  13,0,0,6,0,0,0,6,0,6,0,15,0,15,0,25,
+  128,25,128,48,192,48,192,63,192,127,224,96,96,96,96,192,
+  48,192,48,12,16,32,13,0,0,6,0,0,0,6,0,6,
+  0,15,0,15,0,25,128,25,128,48,192,48,192,63,192,127,
+  224,96,96,96,96,192,48,192,48,12,16,32,13,0,0,25,
+  128,0,0,6,0,6,0,15,0,15,0,25,128,25,128,48,
+  192,48,192,63,192,127,224,96,96,96,96,192,48,192,48,12,
+  16,32,13,0,0,19,0,0,0,6,0,6,0,15,0,15,
+  0,25,128,25,128,48,192,48,192,63,192,127,224,96,96,96,
+  96,192,48,192,48,12,16,32,13,0,0,25,128,0,0,6,
+  0,6,0,15,0,15,0,25,128,25,128,48,192,48,192,63,
+  192,127,224,96,96,96,96,192,48,192,48,12,16,32,13,0,
+  0,9,0,9,0,6,0,6,0,15,0,15,0,25,128,25,
+  128,48,192,48,192,63,192,127,224,96,96,96,96,192,48,192,
+  48,16,14,28,18,1,0,7,255,7,255,13,128,13,128,25,
+  128,25,128,49,254,49,254,63,128,127,128,97,128,97,128,193,
+  255,193,255,12,18,36,14,1,252,15,128,63,224,112,112,96,
+  48,224,0,192,0,192,0,192,0,192,0,224,0,96,48,112,
+  112,63,224,15,128,6,0,3,0,27,0,30,0,10,16,32,
+  13,2,0,12,0,0,0,255,192,255,192,192,0,192,0,192,
+  0,192,0,255,128,255,128,192,0,192,0,192,0,192,0,255,
+  192,255,192,10,16,32,13,2,0,12,0,0,0,255,192,255,
+  192,192,0,192,0,192,0,192,0,255,128,255,128,192,0,192,
+  0,192,0,192,0,255,192,255,192,10,16,32,13,2,0,51,
+  0,0,0,255,192,255,192,192,0,192,0,192,0,192,0,255,
+  128,255,128,192,0,192,0,192,0,192,0,255,192,255,192,10,
+  16,32,13,2,0,51,0,0,0,255,192,255,192,192,0,192,
+  0,192,0,192,0,255,128,255,128,192,0,192,0,192,0,192,
+  0,255,192,255,192,2,16,16,6,2,0,192,0,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,2,16,16,6,2,
+  0,192,0,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,6,16,16,6,0,0,132,0,48,48,48,48,48,48,48,
+  48,48,48,48,48,48,48,6,16,16,6,0,0,204,0,48,
+  48,48,48,48,48,48,48,48,48,48,48,48,48,13,14,28,
+  14,0,0,127,192,127,224,96,112,96,48,96,24,96,24,252,
+  24,252,24,96,24,96,24,96,48,96,112,127,224,127,192,11,
+  16,32,14,1,0,19,0,0,0,192,96,224,96,240,96,240,
+  96,216,96,204,96,204,96,198,96,198,96,195,96,193,224,193,
+  224,192,224,192,96,13,16,32,15,1,0,6,0,0,0,15,
+  128,63,224,112,112,96,48,224,56,192,24,192,24,192,24,192,
+  24,224,56,96,48,112,112,63,224,15,128,13,16,32,15,1,
+  0,6,0,0,0,15,128,63,224,112,112,96,48,224,56,192,
+  24,192,24,192,24,192,24,224,56,96,48,112,112,63,224,15,
+  128,13,16,32,15,1,0,12,192,0,0,15,128,63,224,112,
+  112,96,48,224,56,192,24,192,24,192,24,192,24,224,56,96,
+  48,112,112,63,224,15,128,13,16,32,15,1,0,9,128,0,
+  0,15,128,63,224,112,112,96,48,224,56,192,24,192,24,192,
+  24,192,24,224,56,96,48,112,112,63,224,15,128,13,16,32,
+  15,1,0,12,192,0,0,15,128,63,224,112,112,96,48,224,
+  56,192,24,192,24,192,24,192,24,224,56,96,48,112,112,63,
+  224,15,128,10,9,18,10,0,0,192,192,97,128,51,0,30,
+  0,12,0,30,0,51,0,97,128,192,192,14,14,28,15,0,
+  0,7,204,31,248,56,48,48,120,112,220,97,140,99,12,98,
+  12,102,12,108,28,56,24,56,56,111,240,199,192,11,16,32,
+  14,1,0,6,0,0,0,192,96,192,96,192,96,192,96,192,
+  96,192,96,192,96,192,96,192,96,192,96,192,96,96,192,127,
+  192,31,0,11,16,32,14,1,0,12,0,0,0,192,96,192,
+  96,192,96,192,96,192,96,192,96,192,96,192,96,192,96,192,
+  96,192,96,96,192,127,192,31,0,11,16,32,14,1,0,25,
+  128,0,0,192,96,192,96,192,96,192,96,192,96,192,96,192,
+  96,192,96,192,96,192,96,192,96,96,192,127,192,31,0,11,
+  16,32,14,1,0,49,128,0,0,192,96,192,96,192,96,192,
+  96,192,96,192,96,192,96,192,96,192,96,192,96,192,96,96,
+  192,127,192,31,0,12,16,32,13,0,0,6,0,0,0,192,
+  48,192,48,96,96,96,96,48,192,57,192,25,128,15,0,6,
+  0,6,0,6,0,6,0,6,0,6,0,10,14,28,12,1,
+  0,192,0,192,0,192,0,255,0,255,128,193,192,192,192,192,
+  192,193,192,255,128,255,0,192,0,192,0,192,0,7,14,14,
+  9,1,0,56,124,198,198,198,198,220,220,198,198,198,198,222,
+  220,9,14,28,11,1,0,48,0,24,0,12,0,0,0,126,
+  0,231,0,195,0,7,0,127,0,227,0,195,0,195,0,231,
+  128,121,128,9,14,28,11,1,0,12,0,24,0,48,0,0,
+  0,126,0,231,0,195,0,7,0,127,0,227,0,195,0,195,
+  0,231,128,121,128,9,14,28,11,1,0,24,0,60,0,102,
+  0,0,0,126,0,231,0,195,0,7,0,127,0,227,0,195,
+  0,195,0,231,128,121,128,9,14,28,11,1,0,50,0,90,
+  0,76,0,0,0,126,0,231,0,195,0,7,0,127,0,227,
+  0,195,0,195,0,231,128,121,128,9,14,28,11,1,0,102,
+  0,102,0,0,0,0,0,126,0,231,0,195,0,7,0,127,
+  0,227,0,195,0,195,0,231,128,121,128,9,14,28,11,1,
+  0,24,0,36,0,36,0,24,0,126,0,231,0,195,0,7,
+  0,127,0,227,0,195,0,195,0,231,128,121,128,14,10,20,
+  17,2,0,126,240,231,248,195,12,7,12,127,252,227,0,195,
+  0,195,140,231,252,122,240,8,14,14,10,1,252,62,127,99,
+  192,192,192,192,99,127,62,24,12,108,120,8,14,14,10,1,
+  0,48,24,12,0,60,126,195,195,255,192,192,227,127,60,8,
+  14,14,10,1,0,12,24,48,0,60,126,195,195,255,192,192,
+  227,127,60,8,14,14,10,1,0,24,60,102,0,60,126,195,
+  195,255,192,192,227,127,60,8,14,14,10,1,0,102,102,0,
+  0,60,126,195,195,255,192,192,227,127,60,4,14,14,4,0,
+  0,192,96,48,0,96,96,96,96,96,96,96,96,96,96,4,
+  14,14,4,0,0,48,96,192,0,96,96,96,96,96,96,96,
+  96,96,96,5,14,14,5,0,0,96,240,152,0,96,96,96,
+  96,96,96,96,96,96,96,5,14,14,5,0,0,216,216,0,
+  0,96,96,96,96,96,96,96,96,96,96,9,14,28,11,1,
+  0,96,0,54,0,56,0,76,0,62,0,127,0,99,0,193,
+  128,193,128,193,128,193,128,99,0,127,0,62,0,8,14,14,
+  10,1,0,50,90,76,0,222,255,227,195,195,195,195,195,195,
+  195,9,14,28,11,1,0,48,0,24,0,12,0,0,0,62,
+  0,127,0,99,0,193,128,193,128,193,128,193,128,99,0,127,
+  0,62,0,9,14,28,11,1,0,6,0,12,0,24,0,0,
+  0,62,0,127,0,99,0,193,128,193,128,193,128,193,128,99,
+  0,127,0,62,0,9,14,28,11,1,0,24,0,60,0,102,
+  0,0,0,62,0,127,0,99,0,193,128,193,128,193,128,193,
+  128,99,0,127,0,62,0,9,14,28,11,1,0,50,0,90,
+  0,76,0,0,0,62,0,127,0,99,0,193,128,193,128,193,
+  128,193,128,99,0,127,0,62,0,9,14,28,11,1,0,51,
+  0,51,0,0,0,0,0,62,0,127,0,99,0,193,128,193,
+  128,193,128,193,128,99,0,127,0,62,0,8,8,8,10,1,
+  1,24,24,0,255,255,0,24,24,11,10,20,11,0,0,14,
+  96,63,192,49,128,99,192,102,192,108,192,120,192,49,128,127,
+  128,206,0,8,14,14,10,1,0,48,24,12,0,195,195,195,
+  195,195,195,195,199,255,123,8,14,14,10,1,0,6,12,24,
+  0,195,195,195,195,195,195,195,199,255,123,8,14,14,10,1,
+  0,24,60,102,0,195,195,195,195,195,195,195,199,255,123,8,
+  14,14,10,1,0,102,102,0,0,195,195,195,195,195,195,195,
+  199,255,123,8,18,18,10,1,252,6,12,24,0,195,195,195,
+  102,102,102,36,60,24,24,24,24,112,112,9,18,36,11,1,
+  252,192,0,192,0,192,0,192,0,222,0,255,0,227,0,193,
+  128,193,128,193,128,193,128,227,0,255,0,222,0,192,0,192,
+  0,192,0,192,0,8,18,18,10,1,252,102,102,0,0,195,
+  195,195,102,102,102,36,60,24,24,24,24,112,112
+};
+
+#endif // HAS_GRAPHICAL_TFT
diff --git a/Marlin/src/lcd/tft/fontdata/helvetica_18.cpp b/Marlin/src/lcd/tft/fontdata/helvetica_18.cpp
new file mode 100644
index 0000000000..bb5f6ccf40
--- /dev/null
+++ b/Marlin/src/lcd/tft/fontdata/helvetica_18.cpp
@@ -0,0 +1,492 @@
+/*
+  Fontname: -Adobe-Helvetica-Medium-R-Normal--25-180-100-100-P-130-ISO10646-1
+  Copyright: Copyright (c) 1984, 1987 Adobe Systems Incorporated. All Rights Reserved. Copyright (c) 1988, 1991 Digital Equipment Corporation. All Rights Reserved.
+  Capital A Height: 19, '1' Height: 18
+  Calculated Max Values w=22 h=24 x= 3 y=16 dx=25 dy= 0 ascent=24 len=69
+  Font Bounding box     w=28 h=37 x=-3 y=-8
+  Calculated Min Values           x=-1 y=-5 dx= 0 dy= 0
+  Pure Font   ascent =19 descent=-5
+  X Font      ascent =19 descent=-5
+  Max Font    ascent =24 descent=-5
+*/
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include <stdint.h>
+
+extern const uint8_t Helvetica18_symbols[71] = {
+  0,28,37,253,248,19,4,37,9,49,1,9,251,24,251,19,251,  // tFont
+  0,0,0,0,0,0,  // 0x01 - LCD_STR_REFRESH
+  0,0,0,0,0,0,  // 0x02 - LCD_STR_FOLDER
+  255,  // 0x03 - LCD_STR_ARROW_RIGHT
+  255,  // 0x04 - LCD_STR_UPLEVEL
+  255,  // 0x05 - LCD_STR_CLOCK
+  255,  // 0x06 - LCD_STR_FEEDRATE
+  255,  // 0x07 - LCD_STR_BEDTEMP
+  7,18,18,8,0,1, 0,56, 68,68,68,68,68,84,84,84,84,84, 214,186,186,186,198,124,  // 0x08 - LCD_STR_THERMOMETER
+  7,7,7,7,0,15,56,124,198,198,198,124,56,  // 0x09 - LCD_STR_DEGREE
+};
+
+extern const uint8_t Helvetica18[7307] = {
+  0,28,37,253,248,19,4,37,9,49,32,255,251,24,251,19,251,  // tFont
+  0,0,0,6,0,1,2,19,19,6,2,0,192,192,192,
+  192,192,192,192,192,192,192,192,192,128,128,0,0,192,192,192,
+  6,6,6,8,1,13,204,204,204,204,204,68,11,17,34,14,
+  2,0,12,192,12,192,12,192,25,128,255,224,255,224,25,128,
+  25,128,51,0,51,0,255,224,255,224,51,0,51,0,102,0,
+  102,0,102,0,11,22,44,13,1,254,6,0,6,0,31,128,
+  63,192,118,224,102,96,102,96,102,0,118,0,62,0,62,0,
+  15,128,7,192,6,224,6,96,198,96,198,96,230,224,127,192,
+  63,128,6,0,6,0,19,18,54,22,1,0,0,6,0,60,
+  12,0,126,12,0,195,24,0,195,24,0,195,48,0,195,48,
+  0,126,96,0,60,96,0,0,192,0,0,199,128,1,143,192,
+  1,152,96,3,24,96,3,24,96,6,24,96,6,15,192,4,
+  7,128,14,18,36,17,2,0,15,0,31,128,57,192,48,192,
+  48,192,48,192,25,128,15,0,30,0,63,24,115,152,97,216,
+  192,240,192,96,192,240,225,216,127,156,30,0,2,6,6,6,
+  2,13,192,192,192,192,192,64,5,24,24,8,2,251,24,24,
+  48,48,96,96,96,192,192,192,192,192,192,192,192,192,192,96,
+  96,96,48,48,24,24,5,24,24,8,1,251,192,192,96,96,
+  48,48,48,24,24,24,24,24,24,24,24,24,24,48,48,48,
+  96,96,192,192,7,7,7,10,1,12,16,16,214,124,56,108,
+  68,12,12,24,14,1,1,6,0,6,0,6,0,6,0,6,
+  0,255,240,255,240,6,0,6,0,6,0,6,0,6,0,2,
+  6,6,6,2,253,192,192,192,64,64,128,6,2,2,8,1,
+  6,252,252,2,3,3,6,2,0,192,192,192,7,19,19,7,
+  0,0,6,4,12,12,8,24,24,16,16,48,48,32,96,96,
+  64,192,192,128,128,11,18,36,13,1,0,31,0,63,128,113,
+  192,96,192,96,192,224,224,192,96,192,96,192,96,192,96,192,
+  96,192,96,224,224,96,192,96,192,113,192,63,128,31,0,6,
+  18,18,13,2,0,12,12,28,252,252,12,12,12,12,12,12,
+  12,12,12,12,12,12,12,11,18,36,13,1,0,30,0,127,
+  128,97,192,192,192,192,96,192,96,0,224,0,192,1,192,3,
+  128,15,0,28,0,56,0,112,0,224,0,192,0,255,224,255,
+  224,11,18,36,13,1,0,31,0,127,128,97,128,192,192,192,
+  192,192,192,0,192,1,128,15,0,15,192,0,192,0,96,0,
+  96,192,96,192,192,97,192,127,128,31,0,11,18,36,13,1,
+  0,1,128,3,128,3,128,7,128,15,128,13,128,25,128,57,
+  128,49,128,97,128,225,128,193,128,255,224,255,224,1,128,1,
+  128,1,128,1,128,11,18,36,13,1,0,127,192,127,192,96,
+  0,96,0,96,0,96,0,126,0,127,128,113,192,0,192,0,
+  224,0,96,0,96,192,224,192,192,225,192,127,128,30,0,11,
+  18,36,13,1,0,15,0,63,192,112,192,96,96,224,96,192,
+  0,192,0,207,0,223,128,241,192,224,192,192,96,192,96,192,
+  96,224,224,113,192,127,192,31,0,11,18,36,13,1,0,255,
+  224,255,224,0,224,0,192,1,128,1,128,3,0,3,0,6,
+  0,6,0,12,0,12,0,28,0,24,0,24,0,56,0,48,
+  0,48,0,11,18,36,13,1,0,14,0,63,128,49,128,96,
+  192,96,192,96,192,49,128,31,0,63,128,113,192,96,192,192,
+  96,192,96,192,96,192,96,96,192,127,192,31,0,11,18,36,
+  13,1,0,31,0,127,192,113,192,224,192,192,96,192,96,192,
+  96,192,96,224,224,113,224,127,96,30,96,0,96,0,224,192,
+  192,225,192,127,128,30,0,2,14,14,6,2,0,192,192,192,
+  0,0,0,0,0,0,0,0,192,192,192,2,17,17,6,2,
+  253,192,192,192,0,0,0,0,0,0,0,0,192,192,192,64,
+  64,128,12,12,24,15,1,1,0,48,0,240,3,192,15,0,
+  60,0,224,0,224,0,60,0,15,0,3,192,0,240,0,48,
+  10,5,10,15,2,5,255,192,255,192,0,0,255,192,255,192,
+  12,12,24,15,1,1,192,0,240,0,60,0,15,0,3,192,
+  0,112,0,112,3,192,15,0,60,0,240,0,192,0,10,19,
+  38,12,1,0,31,0,127,128,113,192,224,192,192,192,193,192,
+  1,128,3,128,7,0,6,0,12,0,12,0,12,0,12,0,
+  0,0,0,0,12,0,12,0,12,0,22,23,69,25,2,252,
+  0,255,0,3,255,192,15,1,224,28,0,112,56,0,24,48,
+  0,24,96,115,12,96,251,12,193,199,12,195,134,12,195,6,
+  12,198,6,12,198,12,28,198,12,24,198,12,56,231,28,112,
+  99,247,224,113,227,128,56,0,0,28,0,0,15,3,0,7,
+  255,0,0,252,0,15,19,38,17,1,0,3,128,3,128,6,
+  192,6,192,12,64,12,96,12,96,24,48,24,48,24,48,48,
+  24,63,248,63,248,96,12,96,12,96,12,192,6,192,6,192,
+  6,14,19,38,17,2,0,255,192,255,240,192,112,192,24,192,
+  24,192,24,192,24,192,48,255,224,255,240,192,24,192,12,192,
+  12,192,12,192,12,192,28,192,120,255,240,255,192,15,19,38,
+  18,1,0,7,224,31,248,60,60,112,14,96,6,224,6,192,
+  0,192,0,192,0,192,0,192,0,192,0,192,0,224,6,96,
+  6,112,14,60,60,31,248,7,224,15,19,38,18,2,0,255,
+  192,255,240,192,120,192,28,192,12,192,14,192,6,192,6,192,
+  6,192,6,192,6,192,6,192,6,192,14,192,12,192,28,192,
+  120,255,240,255,192,12,19,38,16,2,0,255,240,255,240,192,
+  0,192,0,192,0,192,0,192,0,192,0,255,224,255,224,192,
+  0,192,0,192,0,192,0,192,0,192,0,192,0,255,240,255,
+  240,11,19,38,14,2,0,255,224,255,224,192,0,192,0,192,
+  0,192,0,192,0,192,0,255,192,255,192,192,0,192,0,192,
+  0,192,0,192,0,192,0,192,0,192,0,192,0,16,19,38,
+  19,1,0,7,224,31,248,60,60,112,14,96,6,224,6,192,
+  0,192,0,192,0,192,127,192,127,192,3,192,3,224,3,96,
+  7,112,15,60,63,31,251,7,227,14,19,38,18,2,0,192,
+  12,192,12,192,12,192,12,192,12,192,12,192,12,192,12,255,
+  252,255,252,192,12,192,12,192,12,192,12,192,12,192,12,192,
+  12,192,12,192,12,2,19,19,8,3,0,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,10,19,
+  38,13,1,0,0,192,0,192,0,192,0,192,0,192,0,192,
+  0,192,0,192,0,192,0,192,0,192,0,192,192,192,192,192,
+  192,192,192,192,97,128,127,128,63,0,13,19,38,18,3,0,
+  192,56,192,112,192,224,193,192,195,128,199,0,206,0,220,0,
+  252,0,254,0,231,0,195,128,193,128,193,192,192,224,192,96,
+  192,112,192,56,192,24,11,19,38,14,2,0,192,0,192,0,
+  192,0,192,0,192,0,192,0,192,0,192,0,192,0,192,0,
+  192,0,192,0,192,0,192,0,192,0,192,0,192,0,255,224,
+  255,224,17,19,57,21,2,0,192,1,128,224,3,128,224,3,
+  128,240,7,128,240,7,128,216,13,128,216,13,128,216,13,128,
+  204,25,128,204,25,128,204,25,128,198,49,128,198,49,128,198,
+  49,128,195,97,128,195,97,128,195,97,128,193,193,128,193,193,
+  128,14,19,38,18,2,0,224,12,240,12,240,12,216,12,220,
+  12,204,12,206,12,198,12,199,12,195,12,195,140,193,140,193,
+  204,192,204,192,236,192,108,192,60,192,60,192,28,16,19,38,
+  18,1,0,7,224,31,248,60,60,112,14,96,6,224,7,192,
+  3,192,3,192,3,192,3,192,3,192,3,192,3,224,7,96,
+  6,112,14,60,60,31,248,7,224,13,19,38,16,2,0,255,
+  224,255,240,192,48,192,24,192,24,192,24,192,24,192,48,255,
+  240,255,224,192,0,192,0,192,0,192,0,192,0,192,0,192,
+  0,192,0,192,0,16,19,38,18,1,0,7,224,31,248,60,
+  60,112,14,96,6,224,7,192,3,192,3,192,3,192,3,192,
+  3,192,3,192,3,224,7,96,230,112,126,60,28,31,254,7,
+  231,13,19,38,17,2,0,255,224,255,240,192,48,192,24,192,
+  24,192,24,192,24,192,48,255,240,255,224,192,112,192,48,192,
+  24,192,24,192,24,192,24,192,24,192,24,192,24,13,19,38,
+  16,2,0,15,128,63,224,96,96,192,48,192,48,192,0,224,
+  0,124,0,63,128,7,224,0,240,0,56,0,24,0,24,192,
+  24,192,56,240,112,127,224,31,128,14,19,38,16,1,0,255,
+  252,255,252,3,0,3,0,3,0,3,0,3,0,3,0,3,
+  0,3,0,3,0,3,0,3,0,3,0,3,0,3,0,3,
+  0,3,0,3,0,14,19,38,18,2,0,192,12,192,12,192,
+  12,192,12,192,12,192,12,192,12,192,12,192,12,192,12,192,
+  12,192,12,192,12,192,12,192,12,96,24,112,56,63,240,15,
+  192,15,19,38,17,1,0,192,6,192,6,224,14,96,12,112,
+  28,48,24,48,24,56,56,24,48,24,48,28,112,12,96,12,
+  96,14,224,6,192,6,192,3,128,3,128,3,128,20,19,57,
+  22,1,0,192,96,48,192,96,48,192,96,48,192,240,48,96,
+  240,96,97,152,96,97,152,96,97,152,96,97,152,96,49,152,
+  192,51,12,192,51,12,192,51,12,192,27,13,128,27,13,128,
+  30,7,128,14,7,0,12,3,0,12,3,0,15,19,38,17,
+  1,0,192,6,224,14,112,28,48,24,24,48,28,112,14,224,
+  7,192,3,128,3,128,7,192,14,224,12,96,28,112,56,56,
+  48,24,96,12,224,14,192,6,14,19,38,16,1,0,192,12,
+  224,28,96,24,112,56,48,48,56,112,24,96,28,224,12,192,
+  15,192,7,128,7,128,3,0,3,0,3,0,3,0,3,0,
+  3,0,3,0,13,19,38,15,1,0,255,248,255,248,0,56,
+  0,112,0,224,1,192,1,192,3,128,7,0,7,0,14,0,
+  28,0,28,0,56,0,112,0,112,0,224,0,255,248,255,248,
+  4,24,24,7,2,251,240,240,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,240,240,8,19,
+  19,7,0,0,192,64,64,96,32,32,48,16,16,16,24,8,
+  8,12,4,4,6,2,3,4,24,24,7,1,251,240,240,48,
+  48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
+  48,48,48,240,240,10,9,18,12,1,10,12,0,12,0,30,
+  0,18,0,51,0,97,128,97,128,192,192,192,192,14,2,4,
+  14,0,251,255,252,255,252,5,4,4,7,1,15,192,96,48,
+  24,11,14,28,13,1,0,31,0,63,128,97,192,96,192,0,
+  192,7,192,63,192,120,192,224,192,192,192,193,192,227,192,126,
+  224,60,96,11,19,38,14,2,0,192,0,192,0,192,0,192,
+  0,192,0,207,0,223,128,241,192,224,192,192,224,192,96,192,
+  96,192,96,192,96,192,224,224,192,241,192,223,128,207,0,10,
+  14,28,12,1,0,31,0,63,128,113,192,96,192,224,0,192,
+  0,192,0,192,0,192,0,224,0,96,192,113,192,63,128,31,
+  0,11,19,38,14,1,0,0,96,0,96,0,96,0,96,0,
+  96,30,96,63,96,113,224,96,224,224,96,192,96,192,96,192,
+  96,192,96,224,96,96,224,113,224,63,96,30,96,11,14,28,
+  13,1,0,14,0,63,128,113,192,96,192,192,96,192,96,255,
+  224,255,224,192,0,192,0,96,96,112,224,63,192,15,0,6,
+  19,19,8,1,0,28,60,48,48,48,252,252,48,48,48,48,
+  48,48,48,48,48,48,48,48,11,19,38,14,1,251,30,96,
+  63,96,113,224,96,224,224,96,192,96,192,96,192,96,192,96,
+  224,96,96,224,113,224,63,96,30,96,0,96,192,96,224,192,
+  127,192,31,0,10,19,38,13,2,0,192,0,192,0,192,0,
+  192,0,192,0,206,0,223,128,241,128,224,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  2,19,19,6,2,0,192,192,192,0,0,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,4,24,24,6,0,251,48,
+  48,48,0,0,48,48,48,48,48,48,48,48,48,48,48,48,
+  48,48,48,48,48,240,224,10,19,38,12,2,0,192,0,192,
+  0,192,0,192,0,192,0,193,128,195,128,199,0,206,0,220,
+  0,248,0,252,0,206,0,198,0,199,0,195,128,193,128,193,
+  192,192,192,2,19,19,6,2,0,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,16,14,28,20,
+  2,0,206,60,255,126,227,199,193,131,193,131,193,131,193,131,
+  193,131,193,131,193,131,193,131,193,131,193,131,193,131,10,14,
+  28,14,2,0,206,0,223,128,241,128,224,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  11,14,28,13,1,0,31,0,63,128,113,192,96,192,224,224,
+  192,96,192,96,192,96,192,96,224,224,96,192,113,192,63,128,
+  31,0,11,19,38,14,2,251,207,0,223,128,241,192,224,192,
+  192,224,192,96,192,96,192,96,192,96,192,224,224,192,241,192,
+  223,128,207,0,192,0,192,0,192,0,192,0,192,0,11,19,
+  38,14,1,251,30,96,63,96,113,224,96,224,224,96,192,96,
+  192,96,192,96,192,96,224,96,96,224,113,224,63,96,30,96,
+  0,96,0,96,0,96,0,96,0,96,6,14,14,9,2,0,
+  204,220,248,240,224,192,192,192,192,192,192,192,192,192,10,14,
+  28,12,1,0,63,0,127,128,225,192,192,192,192,0,248,0,
+  127,0,15,128,1,192,192,192,192,192,225,192,127,128,63,0,
+  6,18,18,8,1,0,48,48,48,48,252,252,48,48,48,48,
+  48,48,48,48,48,48,60,28,10,14,28,14,2,0,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,193,192,99,192,126,192,28,192,11,14,28,13,1,0,
+  192,96,192,96,192,96,96,192,96,192,113,192,49,128,49,128,
+  27,0,27,0,27,0,14,0,14,0,14,0,18,14,42,18,
+  0,0,192,192,192,192,192,192,97,225,128,97,225,128,97,225,
+  128,49,35,0,51,51,0,51,51,0,27,54,0,26,22,0,
+  30,30,0,14,28,0,12,12,0,12,12,0,10,14,28,12,
+  1,0,192,192,225,192,97,128,51,0,30,0,30,0,12,0,
+  30,0,30,0,51,0,115,128,97,128,192,192,192,192,12,19,
+  38,13,0,251,192,48,192,48,96,48,112,96,48,96,56,224,
+  24,192,24,192,13,128,13,128,7,128,7,0,3,0,3,0,
+  6,0,6,0,12,0,60,0,56,0,10,14,28,12,1,0,
+  255,192,255,192,1,128,3,0,7,0,14,0,12,0,28,0,
+  56,0,48,0,96,0,224,0,255,192,255,192,6,24,24,8,
+  1,251,12,24,48,48,48,48,48,48,48,48,96,192,192,96,
+  48,48,48,48,48,48,48,48,24,12,1,24,24,6,2,251,
+  128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
+  128,128,128,128,128,128,128,128,6,24,24,8,1,251,192,96,
+  48,48,48,48,48,48,48,48,24,12,12,24,48,48,48,48,
+  48,48,48,48,96,192,10,4,8,14,2,5,112,192,252,192,
+  207,192,195,128,255,255,255,255,255,255,255,255,255,255,255,255,
+  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
+  255,255,255,255,255,0,0,0,6,0,1,2,19,19,6,2,
+  251,192,192,192,0,0,64,64,192,192,192,192,192,192,192,192,
+  192,192,192,192,10,18,36,13,1,254,1,128,1,128,31,0,
+  63,128,115,192,102,192,198,0,204,0,204,0,204,0,216,0,
+  216,0,216,192,113,192,127,128,63,0,96,0,96,0,12,18,
+  36,14,1,0,31,128,63,224,112,112,96,48,96,0,112,0,
+  48,0,24,0,255,128,255,128,24,0,24,0,24,0,48,0,
+  48,0,103,48,255,240,240,224,11,12,24,13,1,3,192,96,
+  238,224,127,192,49,128,96,192,96,192,96,192,96,192,49,128,
+  127,192,238,224,192,96,14,18,36,14,0,0,224,28,96,24,
+  112,56,48,48,56,112,24,96,28,224,12,192,63,240,63,240,
+  3,0,63,240,63,240,3,0,3,0,3,0,3,0,3,0,
+  2,24,24,6,2,251,192,192,192,192,192,192,192,192,192,192,
+  0,0,0,0,192,192,192,192,192,192,192,192,192,192,11,24,
+  48,13,1,251,31,0,63,128,113,192,96,192,112,192,56,0,
+  28,0,126,0,231,0,195,128,193,192,192,192,96,96,112,96,
+  56,96,28,192,15,128,7,0,3,128,97,192,96,192,113,192,
+  63,128,31,0,6,2,2,8,1,16,204,204,19,19,57,19,
+  1,0,3,248,0,14,14,0,48,1,128,96,0,192,65,240,
+  64,195,24,96,134,12,32,132,0,32,132,0,32,132,0,32,
+  132,0,32,134,12,32,195,24,96,65,240,64,96,0,192,48,
+  1,128,24,3,0,14,14,0,3,248,0,7,12,12,9,1,
+  7,120,204,204,28,108,204,204,220,118,0,254,254,9,8,16,
+  14,2,3,25,128,51,0,102,0,204,0,204,0,102,0,51,
+  0,25,128,13,8,16,15,1,2,255,248,255,248,0,24,0,
+  24,0,24,0,24,0,24,0,24,6,2,2,8,1,6,252,
+  252,18,19,57,19,1,0,7,248,0,28,14,0,48,3,0,
+  96,1,128,67,240,128,194,24,192,130,8,64,130,8,64,130,
+  8,64,130,16,64,131,240,64,130,32,64,130,16,64,194,16,
+  192,66,8,128,96,1,128,48,3,0,28,14,0,7,248,0,
+  6,2,2,8,1,16,252,252,8,7,7,9,0,11,60,102,
+  195,195,195,102,60,12,13,26,14,1,0,6,0,6,0,6,
+  0,6,0,255,240,255,240,6,0,6,0,6,0,6,0,0,
+  0,255,240,255,240,7,10,10,7,0,8,60,126,198,6,12,
+  24,48,96,254,254,7,10,10,7,0,8,124,254,198,6,60,
+  60,6,198,254,124,5,4,4,7,1,15,24,48,96,192,10,
+  19,38,14,2,251,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,193,192,227,192,254,192,220,
+  192,192,0,192,0,192,0,192,0,192,0,10,24,48,12,1,
+  251,31,192,127,192,125,128,253,128,253,128,253,128,253,128,253,
+  128,253,128,125,128,125,128,61,128,13,128,13,128,13,128,13,
+  128,13,128,13,128,13,128,13,128,13,128,13,128,13,128,13,
+  128,2,3,3,6,2,6,192,192,192,5,6,6,7,1,251,
+  96,112,24,24,248,112,4,10,10,7,0,8,48,48,240,240,
+  48,48,48,48,48,48,7,12,12,9,1,7,56,108,198,198,
+  198,198,198,108,56,0,254,254,9,8,16,14,3,3,204,0,
+  102,0,51,0,25,128,25,128,51,0,102,0,204,0,18,18,
+  54,19,1,0,48,24,0,48,24,0,240,48,0,240,48,0,
+  48,96,0,48,96,0,48,192,0,48,192,0,49,131,0,49,
+  135,0,3,15,0,3,15,0,6,27,0,6,51,0,12,127,
+  192,12,127,192,24,3,0,24,3,0,18,18,54,19,1,0,
+  48,24,0,48,24,0,240,48,0,240,48,0,48,96,0,48,
+  96,0,48,192,0,48,192,0,49,135,128,49,143,192,3,24,
+  192,3,0,192,6,1,128,6,3,0,12,6,0,12,12,0,
+  24,31,192,24,31,192,19,18,54,19,0,0,124,12,0,254,
+  12,0,198,24,0,6,24,0,60,48,0,60,48,0,6,96,
+  0,198,96,0,254,193,128,124,195,128,1,135,128,1,135,128,
+  3,13,128,3,25,128,6,63,224,6,63,224,12,1,128,12,
+  1,128,10,19,38,12,1,251,12,0,12,0,12,0,0,0,
+  0,0,12,0,12,0,12,0,12,0,24,0,56,0,112,0,
+  96,0,224,192,192,192,193,192,227,128,127,128,62,0,15,24,
+  48,17,1,0,12,0,6,0,3,0,1,128,0,0,3,128,
+  3,128,6,192,6,192,12,64,12,96,12,96,24,48,24,48,
+  24,48,48,24,63,248,63,248,96,12,96,12,96,12,192,6,
+  192,6,192,6,15,24,48,17,1,0,0,96,0,192,1,128,
+  3,0,0,0,3,128,3,128,6,192,6,192,12,64,12,96,
+  12,96,24,48,24,48,24,48,48,24,63,248,63,248,96,12,
+  96,12,96,12,192,6,192,6,192,6,15,24,48,17,1,0,
+  1,128,3,192,6,96,12,48,0,0,3,128,3,128,6,192,
+  6,192,12,64,12,96,12,96,24,48,24,48,24,48,48,24,
+  63,248,63,248,96,12,96,12,96,12,192,6,192,6,192,6,
+  15,23,46,17,1,0,7,16,13,176,8,224,0,0,3,128,
+  3,128,6,192,6,192,12,64,12,96,12,96,24,48,24,48,
+  24,48,48,24,63,248,63,248,96,12,96,12,96,12,192,6,
+  192,6,192,6,15,23,46,17,1,0,12,96,12,96,0,0,
+  0,0,3,128,3,128,6,192,6,192,12,64,12,96,12,96,
+  24,48,24,48,24,48,48,24,63,248,63,248,96,12,96,12,
+  96,12,192,6,192,6,192,6,15,24,48,17,1,0,3,128,
+  4,64,4,64,3,128,0,0,3,128,3,128,6,192,6,192,
+  12,64,12,96,12,96,24,48,24,48,24,48,48,24,63,248,
+  63,248,96,12,96,12,96,12,192,6,192,6,192,6,21,19,
+  57,23,1,0,3,255,248,3,255,248,6,96,0,6,96,0,
+  12,96,0,12,96,0,12,96,0,24,96,0,24,127,248,24,
+  127,248,48,96,0,63,224,0,63,224,0,96,96,0,96,96,
+  0,96,96,0,192,96,0,192,127,248,192,127,248,15,24,48,
+  18,1,251,7,224,31,248,60,60,112,14,96,6,224,6,192,
+  0,192,0,192,0,192,0,192,0,192,0,192,0,224,6,96,
+  6,112,14,60,60,31,248,7,224,1,128,0,192,0,192,7,
+  192,3,128,12,24,48,16,2,0,48,0,24,0,12,0,6,
+  0,0,0,255,240,255,240,192,0,192,0,192,0,192,0,192,
+  0,192,0,255,224,255,224,192,0,192,0,192,0,192,0,192,
+  0,192,0,192,0,255,240,255,240,12,24,48,16,2,0,1,
+  128,3,0,6,0,12,0,0,0,255,240,255,240,192,0,192,
+  0,192,0,192,0,192,0,192,0,255,224,255,224,192,0,192,
+  0,192,0,192,0,192,0,192,0,192,0,255,240,255,240,12,
+  24,48,16,2,0,6,0,15,0,25,128,48,192,0,0,255,
+  240,255,240,192,0,192,0,192,0,192,0,192,0,192,0,255,
+  224,255,224,192,0,192,0,192,0,192,0,192,0,192,0,192,
+  0,255,240,255,240,12,23,46,16,2,0,24,192,24,192,0,
+  0,0,0,255,240,255,240,192,0,192,0,192,0,192,0,192,
+  0,192,0,255,224,255,224,192,0,192,0,192,0,192,0,192,
+  0,192,0,192,0,255,240,255,240,5,24,24,8,1,0,192,
+  96,48,24,0,48,48,48,48,48,48,48,48,48,48,48,48,
+  48,48,48,48,48,48,48,5,24,24,8,2,0,24,48,96,
+  192,0,96,96,96,96,96,96,96,96,96,96,96,96,96,96,
+  96,96,96,96,96,8,24,24,8,0,0,24,60,102,195,0,
+  24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
+  24,24,24,6,23,23,8,1,0,204,204,0,0,48,48,48,
+  48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,
+  18,19,57,18,255,0,31,248,0,31,254,0,24,15,0,24,
+  3,128,24,1,128,24,1,192,24,0,192,24,0,192,255,128,
+  192,255,128,192,24,0,192,24,0,192,24,0,192,24,1,192,
+  24,1,128,24,3,128,24,15,0,31,254,0,31,248,0,14,
+  23,46,18,2,0,14,32,27,96,17,192,0,0,224,12,240,
+  12,240,12,216,12,220,12,204,12,206,12,198,12,199,12,195,
+  12,195,140,193,140,193,204,192,204,192,236,192,108,192,60,192,
+  60,192,28,16,24,48,18,1,0,12,0,6,0,3,0,1,
+  128,0,0,7,224,31,248,60,60,112,14,96,6,224,7,192,
+  3,192,3,192,3,192,3,192,3,192,3,192,3,224,7,96,
+  6,112,14,60,60,31,248,7,224,16,24,48,18,1,0,0,
+  48,0,96,0,192,1,128,0,0,7,224,31,248,60,60,112,
+  14,96,6,224,7,192,3,192,3,192,3,192,3,192,3,192,
+  3,192,3,224,7,96,6,112,14,60,60,31,248,7,224,16,
+  24,48,18,1,0,0,192,1,224,3,48,6,24,0,0,7,
+  224,31,248,60,60,112,14,96,6,224,7,192,3,192,3,192,
+  3,192,3,192,3,192,3,192,3,224,7,96,6,112,14,60,
+  60,31,248,7,224,16,23,46,18,1,0,3,136,6,216,4,
+  112,0,0,7,224,31,248,60,60,112,14,96,6,224,7,192,
+  3,192,3,192,3,192,3,192,3,192,3,192,3,224,7,96,
+  6,112,14,60,60,31,248,7,224,16,23,46,18,1,0,6,
+  48,6,48,0,0,0,0,7,224,31,248,60,60,112,14,96,
+  6,224,7,192,3,192,3,192,3,192,3,192,3,192,3,192,
+  3,224,7,96,6,112,14,60,60,31,248,7,224,13,12,24,
+  14,0,1,192,24,96,48,48,96,24,192,13,128,7,0,7,
+  0,13,128,24,192,48,96,96,48,192,24,18,19,57,18,0,
+  0,3,240,192,15,253,192,30,31,128,56,7,0,48,15,0,
+  112,29,128,96,57,128,96,113,128,96,225,128,97,193,128,99,
+  129,128,103,1,128,110,1,128,124,3,128,56,3,0,56,7,
+  0,126,30,0,239,252,0,195,240,0,14,24,48,18,2,0,
+  24,0,12,0,6,0,3,0,0,0,192,12,192,12,192,12,
+  192,12,192,12,192,12,192,12,192,12,192,12,192,12,192,12,
+  192,12,192,12,192,12,192,12,96,24,112,56,63,240,15,192,
+  14,24,48,18,2,0,0,96,0,192,1,128,3,0,0,0,
+  192,12,192,12,192,12,192,12,192,12,192,12,192,12,192,12,
+  192,12,192,12,192,12,192,12,192,12,192,12,192,12,96,24,
+  112,56,63,240,15,192,14,24,48,18,2,0,3,0,7,128,
+  12,192,24,96,0,0,192,12,192,12,192,12,192,12,192,12,
+  192,12,192,12,192,12,192,12,192,12,192,12,192,12,192,12,
+  192,12,192,12,96,24,112,56,63,240,15,192,14,23,46,18,
+  2,0,24,192,24,192,0,0,0,0,192,12,192,12,192,12,
+  192,12,192,12,192,12,192,12,192,12,192,12,192,12,192,12,
+  192,12,192,12,192,12,192,12,96,24,112,56,63,240,15,192,
+  14,24,48,16,1,0,0,96,0,192,1,128,3,0,0,0,
+  192,12,224,28,96,24,112,56,48,48,56,112,24,96,28,224,
+  12,192,15,192,7,128,7,128,3,0,3,0,3,0,3,0,
+  3,0,3,0,3,0,13,19,38,16,2,0,192,0,192,0,
+  192,0,192,0,255,224,255,240,192,48,192,24,192,24,192,24,
+  192,24,192,48,255,240,255,224,192,0,192,0,192,0,192,0,
+  192,0,10,19,38,15,3,0,28,0,127,0,227,0,193,128,
+  193,128,193,128,195,0,199,0,206,0,207,0,195,128,193,128,
+  192,192,192,192,192,192,193,128,195,128,207,0,206,0,11,19,
+  38,13,1,0,24,0,12,0,6,0,3,0,0,0,31,0,
+  63,128,97,192,96,192,0,192,7,192,63,192,120,192,224,192,
+  192,192,193,192,227,192,126,224,60,96,11,19,38,13,1,0,
+  1,128,3,0,6,0,12,0,0,0,31,0,63,128,97,192,
+  96,192,0,192,7,192,63,192,120,192,224,192,192,192,193,192,
+  227,192,126,224,60,96,11,19,38,13,1,0,12,0,30,0,
+  51,0,97,128,0,0,31,0,63,128,97,192,96,192,0,192,
+  7,192,63,192,120,192,224,192,192,192,193,192,227,192,126,224,
+  60,96,11,18,36,13,1,0,28,64,54,192,35,128,0,0,
+  31,0,63,128,97,192,96,192,0,192,7,192,63,192,120,192,
+  224,192,192,192,193,192,227,192,126,224,60,96,11,18,36,13,
+  1,0,51,0,51,0,0,0,0,0,31,0,63,128,97,192,
+  96,192,0,192,7,192,63,192,120,192,224,192,192,192,193,192,
+  227,192,126,224,60,96,11,19,38,13,1,0,6,0,9,0,
+  9,0,6,0,0,0,31,0,63,128,97,192,96,192,0,192,
+  7,192,63,192,120,192,224,192,192,192,193,192,227,192,126,224,
+  60,96,19,14,42,21,1,0,31,14,0,63,191,128,97,241,
+  192,96,224,192,0,192,96,7,192,96,63,255,224,120,255,224,
+  224,192,0,192,192,0,193,224,96,227,240,224,126,63,192,60,
+  15,0,10,19,38,12,1,251,31,0,63,128,113,192,96,192,
+  224,0,192,0,192,0,192,0,192,0,224,0,96,192,113,192,
+  63,128,31,0,12,0,6,0,6,0,62,0,28,0,11,19,
+  38,13,1,0,24,0,12,0,6,0,3,0,0,0,14,0,
+  63,128,113,192,96,192,192,96,192,96,255,224,255,224,192,0,
+  192,0,96,96,112,224,63,192,15,0,11,19,38,13,1,0,
+  3,0,6,0,12,0,24,0,0,0,14,0,63,128,113,192,
+  96,192,192,96,192,96,255,224,255,224,192,0,192,0,96,96,
+  112,224,63,192,15,0,11,19,38,13,1,0,12,0,30,0,
+  51,0,97,128,0,0,14,0,63,128,113,192,96,192,192,96,
+  192,96,255,224,255,224,192,0,192,0,96,96,112,224,63,192,
+  15,0,11,18,36,13,1,0,51,0,51,0,0,0,0,0,
+  14,0,63,128,113,192,96,192,192,96,192,96,255,224,255,224,
+  192,0,192,0,96,96,112,224,63,192,15,0,5,19,19,6,
+  0,0,192,96,48,24,0,48,48,48,48,48,48,48,48,48,
+  48,48,48,48,48,5,19,19,6,1,0,24,48,96,192,0,
+  96,96,96,96,96,96,96,96,96,96,96,96,96,96,8,19,
+  19,6,255,0,24,60,102,195,0,24,24,24,24,24,24,24,
+  24,24,24,24,24,24,24,6,18,18,6,0,0,204,204,0,
+  0,48,48,48,48,48,48,48,48,48,48,48,48,48,48,11,
+  19,38,13,1,0,96,0,57,128,14,0,30,0,99,0,31,
+  128,63,128,113,192,96,192,224,224,192,96,192,96,192,96,192,
+  96,224,224,96,192,113,192,63,128,31,0,10,18,36,14,2,
+  0,56,128,109,128,71,0,0,0,206,0,223,128,241,128,224,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,11,19,38,13,1,0,24,0,12,0,6,
+  0,3,0,0,0,31,0,63,128,113,192,96,192,224,224,192,
+  96,192,96,192,96,192,96,224,224,96,192,113,192,63,128,31,
+  0,11,19,38,13,1,0,3,0,6,0,12,0,24,0,0,
+  0,31,0,63,128,113,192,96,192,224,224,192,96,192,96,192,
+  96,192,96,224,224,96,192,113,192,63,128,31,0,11,19,38,
+  13,1,0,12,0,30,0,51,0,97,128,0,0,31,0,63,
+  128,113,192,96,192,224,224,192,96,192,96,192,96,192,96,224,
+  224,96,192,113,192,63,128,31,0,11,18,36,13,1,0,28,
+  64,54,192,35,128,0,0,31,0,63,128,113,192,96,192,224,
+  224,192,96,192,96,192,96,192,96,224,224,96,192,113,192,63,
+  128,31,0,11,18,36,13,1,0,51,0,51,0,0,0,0,
+  0,31,0,63,128,113,192,96,192,224,224,192,96,192,96,192,
+  96,192,96,224,224,96,192,113,192,63,128,31,0,12,12,24,
+  14,1,1,6,0,6,0,6,0,0,0,0,0,255,240,255,
+  240,0,0,0,0,6,0,6,0,6,0,13,14,28,13,0,
+  0,15,152,31,248,56,112,48,224,113,240,99,176,99,48,102,
+  48,108,48,124,112,56,96,112,224,255,192,207,128,10,19,38,
+  14,2,0,48,0,24,0,12,0,6,0,0,0,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,193,192,99,192,126,192,28,192,10,19,38,14,2,0,3,
+  0,6,0,12,0,24,0,0,0,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,193,192,99,
+  192,126,192,28,192,10,19,38,14,2,0,12,0,30,0,51,
+  0,97,128,0,0,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,193,192,99,192,126,192,28,
+  192,10,18,36,14,2,0,51,0,51,0,0,0,0,0,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,193,192,99,192,126,192,28,192,12,24,48,13,0,
+  251,0,192,1,128,3,0,6,0,0,0,192,48,192,48,96,
+  48,112,96,48,96,56,224,24,192,24,192,13,128,13,128,7,
+  128,7,0,3,0,3,0,6,0,6,0,12,0,60,0,56,
+  0,11,24,48,14,2,251,192,0,192,0,192,0,192,0,192,
+  0,207,0,223,128,241,192,224,192,192,224,192,96,192,96,192,
+  96,192,96,192,224,224,192,241,192,223,128,207,0,192,0,192,
+  0,192,0,192,0,192,0,12,23,46,13,0,251,25,128,25,
+  128,0,0,0,0,192,48,192,48,96,48,112,96,48,96,56,
+  224,24,192,24,192,13,128,13,128,7,128,7,0,3,0,3,
+  0,6,0,6,0,12,0,60,0,56,0
+};
+
+#endif // HAS_GRAPHICAL_TFT
diff --git a/Marlin/src/lcd/tft/fontdata/profont_22.cpp b/Marlin/src/lcd/tft/fontdata/profont_22.cpp
new file mode 100644
index 0000000000..1d02ebb069
--- /dev/null
+++ b/Marlin/src/lcd/tft/fontdata/profont_22.cpp
@@ -0,0 +1,426 @@
+/*
+  Fontname: ProFont22
+  Copyright: ProFont Distribution 2.2 Ñ Generated by Fontographer 4.1.5
+  Capital A Height: 14, '1' Height: 14
+  Calculated Max Values w=12 h=22 x= 6 y=12 dx=12 dy= 0 ascent=18 len=44
+  Font Bounding box     w=12 h=21 x= 0 y=-4
+  Calculated Min Values           x= 0 y=-4 dx= 0 dy= 0
+  Pure Font   ascent =14 descent=-4
+  X Font      ascent =16 descent=-4
+  Max Font    ascent =18 descent=-4
+*/
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include <stdint.h>
+
+extern const uint8_t ProFont22[6454] = {
+  0,12,21,0,252,14,3,117,7,113,32,255,252,18,252,16,
+  252,0,0,0,12,0,0,2,14,14,12,4,0,192,192,192,
+  192,192,192,192,192,192,192,0,0,192,192,6,6,6,12,2,
+  10,204,204,204,204,204,204,10,10,20,12,0,4,51,0,51,
+  0,255,192,255,192,51,0,51,0,255,192,255,192,51,0,51,
+  0,10,18,36,12,0,254,12,0,12,0,63,0,127,128,237,
+  192,204,192,204,0,236,0,127,0,63,128,13,192,12,192,204,
+  192,237,192,127,128,63,0,12,0,12,0,10,14,28,12,0,
+  0,63,192,127,192,204,192,205,192,207,128,207,0,127,0,63,
+  128,60,192,124,192,236,192,204,192,199,128,195,0,10,14,28,
+  12,0,0,62,0,127,0,227,0,199,0,206,0,252,0,120,
+  0,120,0,252,192,207,192,199,128,231,128,127,192,60,192,2,
+  6,6,12,4,10,192,192,192,192,192,192,6,18,18,12,2,
+  254,12,28,56,112,224,192,192,192,192,192,192,192,192,224,112,
+  56,28,12,6,18,18,12,2,254,192,224,112,56,28,12,12,
+  12,12,12,12,12,12,28,56,112,224,192,10,10,20,12,0,
+  4,12,0,12,0,204,192,255,192,63,0,63,0,255,192,204,
+  192,12,0,12,0,10,10,20,12,0,2,12,0,12,0,12,
+  0,12,0,255,192,255,192,12,0,12,0,12,0,12,0,5,
+  9,9,12,2,252,48,120,120,56,24,56,112,224,64,6,2,
+  2,12,2,6,252,252,4,4,4,12,3,1,96,240,240,96,
+  11,20,40,12,0,252,0,96,0,96,0,192,0,192,1,128,
+  1,128,3,0,3,0,6,0,6,0,12,0,12,0,24,0,
+  24,0,48,0,48,0,96,0,96,0,192,0,192,0,10,14,
+  28,12,0,0,63,0,127,128,225,192,193,192,195,192,199,192,
+  206,192,220,192,248,192,240,192,224,192,225,192,127,128,63,0,
+  10,14,28,12,0,0,12,0,12,0,124,0,124,0,12,0,
+  12,0,12,0,12,0,12,0,12,0,12,0,12,0,255,192,
+  255,192,10,14,28,12,0,0,63,0,127,128,225,192,192,192,
+  0,192,1,192,3,128,7,0,14,0,28,0,56,0,112,0,
+  255,192,255,192,10,14,28,12,0,0,63,0,127,128,225,192,
+  192,192,0,192,1,128,15,0,15,128,1,192,0,192,192,192,
+  225,192,127,128,63,0,10,14,28,12,0,0,3,0,7,0,
+  15,0,31,0,59,0,115,0,227,0,195,0,255,192,255,192,
+  3,0,3,0,15,192,15,192,10,14,28,12,0,0,255,192,
+  255,192,192,0,192,0,255,0,255,128,1,192,0,192,0,192,
+  0,192,192,192,225,192,127,128,63,0,10,14,28,12,0,0,
+  63,0,127,0,224,0,192,0,255,0,255,128,193,192,192,192,
+  192,192,192,192,192,192,225,192,127,128,63,0,10,14,28,12,
+  0,0,255,192,255,192,0,192,0,192,0,192,1,192,3,128,
+  7,0,14,0,12,0,12,0,12,0,12,0,12,0,10,14,
+  28,12,0,0,63,0,127,128,225,192,192,192,192,192,97,128,
+  63,0,127,128,225,192,192,192,192,192,225,192,127,128,63,0,
+  10,14,28,12,0,0,63,0,127,128,225,192,192,192,192,192,
+  192,192,192,192,224,192,127,192,63,192,0,192,1,192,63,128,
+  63,0,4,10,10,12,3,1,96,240,240,96,0,0,96,240,
+  240,96,5,15,15,12,2,252,48,120,120,48,0,0,48,120,
+  120,56,24,56,112,224,64,8,14,14,12,2,0,3,7,14,
+  28,56,112,224,224,112,56,28,14,7,3,10,6,12,12,0,
+  4,255,192,255,192,0,0,0,0,255,192,255,192,8,14,14,
+  12,2,0,192,224,112,56,28,14,7,7,14,28,56,112,224,
+  192,10,14,28,12,0,0,63,0,127,128,225,192,192,192,0,
+  192,1,192,3,128,7,0,14,0,12,0,0,0,0,0,12,
+  0,12,0,10,14,28,12,0,0,63,0,127,128,225,192,192,
+  192,199,192,207,192,204,192,204,192,207,192,199,128,192,0,224,
+  0,127,192,63,192,10,14,28,12,0,0,12,0,30,0,30,
+  0,51,0,51,0,97,128,97,128,192,192,255,192,255,192,192,
+  192,192,192,192,192,192,192,10,14,28,12,0,0,255,0,255,
+  128,193,192,192,192,192,192,193,128,255,0,255,128,193,192,192,
+  192,192,192,193,192,255,128,255,0,10,14,28,12,0,0,63,
+  0,127,128,225,192,192,192,192,0,192,0,192,0,192,0,192,
+  0,192,0,192,192,225,192,127,128,63,0,10,14,28,12,0,
+  0,255,0,255,128,193,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,193,192,255,128,255,0,10,14,28,
+  12,0,0,255,192,255,192,192,0,192,0,192,0,192,0,255,
+  0,255,0,192,0,192,0,192,0,192,0,255,192,255,192,10,
+  14,28,12,0,0,255,192,255,192,192,0,192,0,192,0,192,
+  0,255,0,255,0,192,0,192,0,192,0,192,0,192,0,192,
+  0,10,14,28,12,0,0,63,0,127,128,225,192,192,192,192,
+  0,192,0,195,192,195,192,192,192,192,192,192,192,225,192,127,
+  128,63,0,10,14,28,12,0,0,192,192,192,192,192,192,192,
+  192,192,192,192,192,255,192,255,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,10,14,28,12,0,0,255,192,255,192,12,
+  0,12,0,12,0,12,0,12,0,12,0,12,0,12,0,12,
+  0,12,0,255,192,255,192,10,14,28,12,0,0,0,192,0,
+  192,0,192,0,192,0,192,0,192,0,192,0,192,192,192,192,
+  192,192,192,225,192,127,128,63,0,10,14,28,12,0,0,193,
+  192,195,128,199,0,206,0,220,0,248,0,240,0,248,0,220,
+  0,206,0,199,0,195,128,193,192,192,192,10,14,28,12,0,
+  0,192,0,192,0,192,0,192,0,192,0,192,0,192,0,192,
+  0,192,0,192,0,192,0,192,0,255,192,255,192,10,14,28,
+  12,0,0,192,192,225,192,243,192,255,192,222,192,204,192,204,
+  192,204,192,192,192,192,192,192,192,192,192,192,192,192,192,10,
+  14,28,12,0,0,192,192,224,192,240,192,248,192,220,192,206,
+  192,199,192,195,192,193,192,192,192,192,192,192,192,192,192,192,
+  192,10,14,28,12,0,0,63,0,127,128,225,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,225,192,127,
+  128,63,0,10,14,28,12,0,0,255,0,255,128,193,192,192,
+  192,192,192,193,192,255,128,255,0,192,0,192,0,192,0,192,
+  0,192,0,192,0,10,16,32,12,0,254,63,0,127,128,225,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,204,
+  192,239,192,127,128,63,128,1,192,0,192,10,14,28,12,0,
+  0,255,0,255,128,193,192,192,192,192,192,193,128,255,0,255,
+  128,193,192,192,192,192,192,192,192,192,192,192,192,10,14,28,
+  12,0,0,63,0,127,128,225,192,192,192,192,0,224,0,127,
+  0,63,128,1,192,0,192,192,192,225,192,127,128,63,0,10,
+  14,28,12,0,0,255,192,255,192,12,0,12,0,12,0,12,
+  0,12,0,12,0,12,0,12,0,12,0,12,0,12,0,12,
+  0,10,14,28,12,0,0,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,225,192,127,
+  128,63,0,10,14,28,12,0,0,192,192,192,192,192,192,192,
+  192,192,192,192,192,97,128,97,128,51,0,51,0,30,0,30,
+  0,12,0,12,0,10,14,28,12,0,0,192,192,192,192,192,
+  192,192,192,192,192,192,192,204,192,204,192,204,192,222,192,255,
+  192,243,192,225,192,192,192,10,14,28,12,0,0,192,192,192,
+  192,192,192,225,192,115,128,63,0,30,0,30,0,63,0,115,
+  128,225,192,192,192,192,192,192,192,10,14,28,12,0,0,192,
+  192,192,192,192,192,192,192,192,192,225,192,115,128,63,0,30,
+  0,12,0,12,0,12,0,12,0,12,0,10,14,28,12,0,
+  0,255,192,255,192,0,192,1,192,3,128,7,0,14,0,28,
+  0,56,0,112,0,224,0,192,0,255,192,255,192,4,18,18,
+  12,4,254,240,240,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,240,240,11,20,40,12,1,252,192,0,192,0,96,
+  0,96,0,48,0,48,0,24,0,24,0,12,0,12,0,6,
+  0,6,0,3,0,3,0,1,128,1,128,0,192,0,192,0,
+  96,0,96,4,18,18,12,2,254,240,240,48,48,48,48,48,
+  48,48,48,48,48,48,48,48,48,240,240,10,6,12,12,0,
+  8,12,0,30,0,63,0,115,128,225,192,64,128,12,2,4,
+  12,0,252,255,240,255,240,4,4,4,12,2,12,192,224,112,
+  48,10,10,20,12,0,0,63,192,127,192,224,192,192,192,192,
+  192,193,192,195,192,231,192,126,192,60,192,10,14,28,12,0,
+  0,192,0,192,0,192,0,192,0,255,0,255,128,193,192,192,
+  192,192,192,192,192,192,192,193,192,255,128,255,0,10,10,20,
+  12,0,0,63,0,127,128,225,192,192,192,192,0,192,0,192,
+  0,224,0,127,192,63,192,10,14,28,12,0,0,0,192,0,
+  192,0,192,0,192,63,192,127,192,224,192,192,192,192,192,192,
+  192,192,192,224,192,127,192,63,192,10,10,20,12,0,0,63,
+  0,127,128,225,192,192,192,255,192,255,192,192,0,224,0,127,
+  192,63,192,8,14,14,12,2,0,15,31,56,48,252,252,48,
+  48,48,48,48,48,48,48,10,14,28,12,0,252,63,192,127,
+  192,224,192,192,192,192,192,192,192,192,192,224,192,127,192,63,
+  192,0,192,1,192,63,128,63,0,10,14,28,12,0,0,192,
+  0,192,0,192,0,192,0,255,0,255,128,193,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,6,14,14,12,2,
+  0,48,48,0,0,240,240,48,48,48,48,48,48,252,252,6,
+  18,18,12,0,252,12,12,0,0,60,60,12,12,12,12,12,
+  12,12,12,12,28,248,240,10,14,28,12,0,0,192,0,192,
+  0,192,0,192,0,195,128,199,0,206,0,220,0,252,0,254,
+  0,231,0,195,128,193,192,192,192,6,14,14,12,2,0,240,
+  240,48,48,48,48,48,48,48,48,48,48,252,252,10,10,20,
+  12,0,0,255,0,255,128,205,192,204,192,204,192,204,192,204,
+  192,204,192,204,192,204,192,10,10,20,12,0,0,207,0,223,
+  128,249,192,240,192,224,192,192,192,192,192,192,192,192,192,192,
+  192,10,10,20,12,0,0,63,0,127,128,225,192,192,192,192,
+  192,192,192,192,192,225,192,127,128,63,0,10,14,28,12,0,
+  252,255,0,255,128,193,192,192,192,192,192,192,192,192,192,193,
+  192,255,128,255,0,192,0,192,0,192,0,192,0,10,14,28,
+  12,0,252,63,192,127,192,224,192,192,192,192,192,192,192,192,
+  192,224,192,127,192,63,192,0,192,0,192,0,192,0,192,10,
+  10,20,12,0,0,207,0,223,128,249,192,240,192,224,0,192,
+  0,192,0,192,0,192,0,192,0,10,10,20,12,0,0,63,
+  192,127,192,192,0,192,0,127,0,63,128,0,192,0,192,255,
+  128,255,0,8,14,14,12,2,0,48,48,48,48,252,252,48,
+  48,48,48,48,56,31,15,10,10,20,12,0,0,192,192,192,
+  192,192,192,192,192,192,192,193,192,195,192,231,192,126,192,60,
+  192,10,10,20,12,0,0,192,192,192,192,192,192,97,128,97,
+  128,51,128,51,0,30,0,30,0,12,0,10,10,20,12,0,
+  0,204,192,204,192,204,192,204,192,204,192,204,192,204,192,204,
+  192,127,128,51,0,10,10,20,12,0,0,192,192,225,192,115,
+  128,63,0,30,0,30,0,63,0,115,128,225,192,192,192,10,
+  14,28,12,0,252,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,224,192,127,192,63,192,0,192,1,192,63,128,63,
+  0,10,10,20,12,0,0,255,192,255,192,3,128,7,0,14,
+  0,28,0,56,0,112,0,255,192,255,192,6,22,22,12,2,
+  252,12,28,56,48,48,48,48,48,48,112,224,224,112,48,48,
+  48,48,48,48,56,28,12,2,18,18,12,4,254,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,6,
+  22,22,12,2,252,192,224,112,48,48,48,48,48,48,56,28,
+  28,56,48,48,48,48,48,48,112,224,192,10,4,8,12,0,
+  6,48,192,124,192,207,128,195,0,0,0,0,12,0,0,0,
+  0,0,12,0,0,0,0,0,12,0,0,4,7,7,12,0,
+  253,48,48,48,48,112,224,64,10,22,44,12,0,252,3,192,
+  7,192,14,0,12,0,12,0,12,0,12,0,12,0,63,0,
+  63,0,12,0,12,0,12,0,12,0,12,0,12,0,12,0,
+  12,0,12,0,28,0,248,0,240,0,8,7,7,12,0,253,
+  51,51,51,51,119,238,68,10,2,4,12,0,0,204,192,204,
+  192,6,10,10,12,2,4,48,48,252,252,48,48,48,48,48,
+  48,6,10,10,12,2,4,48,48,252,252,48,48,252,252,48,
+  48,6,4,4,12,2,12,48,120,252,204,12,16,32,12,0,
+  0,63,240,127,240,204,224,205,192,207,128,207,0,126,0,60,
+  0,60,192,127,224,243,48,243,48,179,48,51,48,31,224,12,
+  192,10,18,36,12,0,0,51,0,63,0,30,0,12,0,63,
+  0,127,128,225,192,192,192,192,0,224,0,127,0,63,128,1,
+  192,0,192,192,192,225,192,127,128,63,0,4,10,10,12,0,
+  255,48,112,96,224,192,192,224,96,112,48,10,14,28,12,0,
+  0,63,192,127,192,236,0,204,0,204,0,204,0,207,0,207,
+  0,204,0,204,0,204,0,236,0,127,192,63,192,0,0,0,
+  12,0,0,0,0,0,12,0,0,0,0,0,12,0,0,0,
+  0,0,12,0,0,4,7,7,12,4,8,32,112,224,192,192,
+  192,192,4,7,7,12,4,7,48,48,48,48,112,224,64,8,
+  7,7,12,2,8,34,119,238,204,204,204,204,8,7,7,12,
+  2,7,51,51,51,51,119,238,68,10,10,20,12,0,2,30,
+  0,127,128,127,128,255,192,255,192,255,192,255,192,127,128,127,
+  128,30,0,6,2,2,12,2,6,252,252,12,2,4,12,0,
+  6,255,240,255,240,10,4,8,12,0,12,48,192,124,192,207,
+  128,195,0,12,6,12,12,0,8,255,48,255,240,51,240,51,
+  240,51,48,51,48,10,16,32,12,0,0,51,0,63,0,30,
+  0,12,0,0,0,0,0,63,192,127,192,192,0,192,0,127,
+  0,63,128,0,192,0,192,255,128,255,0,4,10,10,12,0,
+  255,192,224,96,112,48,48,112,96,224,192,10,10,20,12,0,
+  0,51,0,127,128,204,192,204,192,207,192,207,192,204,0,204,
+  0,127,192,51,192,0,0,0,12,0,0,0,0,0,12,0,
+  0,10,18,36,12,0,0,51,0,51,0,0,0,0,0,192,
+  192,192,192,192,192,192,192,192,192,225,192,115,128,63,0,30,
+  0,12,0,12,0,12,0,12,0,12,0,0,0,0,12,0,
+  0,2,14,14,12,6,0,192,192,0,0,192,192,192,192,192,
+  192,192,192,192,192,10,14,28,12,0,254,12,0,12,0,63,
+  0,127,128,237,192,204,192,204,0,204,0,204,0,236,0,127,
+  192,63,192,12,0,12,0,10,16,32,12,0,0,60,0,126,
+  0,231,0,195,0,192,0,192,0,252,0,252,0,192,0,192,
+  0,192,0,192,0,192,192,193,192,255,128,255,0,10,10,20,
+  12,0,0,64,128,225,192,127,128,63,0,51,0,51,0,63,
+  0,127,128,225,192,64,128,10,14,28,12,0,0,192,192,225,
+  192,115,128,63,0,255,192,255,192,12,0,12,0,255,192,255,
+  192,12,0,12,0,12,0,12,0,2,18,18,12,4,254,192,
+  192,192,192,192,192,192,192,0,0,192,192,192,192,192,192,192,
+  192,10,20,40,12,0,254,31,0,127,128,97,192,224,192,112,
+  192,56,192,220,0,206,0,199,0,227,128,113,192,56,192,28,
+  192,14,192,199,0,195,128,193,192,225,128,127,128,62,0,6,
+  2,2,12,2,12,204,204,10,14,28,12,0,0,120,0,254,
+  0,135,0,1,128,61,128,124,192,192,192,192,192,124,192,61,
+  128,1,128,135,0,254,0,120,0,8,12,12,12,2,6,63,
+  127,227,195,195,227,127,63,0,0,255,255,10,10,20,12,0,
+  255,48,192,113,192,97,128,227,128,195,0,195,0,227,128,97,
+  128,113,192,48,192,10,6,12,12,0,2,255,192,255,192,0,
+  192,0,192,0,192,0,192,10,2,4,12,0,6,255,192,255,
+  192,10,12,24,12,0,2,120,0,254,0,135,0,1,128,241,
+  128,248,192,204,192,204,192,248,192,249,192,223,128,207,0,6,
+  2,2,12,2,12,252,252,8,8,8,12,2,8,60,126,231,
+  195,195,231,126,60,10,12,24,12,0,0,12,0,12,0,12,
+  0,12,0,255,192,255,192,12,0,12,0,12,0,12,0,255,
+  192,255,192,5,7,7,12,3,11,112,136,8,16,32,64,248,
+  5,7,7,12,3,11,112,136,8,48,8,136,112,4,4,4,
+  12,4,12,48,112,224,192,10,14,28,12,0,252,195,0,195,
+  0,195,0,195,0,195,0,195,0,195,0,199,128,255,192,252,
+  192,192,0,192,0,192,0,192,0,10,16,32,12,0,0,31,
+  192,127,192,124,192,236,192,204,192,204,192,236,192,124,192,127,
+  192,31,192,12,192,12,192,12,192,12,192,12,192,12,192,4,
+  4,4,12,4,4,96,240,240,96,4,6,6,12,2,252,240,
+  240,48,112,224,64,5,7,7,12,3,11,32,224,32,32,32,
+  32,248,8,12,12,12,2,6,60,126,231,195,195,231,126,60,
+  0,0,255,255,10,10,20,12,0,255,195,0,227,128,97,128,
+  113,192,48,192,48,192,113,192,97,128,227,128,195,0,12,18,
+  36,12,0,0,16,0,112,0,16,0,16,0,16,16,16,32,
+  124,64,0,128,1,0,2,0,4,0,8,64,16,192,33,64,
+  66,64,131,224,0,64,0,224,12,18,36,12,0,0,16,0,
+  112,0,16,0,16,0,16,16,16,32,124,64,0,128,1,0,
+  2,0,4,0,9,192,18,32,32,32,64,64,128,128,1,0,
+  3,224,12,18,36,12,0,0,56,0,68,0,4,0,24,0,
+  4,16,68,32,56,64,0,128,1,0,2,0,4,0,8,64,
+  16,192,33,64,66,64,131,224,0,64,0,224,10,14,28,12,
+  0,0,12,0,12,0,0,0,0,0,12,0,28,0,56,0,
+  112,0,224,0,192,0,192,192,225,192,127,128,63,0,10,18,
+  36,12,0,0,48,0,56,0,28,0,12,0,12,0,30,0,
+  30,0,51,0,51,0,97,128,97,128,192,192,255,192,255,192,
+  192,192,192,192,192,192,192,192,10,18,36,12,0,0,3,0,
+  7,0,14,0,12,0,12,0,30,0,30,0,51,0,51,0,
+  97,128,97,128,192,192,255,192,255,192,192,192,192,192,192,192,
+  192,192,10,18,36,12,0,0,12,0,30,0,63,0,51,0,
+  12,0,30,0,30,0,51,0,51,0,97,128,97,128,192,192,
+  255,192,255,192,192,192,192,192,192,192,192,192,10,18,36,12,
+  0,0,48,192,124,192,207,128,195,0,12,0,30,0,30,0,
+  51,0,51,0,97,128,97,128,192,192,255,192,255,192,192,192,
+  192,192,192,192,192,192,10,18,36,12,0,0,51,0,51,0,
+  0,0,0,0,12,0,30,0,30,0,51,0,51,0,97,128,
+  97,128,192,192,255,192,255,192,192,192,192,192,192,192,192,192,
+  10,18,36,12,0,0,12,0,30,0,51,0,51,0,30,0,
+  30,0,30,0,51,0,51,0,97,128,97,128,192,192,255,192,
+  255,192,192,192,192,192,192,192,192,192,10,14,28,12,0,0,
+  63,192,127,192,236,0,204,0,204,0,204,0,255,0,255,0,
+  204,0,204,0,204,0,204,0,207,192,207,192,10,18,36,12,
+  0,252,63,0,127,128,225,192,192,192,192,0,192,0,192,0,
+  192,0,192,0,192,0,192,192,225,192,127,128,63,0,12,0,
+  28,0,56,0,16,0,10,18,36,12,0,0,48,0,56,0,
+  28,0,12,0,255,192,255,192,192,0,192,0,192,0,192,0,
+  255,0,255,0,192,0,192,0,192,0,192,0,255,192,255,192,
+  10,18,36,12,0,0,3,0,7,0,14,0,12,0,255,192,
+  255,192,192,0,192,0,192,0,192,0,255,0,255,0,192,0,
+  192,0,192,0,192,0,255,192,255,192,10,18,36,12,0,0,
+  12,0,30,0,63,0,51,0,255,192,255,192,192,0,192,0,
+  192,0,192,0,255,0,255,0,192,0,192,0,192,0,192,0,
+  255,192,255,192,10,18,36,12,0,0,51,0,51,0,0,0,
+  0,0,255,192,255,192,192,0,192,0,192,0,192,0,255,0,
+  255,0,192,0,192,0,192,0,192,0,255,192,255,192,10,18,
+  36,12,0,0,48,0,56,0,28,0,12,0,255,192,255,192,
+  12,0,12,0,12,0,12,0,12,0,12,0,12,0,12,0,
+  12,0,12,0,255,192,255,192,10,18,36,12,0,0,3,0,
+  7,0,14,0,12,0,255,192,255,192,12,0,12,0,12,0,
+  12,0,12,0,12,0,12,0,12,0,12,0,12,0,255,192,
+  255,192,10,18,36,12,0,0,12,0,30,0,63,0,51,0,
+  255,192,255,192,12,0,12,0,12,0,12,0,12,0,12,0,
+  12,0,12,0,12,0,12,0,255,192,255,192,10,18,36,12,
+  0,0,51,0,51,0,0,0,0,0,255,192,255,192,12,0,
+  12,0,12,0,12,0,12,0,12,0,12,0,12,0,12,0,
+  12,0,255,192,255,192,10,14,28,12,0,0,63,0,63,128,
+  49,192,48,192,48,192,48,192,252,192,252,192,48,192,48,192,
+  48,192,49,192,63,128,63,0,10,18,36,12,0,0,48,192,
+  124,192,207,128,199,0,192,192,224,192,240,192,248,192,220,192,
+  206,192,199,192,195,192,193,192,192,192,192,192,192,192,192,192,
+  192,192,10,18,36,12,0,0,48,0,56,0,28,0,12,0,
+  63,0,127,128,225,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,225,192,127,128,63,0,10,18,36,12,
+  0,0,3,0,7,0,14,0,12,0,63,0,127,128,225,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  225,192,127,128,63,0,10,18,36,12,0,0,12,0,30,0,
+  63,0,51,0,0,0,63,0,127,128,225,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,225,192,127,128,63,0,
+  10,18,36,12,0,0,48,192,124,192,207,128,199,0,63,0,
+  127,128,225,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,225,192,127,128,63,0,10,18,36,12,0,0,
+  51,0,51,0,0,0,0,0,63,0,127,128,225,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,225,192,
+  127,128,63,0,10,10,20,12,0,2,64,128,225,192,115,128,
+  63,0,30,0,30,0,63,0,115,128,225,192,64,128,10,14,
+  28,12,0,0,63,0,127,128,225,192,193,192,195,192,199,192,
+  206,192,220,192,248,192,240,192,224,192,225,192,127,128,63,0,
+  10,18,36,12,0,0,48,0,56,0,28,0,12,0,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,225,192,127,128,63,0,10,18,36,12,0,0,
+  3,0,7,0,14,0,12,0,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,225,192,
+  127,128,63,0,10,18,36,12,0,0,12,0,30,0,63,0,
+  51,0,0,0,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,225,192,127,128,63,0,10,18,
+  36,12,0,0,51,0,51,0,0,0,0,0,192,192,192,192,
+  192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,
+  192,192,225,192,127,128,63,0,10,18,36,12,0,0,3,0,
+  7,0,14,0,12,0,192,192,192,192,192,192,192,192,192,192,
+  225,192,115,128,63,0,30,0,12,0,12,0,12,0,12,0,
+  12,0,10,14,28,12,0,0,192,0,192,0,255,0,255,128,
+  193,192,192,192,192,192,193,192,255,128,255,0,192,0,192,0,
+  192,0,192,0,10,18,36,12,0,254,15,0,31,128,57,192,
+  112,192,224,192,193,192,195,128,195,0,195,0,195,128,193,192,
+  192,192,192,192,193,192,207,128,207,0,192,0,192,0,10,16,
+  32,12,0,0,12,0,14,0,7,0,3,0,0,0,0,0,
+  63,192,127,192,224,192,192,192,192,192,193,192,195,192,231,192,
+  126,192,60,192,10,16,32,12,0,0,3,0,7,0,14,0,
+  12,0,0,0,0,0,63,192,127,192,224,192,192,192,192,192,
+  193,192,195,192,231,192,126,192,60,192,10,16,32,12,0,0,
+  12,0,30,0,63,0,51,0,0,0,0,0,63,192,127,192,
+  224,192,192,192,192,192,193,192,195,192,231,192,126,192,60,192,
+  10,16,32,12,0,0,48,192,124,192,207,128,199,0,0,0,
+  0,0,63,192,127,192,224,192,192,192,192,192,193,192,195,192,
+  231,192,126,192,60,192,10,14,28,12,0,0,51,0,51,0,
+  0,0,0,0,63,192,127,192,224,192,192,192,192,192,193,192,
+  195,192,231,192,126,192,60,192,10,16,32,12,0,0,12,0,
+  30,0,51,0,51,0,30,0,12,0,63,192,127,192,224,192,
+  192,192,192,192,193,192,195,192,231,192,126,192,60,192,10,10,
+  20,12,0,0,63,0,127,128,237,192,204,192,207,192,207,192,
+  204,0,236,0,127,192,63,192,10,14,28,12,0,252,63,0,
+  127,128,225,192,192,192,192,0,192,0,192,0,224,0,127,192,
+  63,192,12,0,28,0,56,0,16,0,10,16,32,12,0,0,
+  48,0,56,0,28,0,12,0,0,0,0,0,63,0,127,128,
+  225,192,192,192,255,192,255,192,192,0,224,0,127,192,63,192,
+  10,16,32,12,0,0,3,0,7,0,14,0,12,0,0,0,
+  0,0,63,0,127,128,225,192,192,192,255,192,255,192,192,0,
+  224,0,127,192,63,192,10,16,32,12,0,0,12,0,30,0,
+  63,0,51,0,0,0,0,0,63,0,127,128,225,192,192,192,
+  255,192,255,192,192,0,224,0,127,192,63,192,10,14,28,12,
+  0,0,51,0,51,0,0,0,0,0,63,0,127,128,225,192,
+  192,192,255,192,255,192,192,0,224,0,127,192,63,192,6,16,
+  16,12,2,0,192,224,112,48,0,0,240,240,48,48,48,48,
+  48,48,252,252,6,16,16,12,2,0,12,28,56,48,0,0,
+  240,240,48,48,48,48,48,48,252,252,6,16,16,12,2,0,
+  48,120,252,204,0,0,240,240,48,48,48,48,48,48,252,252,
+  6,14,14,12,2,0,204,204,0,0,240,240,48,48,48,48,
+  48,48,252,252,10,17,34,12,0,0,36,0,126,0,60,0,
+  60,0,126,0,39,0,3,128,63,192,127,192,225,192,192,192,
+  192,192,192,192,192,192,225,192,127,128,63,0,10,16,32,12,
+  0,0,48,192,124,192,207,128,199,0,0,0,0,0,207,0,
+  223,128,249,192,240,192,224,192,192,192,192,192,192,192,192,192,
+  192,192,10,16,32,12,0,0,48,0,56,0,28,0,12,0,
+  0,0,0,0,63,0,127,128,225,192,192,192,192,192,192,192,
+  192,192,225,192,127,128,63,0,10,16,32,12,0,0,3,0,
+  7,0,14,0,12,0,0,0,0,0,63,0,127,128,225,192,
+  192,192,192,192,192,192,192,192,225,192,127,128,63,0,10,16,
+  32,12,0,0,12,0,30,0,63,0,51,0,0,0,0,0,
+  63,0,127,128,225,192,192,192,192,192,192,192,192,192,225,192,
+  127,128,63,0,10,16,32,12,0,0,48,192,124,192,207,128,
+  199,0,0,0,0,0,63,0,127,128,225,192,192,192,192,192,
+  192,192,192,192,225,192,127,128,63,0,10,14,28,12,0,0,
+  51,0,51,0,0,0,0,0,63,0,127,128,225,192,192,192,
+  192,192,192,192,192,192,225,192,127,128,63,0,10,10,20,12,
+  0,2,12,0,12,0,0,0,0,0,255,192,255,192,0,0,
+  0,0,12,0,12,0,10,10,20,12,0,0,63,0,127,128,
+  227,192,199,192,206,192,220,192,248,192,241,192,127,128,63,0,
+  10,16,32,12,0,0,48,0,56,0,28,0,12,0,0,0,
+  0,0,192,192,192,192,192,192,192,192,192,192,193,192,195,192,
+  231,192,126,192,60,192,10,16,32,12,0,0,3,0,7,0,
+  14,0,12,0,0,0,0,0,192,192,192,192,192,192,192,192,
+  192,192,193,192,195,192,231,192,126,192,60,192,10,16,32,12,
+  0,0,12,0,30,0,63,0,51,0,0,0,0,0,192,192,
+  192,192,192,192,192,192,192,192,193,192,195,192,231,192,126,192,
+  60,192,10,14,28,12,0,0,51,0,51,0,0,0,0,0,
+  192,192,192,192,192,192,192,192,192,192,193,192,195,192,231,192,
+  126,192,60,192,10,20,40,12,0,252,3,0,7,0,14,0,
+  12,0,0,0,0,0,192,192,192,192,192,192,192,192,192,192,
+  192,192,192,192,224,192,127,192,63,192,0,192,1,192,63,128,
+  63,0,10,18,36,12,0,252,192,0,192,0,192,0,192,0,
+  255,0,255,128,193,192,192,192,192,192,192,192,192,192,193,192,
+  255,128,255,0,192,0,192,0,192,0,192,0,10,18,36,12,
+  0,252,51,0,51,0,0,0,0,0,192,192,192,192,192,192,
+  192,192,192,192,192,192,192,192,224,192,127,192,63,192,0,192,
+  1,192,63,128,63,0
+};
+
+#endif // HAS_GRAPHICAL_TFT
diff --git a/Marlin/src/module/TG_I2C/TG_I2CSlave.cpp b/Marlin/src/module/TG_I2C/TG_I2CSlave.cpp
new file mode 100644
index 0000000000..c006fd0431
--- /dev/null
+++ b/Marlin/src/module/TG_I2C/TG_I2CSlave.cpp
@@ -0,0 +1,687 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * Based on LPC17xx_I2C.c and adapted for Marlin using I2C1 in Slave Mode to send/receive rpm data packets
+ * Note: lpc17xx_i2c.c and lpc17xx_i2c.h are still required because some of it's functions are called!!
+ * T. Gioiosa 5/12/22
+ * 
+ * Currently only Slave Mode is fully implemented. Marlin is an addressed slave and the Master is the CNC
+ * Speed Controller (AVR128DB28). The CNC Master reads TARGET_RPM (set from LCD via M3,M4,M5 commands) from
+ * Marlin and sends ACTUAL_RPM to Marlin for relay to the LCD. The CNC Master also will read cutter.spindle_use_pid
+ * flag and other flag info from Marlin for the CNC speed controller to use.
+
+ * Description: Customized I2C driver for LPC1769
+ */
+
+
+
+#include <src/MarlinCore.h>
+#include <src/inc/MarlinConfig.h>
+
+#if ENABLED(TG_I2C_SUPPORT)	//TG 12/16/22
+#include <lpc17xx_i2c.h>
+#include <LPC17xx.h>
+#include <lpc17xx_pinsel.h>
+#include <lpc17xx_gpio.h>
+#include "../../feature/spindle_laser.h"
+#include "../../gcode/config/M7979.h"
+#include "TG_I2CSlave.h"
+#include <src/module/planner.h>
+#include "src/HAL/shared/Delay.h"		// only needed if using delay_us()
+
+#ifndef USEDI2CDEV_M								// Choose which LPC1769 I2C peripheral will be used (0, 1, or 2)
+  #define USEDI2CDEV_M -1						// -1 means not selected
+#endif
+#ifndef USEDI2CDEV_S
+	#define USEDI2CDEV_S 1						// using I2C1 interface for slave
+#endif
+
+#pragma region Set I2CDEV_M and I2CDEV_S to which I2C Peripheral is being used and set up IRQ handlers
+#if (USEDI2CDEV_M == 0)
+  #define I2CDEV_M LPC_I2C0
+#elif (USEDI2CDEV_M == 1)
+  #define I2CDEV_M LPC_I2C1
+#elif (USEDI2CDEV_M == 2)
+  #define I2CDEV_M LPC_I2C2
+#else
+  #define I2CDEV_M NULL
+	#warning "Master I2C device not used!"
+#endif
+
+#if (USEDI2CDEV_S == 0)
+  #define I2CDEV_S LPC_I2C0
+#elif (USEDI2CDEV_S == 1)
+  #define I2CDEV_S LPC_I2C1
+#elif (USEDI2CDEV_S == 2)
+  #define I2CDEV_S LPC_I2C2
+#else
+#define I2CDEV_S NULL
+  #warning "Slave I2C device not used!"
+#endif
+
+#if (USEDI2CDEV_M == USEDI2CDEV_S)
+  #error "Master and Slave I2C device are duplicated!"
+#endif
+
+#if ((USEDI2CDEV_M == 0) || (USEDI2CDEV_S == 0))
+  #define I2C_ISR()  extern "C" void I2C0_IRQHandler()		// define the I2C handler to be I2C_ISR()
+#elif ((USEDI2CDEV_M == 1) || (USEDI2CDEV_S == 1))
+	#define I2C_ISR()  extern "C" void I2C1_IRQHandler()		// define the I2C handler to be I2C_ISR()
+#elif ((USEDI2CDEV_M == 2) || (USEDI2CDEV_S == 2))
+	#define I2C_ISR()  extern "C" void I2C2_IRQHandler()		// define the I2C handler to be I2C_ISR()
+#endif
+#pragma endregion
+
+/** These global variables below used in interrupt mode -----------*/
+#pragma region Global variables
+__IO FlagStatus complete_M;
+__IO FlagStatus complete_S;
+I2C_S_SETUP_Type transferSCfg;      //TG data transfer struct for blocking interrupt or polled mode
+																		// not needed for Full Interrupt mode
+I2C_RX_buffer rx_int_buf;						// circular receive buffer
+I2C_TX_buffer tx_int_buf;						// circular transmit buffer
+volatile uint8_t COMMAND;						// command byte received from a Master device
+char logMsg[100];										// string buffer for sprintf() messages
+i2cStat RetStatus;									// used in mySlaveHandler, it's global here so we can view while debugging
+volatile I2C_dir_type I2C_dir;			// direction, made global in case other code needs to use it
+
+typedef union  {
+    float f;
+		uint16_t i;
+		uint8_t b;
+    unsigned char a[sizeof (float) ];
+}floatunion_t;
+
+//volatile uint16_t TARGET_RPM = 0;	//TG 12/16/22  moved to SpindleLaser class
+//volatile uint16_t ACTUAL_RPM = 0; //TG 12/16/22  moved to SpindleLaser class
+
+floatunion_t TRPM_u;				// union is used so we can access members as integer, byte, float, or float as a byte array
+floatunion_t ARPM_u;
+
+#pragma endregion
+//TG to generate scope signals use WRITE(P2_12,1) / //WRITE(P2_12,0) 
+//TG ***** Beware when enabling port pins for scope signals used to debug! Observe the following precautions for unused J8 signals:
+//				P1_22	-	VACUUM ENABLE RELAY
+//				P1_23 - previously PWM MOTOR DRIVE (not used with new AVR Triac Controller)
+//				P2_11 - SPINDLE ENABLE RELAY
+//				P2_12 - SPINDLE DIR (not used)
+//				P4_28 - (not used)
+//   DO NOT USE ANY OF THE ABOVE PINS AS SCOPE SIGNALS IN RELEASE VERSION!!
+//TG *******************************************************************************************************************************
+
+//TG ***** Main ISR routine for interrupt-driven I2C mode (this is preferred mode) *****
+I2C_ISR()
+{
+	#if (USEDI2CDEV_M == 1)		 // *************** MASTER Mode ********************
+		I2C_MasterHandler(I2CDEV_M);
+		if (I2C_MasterTransferComplete(I2CDEV_M)){
+			complete_M = SET;
+		}
+	#endif
+
+	#if (USEDI2CDEV_S == 1)    // **************** SLAVE Mode ********************
+
+	  #ifdef FULL_INTERRUPT		 // Fully Interrupt Driven method, fastest and most reliable method
+	    uint8_t curStat;
+			i2cStat HandlerStatus;
+
+			//Optional determine whether RECEIVE or TRANSMIT mode, not currently used and may not really be necessary
+			#pragma region Optional I2C direction detect
+					/*	curStat = (I2CDEV_S->I2STAT >> 5) & 0x7;
+			  		switch(curStat)
+			  		{
+			  			case 3:
+			  			case 4:
+			  			case 7:
+			  				I2C_dir = RECEIVE;
+			  			  break;
+			  			case 5:
+			  			case 6:
+			  				I2C_dir = TRANSMIT;
+			  				break;
+							default:
+								I2C_dir = RECEIVE;
+							  break;
+			  		}
+						*/
+			#pragma endregion
+			
+			// call mySlave Handler, if transaction still processing returns I2C_OK, I2C_BYTE_RECV, I2C_BYTE_SENT
+			// if transaction complete returns I2C_ERR, I2C_NAK_RECV, I2C_SEND_END, I2C_RECV_END, I2C_STA_STO_RECV  
+	    HandlerStatus = mySlaveHandler();
+			
+			if(HandlerStatus == I2C_OK || HandlerStatus == I2C_BYTE_RECV || HandlerStatus == I2C_BYTE_SENT)
+			{
+				processI2Cpacket();		// transaction still in process, hook to application code
+			}
+			else										// I2C transaction is complete
+			{ 
+				if (HandlerStatus == I2C_SEND_END)					// send transaction completed, check all bytes were sent
+					{		
+						if(tx_int_buf.head != tx_int_buf.tail)	// if master didn't take all bytes from buffer, flush the buffer
+						{																				// to prevent buffer getting stuck when end of buffer is reached
+							tx_int_buf.head = tx_int_buf.tail;
+							tx_int_buf.count = 0;
+						}
+					}
+				if (HandlerStatus == I2C_RECV_END)    			// should only get this if Rx buffer is full!
+					{
+						NOP
+					}
+
+				processI2Cpacket();																					// hook to handle I2C events
+				I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;												// Keep Assert Ack going
+				I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;	// clear I2C Int flag, clear Start flag
+				I2C_IntCmd(I2CDEV_S, TRUE);		// Re-Enable I2C Interrupts that were disabled after SlaveHandler completed
+			}
+	
+	  #endif  // Full Interrupt Driven method
+
+
+		// API method Blocking Interrupt or Polled, these are not preferred nor currently used, and there
+		// is no handling in processI2Cpacket() for these modes
+    #if ANY(BLOCKING_INTERRUPT, FULL_POLLING )
+				I2C_SlaveHandler(I2CDEV_S);
+				if(I2C_SlaveTransferComplete(I2CDEV_S))
+					complete_S = SET;
+    #endif //API method Int or Polled
+  
+	#endif // USEDI2CDEV_S == 1
+}
+
+/******  MAIN ROUTINE to process I2C Events  *****/
+void processI2Cpacket(void)
+{
+uint8_t i;
+#pragma region Interrupt driven method
+#ifdef FULL_INTERRUPT
+	if(rx_int_buf.count > 0)		// only if buffer has some data
+	{
+
+		 COMMAND = I2C_RX_peek();  // peek at byte from buffer to see if it's a command, if not, 
+																					// we will continue coming back here until we get a command
+  	switch(COMMAND)
+		{
+			case READ_TARGET_RPM:					// Master is requesting Target RPM from Slave
+				I2C_RX_dequeue();						// remove command byte from buffer, no other Rx data bytes for this command
+																		// Immediately fill transmit buffer with Target RPM to send back to Master
+				writeTXbuf(cutter.TARGET_RPM);			// put byte, integer, or float data (auto detects) from union array into I2CTXDAT
+				break;
+
+			case WRITE_ACTUAL_RPM:				// Master wants to write Actual RPM to Slave
+				if(rx_int_buf.count > sizeof(cutter.ACTUAL_RPM))
+				{
+					//WRITE(P2_11,1);
+				  I2C_RX_dequeue();		  		// remove command byte from buffer, integer(2 data bytes) follows
+				  readRXbuf(&cutter.ACTUAL_RPM);		// get bytes of integer or float data (auto detects) from RX buffer
+			  	//WRITE(P2_11,0);
+				}
+				break;
+
+			case SEND_AVR_INFO_BLOCK:			// Master is requesting Marlin's AVR infoBlock/status(including floats), send it
+				I2C_RX_dequeue();						// remove command byte from buffer, no other Rx data bytes for this command
+				AVRInfoBlock.PIDFLAG = cutter.spindle_use_pid;
+				writeTXbufByteAry(&AVRInfoBlock.PIDFLAG, sizeof(AVRInfoBlock));		// send struct of bytes, pass first element as pointer
+				if(AVRInfoBlock.Reset_Flag)  AVRInfoBlock.Reset_Flag = 0;					// always clear reset flag after sending
+				if(AVRInfoBlock.Update_EEPROM) AVRInfoBlock.Update_EEPROM = 0;		// always clear EEPROM Update flag after sending
+				sendAVRBlockComplete = 1;																					// flag completion
+				break;				
+
+			case RCV_AVR_INFO_BLOCK:			// Master is sending it's copy of AVR infoBlock/status(including floats), receive it
+				if(rx_int_buf.count > sizeof(AVRInfoBlock))
+				{
+					I2C_RX_dequeue();					// remove command byte from buffer, no other Rx data bytes for this command
+					readRXbufByteAry(&AVRInfoBlock.PIDFLAG,sizeof(AVRInfoBlock));		// recv struct of bytes, pass first element as pointer
+					cutter.spindle_use_pid = AVRInfoBlock.PIDFLAG;  								// fix this double re-assigned variable later
+				}
+				RecvAVRBlockComplete = 1;																					// flag completion
+				break;				
+			
+			
+			case POST_PID_INFO:						// Master is sending an array of 4 floats for Marlin to echo to Serial/USB
+				float tau[4];								// This command is ONLY for data logging to a terminal to test PID performance
+				if(rx_int_buf.count > sizeof(tau))
+				{
+					I2C_RX_dequeue();					// remove command byte from buffer, multiple data bytes remain for this command
+					readRXbuf(&tau[0]);
+					readRXbuf(&tau[1]);
+					readRXbuf(&tau[2]);
+					readRXbuf(&tau[3]);	
+					sprintf(logMsg," T:%1.3f :KP:%5.2f :KI:%5.2f :KD:%5.2f\n", tau[0], tau[1], tau[2], tau[3] );   // to post PID setup info        
+	 				SERIAL_ECHO(logMsg);
+				}
+				break;
+
+			case POST_PID_DATA:						// Master is sending an array of 6 floats for Marlin to echo to Serial/USB
+																		// This command is ONLY for data logging to a terminal to test PID performance
+				float pidErr, pidProp, pidInt, pidDer, pidOut, cur_adc;
+				if(rx_int_buf.count > 24)
+				{
+					I2C_RX_dequeue();					// remove command byte from buffer, multiple data bytes remain for this command
+					readRXbuf(&pidErr);
+					readRXbuf(&pidProp);
+					readRXbuf(&pidInt);
+					readRXbuf(&pidDer);
+					readRXbuf(&pidOut);
+					readRXbuf(&cur_adc);
+					sprintf(logMsg," PV:%5u :SP:%5u :ER:%5.2f :P:%5.2f :I:%5.2f :D:%5.2f :PO:%5.2f :ADC:%5.2f\n",
+					        cutter.ACTUAL_RPM, cutter.TARGET_RPM, pidErr, pidProp, pidInt, pidDer, pidOut, cur_adc );           
+	 				SERIAL_ECHO(logMsg);			// to post current data to TFT LCD
+				}
+				break;
+
+			default:
+			  break;
+		}
+	}
+	//GPIO_SetValue(4,0x10000000);		//TG- P4_28 pin
+	//GPIO_ClearValue(4,0x10000000);	//TG- P4_28 pin
+	return;
+#endif
+#pragma endregion
+	
+}
+
+// overloaded function to accept float or integer val and fill TRPM_u array
+void writeTXbuf(uint8_t len)
+{
+	uint8_t i=0;
+	for(i = 0; i < len; i++)				// send 4 bytes of float data from array
+	{
+		I2C_TX_enqueue((uint8_t)TRPM_u.a[i]);
+	}
+}
+void writeTXbuf(volatile float val)
+{
+	TRPM_u.f = val;	// set float in union from actual_rpm	
+	writeTXbuf((uint8_t)sizeof(val));
+}
+void writeTXbuf(volatile uint16_t val)
+{
+	TRPM_u.i = val;	// set integer in union from actual_rpm	
+	writeTXbuf((uint8_t)sizeof(val));
+}
+void writeTXbufByteAry(volatile uint8_t * src, uint8_t len)
+{
+	uint8_t i=0;
+	for(i = 0; i < len; i++)	
+	{
+			I2C_TX_enqueue(src[i]);
+	}
+}
+
+void readRXbuf(volatile float * val)
+{
+	uint8_t i=0;
+	for(i = 0; i < sizeof(float); i++)			// grab 4 bytes of float data into array
+	{
+		ARPM_u.a[i] = I2C_RX_dequeue();
+	}
+  *val = ARPM_u.f;												// get float from union float into actual_rpm		
+}
+void readRXbuf(volatile uint16_t * val)
+{
+	uint8_t i=0;
+	for(i = 0; i < sizeof(uint16_t); i++)		// grab 2 bytes of int data into array
+	{
+		ARPM_u.a[i] = I2C_RX_dequeue();
+	}
+	*val = (uint16_t)ARPM_u.i;							// get integer from union	
+}
+void readRXbufByteAry(volatile uint8_t * dest, uint8_t len)
+{
+	uint8_t i=0;
+	for(i = 0; i < len; i++)	
+	{
+		dest[i] = I2C_RX_dequeue();
+	}
+}
+
+//TG Adapted from lpc17xx_i2c code, customized for use here and renamed
+i2cStat mySlaveHandler()
+{
+uint8_t returnCode;
+uint32_t timeout;
+RetStatus = I2C_OK;
+//GPIO_SetValue(4,0x10000000);		//TG- P4_28 pin
+//GPIO_ClearValue(4,0x10000000);	//TG- P4_28 pin
+
+handle_state:
+	returnCode = (I2CDEV_S->I2STAT & I2C_STAT_CODE_BITMASK);			// get current I2C status reg byte
+  // StateHandler returns I2C_OK, I2C_BYTE_RECV, I2C_BYTE_SENT, I2C_SEND_END, I2C_RECV_END, or I2C_STA_STO_R
+	RetStatus = myStateHandler(returnCode);		// call Slave State Machine handler with I2CDEV_S->I2STAT
+	
+	if(I2C_CheckError(RetStatus))							//##### if I2C_ERR or I2C_NAK_RECV	bit 7 = 1 ##### 
+		goto s_int_end;					
+	else if (RetStatus & I2C_STA_STO_RECV)		//##### STOP condition or repeated START ##### 
+	{
+		I2C_IntCmd(I2CDEV_S, FALSE);						// Temporally lock the interrupt for timeout condition
+		timeout = I2C_SLAVE_TIME_OUT;						// enable time out
+		while(1)
+		{
+			if (I2CDEV_S->I2CONSET & I2C_I2CONSET_SI)	// ##### got a new Interrupt during timeout? #####
+			{																					// could be a repeat Start
+				I2C_IntCmd(I2CDEV_S, TRUE);							// re-Enable interrupt
+				goto handle_state;											// handle new state
+			}
+			else																	// countdown the timeout
+			{
+				timeout--;
+				if (timeout == 0)										// ##### timed out, it's really a stop condition #####
+					goto s_int_end;
+			}
+		}
+	}
+	else if(RetStatus & I2C_SEND_END)					// ##### last byte or NACK, transmission ended #####
+		goto s_int_end;
+	else if(RetStatus & I2C_RECV_END)					// ##### Rx buffer Full, transmission ended #####
+	  goto s_int_end;
+	else																			// ##### I2C_OK, I2C_BYTE_RECV, I2C_BYTE_SENT ##### 
+		return RetStatus;												// still busy ONLY for I2C_OK, I2C_BYTE_RECV, I2C_BYTE_SENT
+
+s_int_end:		// completed, ONLY for I2C_SEND_END, I2C_RECV_END, I2C_STA_STO_R, I2C_ERR, or I2C_NAK_RECV
+	I2C_IntCmd(I2CDEV_S, FALSE);							// Disable interrupt
+	I2CDEV_S->I2CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
+	return RetStatus;	
+}
+
+//TG Adapted from lpc17xx_i2c code, customized for use here and renamed, process according to I2CDEV_S->I2STAT
+i2cStat myStateHandler(uint32_t CodeStatus)
+{
+i2cStat Ret = I2C_OK;
+
+switch (CodeStatus)
+{ // note: if you need pin toggling for scope output use OUT_WRITE(P1_22,1); / OUT_WRITE(P1_22,0);
+	
+	/******************************************************************************************************/
+	/* Slave Reading phase, a Master wants to write to this slave ------------------------------ */
+	/******************************************************************************************************/
+			
+	case I2C_I2STAT_S_RX_SLAW_ACK:	// 0x60	Own SLA+W has been received, ACK has been returned, data byte will be received
+	case I2C_I2STAT_S_RX_GENCALL_ACK:  // 0x70 General call address has been received, ACK has been returned, data byte will be received
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;			// keep the assert ACK going
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;		// clear the Interrupt flag
+		break;
+	case I2C_I2STAT_S_RX_ARB_LOST_M_GENCALL:		// 0x78	General Call has been received and ACK has been returned.
+	case I2C_I2STAT_S_RX_ARB_LOST_M_SLA:				// 0x68	Arbitration has been lost in Slave Address + R/W bit as bus Master. 
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA|I2C_I2CONSET_STA;	// STA set to restart Master mode
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;		// clear the Interrupt flag
+		break;
+	/* Receive Data bytes phase, Master sending data to slave  --------------------------------- */
+	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:		// 0x80	Previously addressed with own SLA; DATA byte has been received; ACK has been returned
+		if(!I2C_RX_buffer_full())	// buffer has room,  data bytes that over-flow the buffer, just ignore them.
+		{
+			I2C_RX_enqueue((uint8_t)I2CDEV_S->I2DAT);  // read data from I2DAT, inc buffer ptr
+			Ret = I2C_BYTE_RECV;
+		}
+		// typically this would check for last data byte OR buffer full to NAK the master, but in this custom
+		// version we don't know how many bytes will be received, we only know when our RX buffer is full!
+		if(I2C_RX_buffer_full())	 								// buffer full
+		{
+			I2CDEV_S->I2CONCLR = I2C_I2CONCLR_AAC|I2C_I2CONCLR_SIC;	 // prepare to NAK master
+			Ret = I2C_BYTE_RECV;
+		}
+		else {																		// not full or the last data byte yet
+			I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;		// keep the assert ACK going
+			I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;	// clear the Interrupt flag
+		}
+		break;
+	
+  /* In this custom version we only get here if our Rx buffer gets full, not when last byte received! */
+	/* Received data will not be saved. Not addressed Slave mode is entered */
+	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:	// 0x88 Previously addressed with own SLA; DATA byte has been received; NOT ACK has been returned 
+	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:	// 0x98 Previously addressed with General Call. Data has been received, NOT ACK has been returned.
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;			// keep the assert ACK going
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;		// clear the Interrupt flag
+		Ret = I2C_RECV_END;
+	  break;
+	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:	// 0x90 Previous General Call, DATA has been received, Only first data byte will be received with ACK. 
+		if(!I2C_RX_buffer_full())								// buffer has room
+		{
+			I2C_RX_enqueue((uint8_t)I2CDEV_S->I2DAT);  // read data from I2DAT, inc ptr
+			Ret = I2C_BYTE_RECV;
+		}
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_AAC|I2C_I2CONCLR_SIC; 	// No ACK, clear Interrupt, Additional data will be received with NOT ACK.
+		break;
+	
+	
+	/******************************************************************************************************/
+	/* Slave Writing phase, Master requested data from slave -------------------------------------------- */
+	/******************************************************************************************************/
+	
+	case I2C_I2STAT_S_TX_SLAR_ACK:	// 0xA8 Own SLA+R has been received, ACK has been returned, DATA will be transmitted, ACK will be received
+	case I2C_I2STAT_S_TX_DAT_ACK:		// 0xB8 Data has been transmitted, ACK has been received, DATA will be transmitted, ACK will be received
+		if(!I2C_TX_buffer_empty())		// buffer has data - send data bytes up to specified transmit data length.
+		{	
+			I2C_IntCmd(I2CDEV_S, FALSE);
+			I2CDEV_S->I2DAT = I2C_TX_dequeue();;
+			I2C_IntCmd(I2CDEV_S, TRUE);
+			Ret = I2C_BYTE_SENT;
+		}
+		else																		// buffer is empty
+		{
+			I2CDEV_S->I2DAT = 0x99;								// send a bogus byte
+		}
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;		// keep the assert ACK going
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;	// clear the Interrupt flag
+		break;
+	/* Arbitration lost in Slave Address and R/W bit as bus Master. Own Slave Address + Read
+	   has been received, ACK has been returned. Data will be transmitted, ACK bit will be 
+	   received. STA is set to restart Master mode after the bus is free again.*/
+	case I2C_I2STAT_S_TX_ARB_LOST_M_SLA:	//	0xB0
+		if(!I2C_TX_buffer_empty())			// buffer has data - send data bytes
+		{	
+			I2CDEV_S->I2DAT = I2C_TX_dequeue();
+			Ret = I2C_BYTE_SENT;
+		}
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA|I2C_I2CONSET_STA;	// STA set to restart Master mode
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;									// clear the Interrupt flag
+		break;
+	
+	/*
+	 * Note: Don't wait for stop event in slave transmit mode, since there no proof to inform
+	 * us when a stop signal has been received on slave side.
+	 */
+	
+	/* Last byte has been transmitted, NACK has been received, enter Not addressed Slave mode */
+	case I2C_I2STAT_S_TX_LAST_DAT_ACK:	//	0xC8
+	/* Data has been transmitted, NOT ACK has been received. Not addressed Slave mode is entered */
+	case I2C_I2STAT_S_TX_DAT_NACK:			//	0xC0
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;					// keep the assert ACK going
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;					// clear the Interrupt flag
+		Ret = I2C_SEND_END;
+		break;
+	/*
+	 * Note that: Return code only let us know a stop condition mixed with a repeat start condition in the
+	 * same code value. So we should provide a time-out. In case this is really a stop condition, this will
+	 * return back after time out condition. Otherwise, next session that is slave receive data will be completed.
+	 */
+	/* A STOP condition or repeated START has been received, while still addressed as a 
+	   Slave. Data will not be saved. Not addressed Slave mode is entered. */
+	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:	// 0xA0		## 1.4us to end of ISR
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;					// keep the assert ACK going
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;				// clear the Interrupt flag
+		Ret = I2C_STA_STO_RECV;
+		break;
+	case I2C_I2STAT_NO_INF:	//	0xF8 No status information, Other status must be captured
+	default:
+		I2CDEV_S->I2CONSET = I2C_I2CONSET_AA;					// keep the assert ACK going
+		I2CDEV_S->I2CONCLR = I2C_I2CONCLR_SIC;				// clear the Interrupt flag
+		break;
+	}
+
+return Ret;
+}
+
+//TG custom version adapted from lpc17xx_i2c and renamed, customized for use here 
+#pragma region I2C Initialization
+void I2C_begin(en_I2C_Mode mode, uint8_t address, uint32_t speed, bool StartInterrupts){
+	/* Init I2C pin connections according to which peripheral I2C0, 1, or 2 */
+	PINSEL_CFG_Type PinCfg;
+	PinCfg.OpenDrain = PINSEL_PINMODE_OPENDRAIN;		//TG 8/9/22 changed to 1, was 0
+	PinCfg.Pinmode = PINSEL_PINMODE_PULLUP;
+	#if USEDI2CDEV_M == 0 || USEDI2CDEV_S == 0
+	  PinCfg.Funcnum = 1;
+	  PinCfg.Pinnum = 27;
+	  PinCfg.Portnum = 0;
+	  PINSEL_ConfigPin(&PinCfg); // SDA0 / D57  AUX-1
+	  PinCfg.Pinnum = 28;
+	  PINSEL_ConfigPin(&PinCfg); // SCL0 / D58  AUX-1
+	#endif
+	#if USEDI2CDEV_M == 1 || USEDI2CDEV_S == 1
+		PinCfg.Funcnum = 3;														// alt function 3 = SDA1, SCL1 
+	  PinCfg.Pinnum = 0;														// P0.0 = SDA1
+	  PinCfg.Portnum = 0;														// Port 0
+	  PINSEL_ConfigPin(&PinCfg);  									// SDA1 / D20 SCA
+	  PinCfg.Pinnum = 1;														// P0.1 = SCL1
+	  PINSEL_ConfigPin(&PinCfg);  									// SCL1 / D21 SCL
+	#endif
+	#if USEDI2CDEV_M == 2 || USEDI2CDEV_S == 2
+	  PinCfg.Funcnum = 2;
+	  PinCfg.Pinnum = 10;
+	  PinCfg.Portnum = 0;
+	  PINSEL_ConfigPin(&PinCfg); // SDA2 / D38  X_ENABLE_PIN
+	  PinCfg.Pinnum = 11;
+	  PINSEL_ConfigPin(&PinCfg); // SCL2 / D55  X_DIR_PIN
+	#endif
+
+	if(mode == I2C_MASTER_MODE){                		// set up Master mode config
+	  // Initialize I2C peripheral power and clock setup
+		I2C_Init(I2CDEV_M, speed);
+		// Enable Master I2C operation
+	  I2C_Cmd(I2CDEV_M, I2C_MASTER_MODE, ENABLE);
+	}
+	
+	if(mode == I2C_SLAVE_MODE){                 		// set up Slave mode config structure
+	  // Initialize I2C peripheral power and clock setup
+		I2C_Init(I2CDEV_S, speed);
+
+		// Configure the Slave Own Address type
+		I2C_OWNSLAVEADDR_CFG_Type mySLAVEADDR;
+	  mySLAVEADDR.SlaveAddr_7bit = address;     		// the slave device's own address
+	  mySLAVEADDR.SlaveAddrMaskValue = 0x00; 
+	  mySLAVEADDR.SlaveAddrChannel = 0;         		// can be up to four different addresses
+	  mySLAVEADDR.GeneralCallState = ENABLE;
+	  I2C_SetOwnSlaveAddr(I2CDEV_S, &mySLAVEADDR);	// Set slave address
+	  I2C_Cmd(I2CDEV_S, I2C_SLAVE_MODE, ENABLE); 		// Enable Slave I2C operation
+	}
+	
+	#ifdef FULL_INTERRUPT
+	// set interrupt priority 4 for I2C, must not be higher than TIMERS or UART to avoid stuttering motion
+	// Marlin IRQ priority defaults to WDTIMER=0, TIMER0=1, TIMER1=2, UART = 3, and SERVO=5
+	if(StartInterrupts){
+		if(I2CDEV_S == LPC_I2C0)								
+		{																				
+			NVIC_SetPriority(I2C0_IRQn, 4);
+		}
+		else if (I2CDEV_S == LPC_I2C1)
+		{
+			NVIC_SetPriority(I2C1_IRQn, 4);
+		}
+		else if (I2CDEV_S == LPC_I2C2)
+		{
+			NVIC_SetPriority(I2C2_IRQn, 4);
+		}
+		
+		I2C_IntCmd(I2CDEV_S, TRUE);								// start I2C interrupts
+	}
+  #endif
+}
+#pragma endregion
+						
+#pragma region Circular Buffer Routines
+
+uint8_t I2C_RX_peek(){
+		if(I2C_RX_buffer_empty()==false)						// if buffer not empty
+			return rx_int_buf.data[rx_int_buf.head];	// get from queue
+		else
+			return 0;
+}
+void I2C_RX_enqueue(uint8_t byte){
+		if(I2C_RX_buffer_full()==false)							// if buffer not full
+		{
+			rx_int_buf.data[rx_int_buf.tail] = byte;	// put in queue at tail
+			rx_int_buf.tail = (rx_int_buf.tail + 1) % I2C_BUF_SIZE;	// bump tail
+			rx_int_buf.count = (rx_int_buf.count + 1) % I2C_BUF_SIZE;
+		}
+}
+uint8_t I2C_RX_dequeue(){
+		uint8_t retbyte;
+		if(I2C_RX_buffer_empty()==false)						// if buffer not empty
+		{
+			retbyte = rx_int_buf.data[rx_int_buf.head];			// get from queue
+			rx_int_buf.data[rx_int_buf.head] = 0;						// clear it
+			rx_int_buf.head = (rx_int_buf.head + 1) % I2C_BUF_SIZE;	// bump head
+			rx_int_buf.count = (rx_int_buf.count - 1) % I2C_BUF_SIZE;
+			return retbyte;
+		}
+		else
+			return 0;
+}
+
+void I2C_TX_enqueue(uint8_t byte){
+		if(I2C_TX_buffer_full()==false)						// if buffer not full
+		{
+			tx_int_buf.data[tx_int_buf.tail] = byte;			// put in queue at tail
+			tx_int_buf.tail = (tx_int_buf.tail + 1) % I2C_BUF_SIZE;	// bump tail
+			tx_int_buf.count = (tx_int_buf.count + 1) % I2C_BUF_SIZE;
+		}
+}
+uint8_t I2C_TX_dequeue(){
+		uint8_t retbyte;
+		if(I2C_TX_buffer_empty()==false)						// if buffer not empty
+		{
+			retbyte = tx_int_buf.data[tx_int_buf.head];		// get from queue at head
+			tx_int_buf.data[tx_int_buf.head] = 0;					// clear from queue
+			tx_int_buf.head = (tx_int_buf.head + 1) % I2C_BUF_SIZE;	  // bump head
+			tx_int_buf.count = (tx_int_buf.count - 1) % I2C_BUF_SIZE; // dec count
+			return retbyte;
+		}
+		else
+			return 0;
+}
+
+bool I2C_RX_buffer_full(){
+	if(rx_int_buf.head ==	(rx_int_buf.tail + 1) % I2C_BUF_SIZE){	// full if tail + 1 will hit head
+		rx_int_buf.count = I2C_BUF_SIZE;
+
+//		GPIO_SetValue(4,0x10000000);		//TG- P4_28 pin
+//		DELAY_US(5);
+//		GPIO_ClearValue(4,0x10000000);	//TG- P4_28 pin		
+
+		return true;
+	}
+	else
+		return false;
+}
+bool I2C_TX_buffer_full(){		// full if tail + 1 will hit head
+	if(tx_int_buf.head ==	(tx_int_buf.tail + 1) % I2C_BUF_SIZE){	
+		tx_int_buf.count = I2C_BUF_SIZE;
+		return true;
+	}
+	else
+		return false; 
+} 
+bool I2C_RX_buffer_empty(){		// empty if head = tail
+	if(rx_int_buf.head == rx_int_buf.tail){				
+		rx_int_buf.count = 0;
+		return true; 
+	}
+	else
+		return false;
+}
+bool I2C_TX_buffer_empty(){		// empty if head = tail
+	if(tx_int_buf.head == tx_int_buf.tail){				
+		tx_int_buf.count = 0;
+		
+//		GPIO_SetValue(2,0x00001000);		//TG- P2_12 pin 
+//		DELAY_US(5);
+//		GPIO_ClearValue(2,0x00001000);	//TG- P2_12 pin 
+		
+		return true; 
+	}
+	else
+		return false;
+}
+
+#pragma endregion
+
+#endif	// #ifdef TG_I2C_SUPPORT
diff --git a/Marlin/src/module/TG_I2C/TG_I2CSlave.h b/Marlin/src/module/TG_I2C/TG_I2CSlave.h
new file mode 100644
index 0000000000..d159a38451
--- /dev/null
+++ b/Marlin/src/module/TG_I2C/TG_I2CSlave.h
@@ -0,0 +1,88 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * Based on LPC17xx_I2C.c and adapted for Marlin using I2C1 in Slave Mode to send/receive rpm data
+ * T. Gioiosa 5/12/22
+ * 
+ */
+#ifndef _TG_I2CSLAVE_H_
+#define _TG_I2CSLAVE_H_
+#include <stdint.h>
+#include <lpc17xx_i2c.h>
+
+#if ENABLED(TG_I2C_SUPPORT)	//TG 12/16/22
+
+//TG 8/16/22 max about 550000 where 2004A LCD display starts to fail
+//depends on lead lenths of jumper wires, 400Khz gives a little margin
+#define I2C_CLOCK  400000		
+
+#define READ_TARGET_RPM			0x30	// Master commands over I2C
+#define WRITE_ACTUAL_RPM 		0x50
+#define POST_PID_INFO 			0x41
+#define POST_PID_DATA 			0x42
+#define SEND_PID_CONSTANTS 	0x51
+#define RCV_PID_CONSTANTS 	0x52
+#define SEND_AVR_INFO_BLOCK	0x60
+#define RCV_AVR_INFO_BLOCK	0x61
+
+#define I2C_BUF_SIZE 				64
+
+#define FULL_INTERRUPT
+//#define BLOCKING_INTERRUPT
+//#define FULL_POLLING
+
+//extern volatile uint16_t TARGET_RPM;	//TG 12/16/22 moved to SpindleLaser class
+//extern volatile uint16_t ACTUAL_RPM;  //TG 12/16/22 moved to SpindleLaser class
+
+volatile typedef struct {
+		__IO uint8_t data[I2C_BUF_SIZE];			// the buffer
+		__IO int8_t head;											// write pointer			
+		__IO int8_t tail;											// read pointer
+		__IO uint8_t count;
+}I2C_RX_buffer;
+
+volatile typedef struct {
+		__IO uint8_t data[I2C_BUF_SIZE];			// the buffer
+		__IO int8_t head;											// write pointer	
+		__IO int8_t tail;											// read pointer
+		__IO uint8_t count;
+}I2C_TX_buffer;
+
+#define RXBUF_EMPTY (rx_int_buf.count==0)
+#define RXBUF_FULL (rx_int_buf.count==I2C_BUF_SIZE)
+#define TXBUF_EMPTY (tx_int_buf.count==0)
+#define TXBUF_FULL (tx_int_buf.count==I2C_BUF_SIZE)
+
+void processI2Cpacket(void);
+void I2C_begin(en_I2C_Mode mode, uint8_t address, uint32_t speed, bool StartInterrupts);
+uint8_t I2C_RX_peek();
+uint8_t I2C_RX_dequeue();
+void I2C_TX_enqueue(uint8_t byte);
+uint8_t I2C_TX_dequeue();
+bool I2C_RX_buffer_full();
+bool I2C_RX_buffer_empty();
+void I2C_RX_enqueue(uint8_t byte);
+bool I2C_TX_buffer_full();
+bool I2C_TX_buffer_empty();
+
+void writeTXbuf(uint8_t len);
+void writeTXbuf(volatile float val);
+void writeTXbuf(volatile uint16_t val);
+void writeTXbufByteAry(volatile uint8_t * src, uint8_t len);
+
+void readRXbuf(volatile float * val);
+void readRXbuf(volatile uint16_t * val);
+void readRXbufByteAry(volatile uint8_t * dest, uint8_t len);
+
+
+i2cStat myStateHandler(uint32_t CodeStatus);
+i2cStat mySlaveHandler();
+
+typedef enum {
+	TRANSMIT,
+	RECEIVE,
+} I2C_dir_type;
+
+
+#endif //#if ENABLED(AVR_TRIAC_CONTROLLER)
+
+
+#endif
\ No newline at end of file
diff --git a/Marlin/src/module/planner.cpp b/Marlin/src/module/planner.cpp
index 12e879af96..8889369892 100644
--- a/Marlin/src/module/planner.cpp
+++ b/Marlin/src/module/planner.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -2152,6 +2152,19 @@ bool Planner::_populate_block(
     if (hints.millimeters)
       block->millimeters = hints.millimeters;
     else {
+      /**
+       * Distance for interpretation of feedrate in accordance with LinuxCNC (the successor of NIST
+       * RS274NGC interpreter - version 3) and its default CANON_XYZ feed reference mode.
+       * Assume that X, Y, Z are the primary linear axes and U, V, W are secondary linear axes and A, B, C are
+       * rotational axes. Then dX, dY, dZ are the displacements of the primary linear axes and dU, dV, dW are the displacements of linear axes and
+       * dA, dB, dC are the displacements of rotational axes.
+       * The time it takes to execute move command with feedrate F is t = D/F, where D is the total distance, calculated as follows:
+       *   D^2 = dX^2 + dY^2 + dZ^2
+       *   if D^2 == 0 (none of XYZ move but any secondary linear axes move, whether other axes are moved or not):
+       *     D^2 = dU^2 + dV^2 + dW^2
+       *   if D^2 == 0 (only rotational axes are moved):
+       *     D^2 = dA^2 + dB^2 + dC^2
+       */
       const xyze_pos_t displacement = LOGICAL_AXIS_ARRAY(
         steps_dist_mm.e,
         #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
diff --git a/Marlin/src/module/rpmSensor/rpmTimer.cpp b/Marlin/src/module/rpmSensor/rpmTimer.cpp
new file mode 100644
index 0000000000..83c4ab0c40
--- /dev/null
+++ b/Marlin/src/module/rpmSensor/rpmTimer.cpp
@@ -0,0 +1,539 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * Based in Marlin/HAL/timers.h adapted for using LPC_TMR3 to count rpm pulses
+ * T. Gioiosa 2/19/21
+ * modified 12/24/22 for VFD
+ * Marlin 3D Printer Firmware
+ *
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
+ * Copyright (c) 2015-2016 Nico Tonnhofer wurstnase.reprap@gmail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Description:
+ *
+ * Timers for LPC1768
+ */
+
+#ifdef TARGET_LPC1768
+  #include "../../inc/MarlinConfig.h" // needed for the next line #if ENABLED
+  #if ENABLED(USE_RPM_SENSOR)
+  
+  #pragma region Includes ----------------------------------------
+  #include "../../../src/lcd/marlinui.h"
+  //#include "../../LPC1768/timers.h"
+  #include "rpmTimer.h"
+  #include "../../../feature/spindle_laser.h"
+  #include "../temperature.h"
+  #include "stdio.h"
+  #include "pwm.h"
+  //#include <src/module/rpmSensor/TG_I2CSlave.h>
+  #pragma endregion // Includes
+
+  #pragma region - TG 9/17/21 - choose config options below, comment out those not wanted
+  // good resolution but longer measure time, typically 250ms to 1000msec lower limit=60RPM
+  //#define FREQUENCY_COUNTER_MODE        
+  // good resolution and faster, varies with RPM  2msec@30000RPM  600msec@100RPM  60sec@1RPM
+  #define PERIOD_MEASURE_MODE             
+  #pragma endregion
+
+  #pragma region - Defines for PERIOD_MEASURE_MODE
+  #ifdef PERIOD_MEASURE_MODE
+    int limitFlag = 0;
+    #define PERIOD_TMR_RATE 1000000             // for 1 us resolution
+    #define TIMER_RES 1.0f/PERIOD_TMR_RATE      // in usec Depends on Timer PCLK and PR. Used to convert measured period to frequency. 
+  #endif
+  #pragma endregion
+
+  #pragma region - //TG - Variables for Spindle/RPM sensor ******************************************************************
+  extern SpindleLaser cutter;
+  float measured_RPM = 0;
+  uint16_t RPM_NO_SIGNAL = 0;        //TG 12/21/22 added
+  uint16_t VFD_STATUS_COUNTER = 0;
+  #define RPM_LOSS_TIMEOUT 2 * RPM_TICK_RATE   // if timer tick is 1ms then for 2s timeout would be 2*1000 = 2000
+  #define VFD_STATUS_INTERVAL 3 * RPM_TICK_RATE // // time in ms to fetch and display status = 3*1000 = 3000ms
+  //std::array<char,60> logMsg;      // a CPP style array, use str.Data() for pointer to actual characters
+  char logMsg[60];
+  #pragma endregion
+
+  #pragma region - //TG - ***** Variables for PID speed control algorithm *************************************************
+  #if SPINDLE_USE_PID
+    float_t error = 0;
+    uint16_t SP = 0;                      // setpoint (target to reach)
+    uint16_t PV = 0;                      // process value (actual output)
+    float proportional = 0;
+    PIDController pid_RPM = {PID_KP,PID_KI,PID_KD,PID_TAU,PID_LIM_MIN,PID_LIM_MAX,PID_LIM_MIN_INT,PID_LIM_MAX_INT,SAMPLE_TIME_S};
+    int8_t errorSign;
+  #endif // SPINDLE_USE_PID
+  #pragma endregion
+
+  #pragma region - Timer Initialization for Timer2 or Timer3, handles either FREQUENCY_COUNTER_MODE or PERIOD_MEASURE_MODE for Timer3
+    void RPM_timer_init(uint8_t timer_num){
+      switch(timer_num)
+    {
+      case 2: 
+        SBI(LPC_SC->PCONP, SBIT_TIMER2); 
+        LPC_TIM2->PR = 0;  //Using lowest PR gives most accurate results
+        LPC_SC->PCLKSEL1 |= (1<<12); //Set bits[13:12] = [01] to select PCLK_TIMER2 = CCLK i.e. 120Mhz in our case. 
+        LPC_PINCON->PINSEL0 |= (1<<9) | (1<<8); //Set Bits[9:8] = [11] to Select CAP2.0 for P0.4
+        LPC_TIM2->CTCR = 0x1; //Increment TC on rising edges of External Signal for CAP2.0  (P0_4)
+        LPC_TIM2->CCR = 0x0;  //No Capture Register load on event and no int on event for CAP2.0 or CAP 2.1
+        LPC_TIM2->TCR = 0x2; //Reset & Disable Timer2 Initially
+        break;  // Power ON Timer 2
+      case 3: 
+        #ifdef FREQUENCY_COUNTER_MODE
+        SBI(LPC_SC->PCONP, SBIT_TIMER3); 
+        LPC_TIM3->PR = 0;  //Using lowest PR gives most accurate results
+        LPC_SC->PCLKSEL1 |= (1<<14); //Set bits[15:14] = [01] to select PCLK_TIMER3 = CCLK i.e. 120Mhz in our case. 
+        LPC_PINCON->PINSEL1 |= (1<<15) | (1<<14); //Set Bits[15:14] = [11] to Select CAP3.0 for P0.23
+        LPC_TIM3->CTCR = 0x1; //Increment TC on rising edges of External Signal for CAP3.0  (P0_23)
+        LPC_TIM3->CCR = 0x0;  //No Capture Register load on event and no int on event for CAP3.0 or CAP 3.1
+        LPC_TIM3->TCR = 0x2; //Reset & Disable Timer3 Initially
+        #endif
+        #ifdef PERIOD_MEASURE_MODE
+        SBI(LPC_SC->PCONP, SBIT_TIMER3); //Power-Up Timer3 module. It is disabled by default.
+        LPC_TIM3->PR = F_CPU/(PERIOD_TMR_RATE - 1);    // set prescalar for desired PERIOD_TMR_RATE
+        LPC_TIM3->PC = F_CPU/(PERIOD_TMR_RATE - 1);
+        LPC_SC->PCLKSEL1 |= (1<<14); //Set bits[15:14] = [01] to select PCLK_TIMER3 = CCLK i.e. 120Mhz in our case. 
+        LPC_PINCON->PINSEL1 |= (1<<15) | (1<<14); //Set Bits[15:14] = [11] to Select CAP3.0 for P0.23
+        LPC_TIM3->CTCR = 0x0; //Timer Mode clocked by PreScale Counter
+        LPC_TIM3->CCR = (1<<0) | (1<<2); //Capture on Rising Edge(0->1) and generate an interrupt for CAP3.0
+        LPC_TIM3->TCR = 0x2; //Reset & Disable Timer3 Initially
+        RPM_timer_enable_interrupt(MF_TIMER_RPM);
+        RPM_timer_start(MF_TIMER_RPM);
+        #endif
+
+        break;  // Power ON Timer 3
+      default: 
+        break;
+    }
+    }
+  #pragma endregion
+
+  // the HAL_TEMP_TIMER_ISR calls here every 1ms, when 1 second has elapsed we update the measured_RPM.
+  // execution is under 100us with PID running (longer if processing M3/M4 gcodes from TFT speed changes)
+  // RPM_tick and PID code             <100us  
+  // Logging PV strings to terminal    ~3000us
+  // FAST_RPM_REPORTING on             ~360us to 620us varies
+  // all turned on takes about 3760us, so HAL_TEMP_TIMER_ISR is modified to every 4ms if Logging or FAST_RPM_REPORTING is on.
+  #pragma region - RPM_tick code called by HAL_TEMP_ISR in temperature.c, RPM_SAMPLE_TIME sets interval to perform action
+  // In FREQUENCY_COUNTER_MODE, RPM measurement/measured_RPM and PID sample time are handled at RPM_SAMPLE_TIME interval
+  // In PERIOD_MEASURE_MODE, RPM measurement/measured_RPM are at the Timer 3 ISR rate, PID action remains at the RPM_SAMPLE_TIME interval
+  // The Timer 3 ISR rate is much faster than FREQUENCY_COUNTER_MODE and runs at the RPM sensor rate (2ms to 600ms). 
+    void RPM_tick(void) {
+      static uint16_t gate_counter = 0;
+      static uint32_t pulse_count = 0;
+      static uint8_t smode = 0;
+      static uint8_t bytecount;
+      static uint8_t I2C_timer;
+
+      //WRITE(P2_12,1);     //TG - ***** for scope measurement normally commented out  
+      if(gate_counter++ == 0){                        // when gate interval counter is at reset (0)
+        #ifdef FREQUENCY_COUNTER_MODE
+        RPM_timer_start(MF_TIMER_RPM);             // start counting rising edge of pulses on CAP3.0 (P0_23)
+        #endif
+      } 
+      else if(gate_counter > ((RPM_SAMPLE_TIME*RPM_TICK_RATE/1000) - 1))   // when gate interval has elapsed
+      {
+        //WRITE(P4_28,1);    //TG - ***** for scope measurement normally commented out
+        // Measure frequency from number of pulses counted in one gate interval 
+        #ifdef FREQUENCY_COUNTER_MODE
+        // calc measured_RPM and update the RPM from number of pulses counted in one gate interval
+        // if in PERIOD_MEASURE_MODE the measured_RPM variable is set by the Timer3 ISR code
+        //WRITE(P2_12,1);
+        RPM_timer_stop(MF_TIMER_RPM);        // stop the timer
+        pulse_count = RPM_timer_get_count(); // get the pulses counted over gate interval
+        RPM_timer_reset(MF_TIMER_RPM);       // reset the timer counter
+        measured_RPM = 60 * (double)pulse_count * RPM_TICK_RATE / RPM_SAMPLE_TIME;
+        cutter.ACTUAL_RPM = measured_RPM;    //TG 12/20/22 added because this is what TFT displays
+        #endif
+
+        //sprintf(str, "Speed: %5.2f  Gate: %u", measured_RPM, gate_counter); 
+        //send_M117_msg(str);
+        gate_counter = 0;                     // reset the gate interval counter
+
+        //TG 2/21/21 don't wait for autotemp reporting cause it is every 3 sec by default, instead send a
+        //speed msg "S0:ttttt/aaaaa" every gate interval for faster updates(gate is currently 500 msec)
+        //when FAST_RPM_REPORTING is defined in Configuration_adv.h
+        #ifdef FAST_RPM_REPORTING
+          #ifdef SERIAL_FLOAT_PRECISION
+            #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
+          #else
+            #define SFP 2
+          #endif
+          //WRITE(P2_12,1);     //TG - ***** for scope measurement normally commented out
+          //TG one-line method
+          sprintf(logMsg," S0:%d / %d\n", (int)Temperature::spindle_speed[0].target, (int)measured_RPM);
+          SERIAL_ECHOPGM(logMsg);
+
+          //TG original method
+          //SERIAL_CHAR(' ', 'S', '0',':');
+          //SERIAL_PRINT(Temperature::spindle_speed[0].target, SFP); //TG 5/25/21 added (double) to fix errors
+          //SERIAL_ECHOPGM(" /");
+          // SERIAL_PRINT(measured_RPM, SFP);
+          //SERIAL_EOL();
+          //WRITE(P2_12,0);     //TG - ***** for scope measurement normally commented out
+        #endif
+    
+        // PID speed correction if enabled
+        // perform speed control only if spindle is commanded on and ready, and spindle_use_pid is set true, skip otherwise
+        #if SPINDLE_USE_PID
+        if(SpindleLaser::isReady && SpindleLaser::enabled() && cutter.spindle_use_pid==true)
+        {
+          // Marlin's CUTTER_POWER_UNIT is what determines unitPower and menuPower units(not the settings at the TFT).
+          // The TFT settings affect TFT displayed units and what units to expect from Marlin to display them properly!
+          // Let's convert any Marlin units to RPM for better accuracy and precision.
+          PV = MarlinUnitsToRPM(measured_RPM);
+          SP = MarlinUnitsToRPM(SpindleLaser::menuPower);
+          errorSign = SP>PV ? 1 : SP<PV ? -1 : 0;
+          error = SP - PV;
+          //TG - 9/21/21 copy temp_bed.pid values to pid_RPM struct values (used in the computePID_Classic() call), 
+          // since temp_bed.pid values can be user-set with M304 and stored/recalled in EEPROM
+          copy_PID_constants(); 
+          
+          // code for logging values to terminal during test or development to study waveforms (adds 300usec to execution time)
+         // #ifdef PID_WAVEFORM_LOGGING
+            if(pid_RPM.newTarget==1)            // if first cycle after a new setpoint, print these info values one time
+            {   
+              //str.fill('\0');
+              sprintf(logMsg,"Kp:%3.2f, Ki:%3.2f, Kd:%3.2f, SP:%u, T:%2.2f \n",pid_RPM.Kp,pid_RPM.Ki,pid_RPM.Kd,SP,pid_RPM.T);
+              SERIAL_ECHO(logMsg);
+              
+              //str.fill('\0');
+              sprintf(logMsg," PV:%u :P1:%d :E:%5.0f \n",SP, SpindleLaser::power,error);  // to indicate a start point    
+              SERIAL_ECHO(logMsg);
+              //str.fill('\0');
+              sprintf(logMsg," PR:%5.0f :I:%5.0f :P2:%3.0f :KP:%1.2f :KI:%1.2f\n",proportional,pid_RPM.integrator,pid_RPM.out,pid_RPM.Kp,pid_RPM.KpFactor);            // to indicate a start point        
+              SERIAL_ECHO(logMsg);
+            }
+            else{
+              //str.fill('\0');
+              sprintf(logMsg," PV:%u :P1:%3.0f :E:%5.0f \n",PV, pid_RPM.prevPower,error);   // to post current data        
+              SERIAL_ECHO(logMsg);
+              //str.fill('\0');
+              sprintf(logMsg," PR:%5.0f :I:%5.0f :P2:%3.0f :KP:%1.2f :KI:%1.2f\n",proportional,pid_RPM.integrator,pid_RPM.out,pid_RPM.Kp,pid_RPM.KpFactor);             // to post current data        
+              SERIAL_ECHO(logMsg);
+            }   
+          //#endif
+
+          computePID_Classic();               // do the speed control work
+          //computePID_WindowMethod();
+           
+          pid_RPM.newTarget=0;                    // clear flag so log values only printed on first entry after setpoint change
+        } // if(SpindleLaser::isReady
+        else
+        { // reset all PID variables if spindle is off
+          pid_RPM.integrator = 0;
+          pid_RPM.prevError = 0;
+          pid_RPM.prevMeasurement = 0;
+          pid_RPM.prevPower = 0;
+          pid_RPM.out=0;
+          pid_RPM.newTarget = 1;
+          measured_RPM = 0;
+        }
+        //WRITE(P4_28,0);    //TG - ***** for scope measurement normally commented out
+        #endif // SPINDLE_USE_PID
+      
+      } // end if(gate_counter > (RPM_MEAS_TIME - 1))
+
+      //TG 12/21/22 inc the no-rpm counter, if it doesn't get cleared by Timer3 ISR before reaching RPM_LOSS_TIMEOUT then we 
+      //can assume rpm has dropped to less than the 60/(timeout period) so consider motor stopped, and force RPM to zero.
+      if(RPM_NO_SIGNAL++ > RPM_LOSS_TIMEOUT)
+      {
+        RPM_NO_SIGNAL = 0;
+        cutter.ACTUAL_RPM = measured_RPM = 0;         //TG 12/21/22 added
+      }
+
+    //WRITE(P2_12,0);     //TG - ***** for scope measurement normally commented out      
+    } // void RPM_tick
+
+  #pragma endregion // RPM_tick code called by HAL_TEMP_ISR
+
+  #pragma region - PID routines
+    #if SPINDLE_USE_PID
+    // Classic PID discrete-time calculation using pid_RPM structure, works best when M3/M4 speed command starts out with an initial
+    // minimum ocr speed of 25% SP (if it was currently zero) and leaving it at previous ocr if non-zero. Good values for K-factors are:
+    //   T = 0.25s          T = 0.50s         T = 1.00s
+    // PID_KP  0.16f      PID_KP  0.17f     PID_KP  0.10f
+    // PID_KI  0.28f      PID_KI  0.23f     PID_KI  0.18f
+    // PID_KD  0.00f      PID_KD  0.00f     PID_KD  0.00f
+    void computePID_Classic(void) 
+  {
+    //TG - optional compensate error scale dynamically according to setpoint range, corrects for non-symetric overshoots/undershoots
+        //if (errorSign < 0)
+        //     error = error * (0.60f + SP/50000.0f); // decrease falling error rate with SP
+        //if (errorSign > 0)
+        //    error = error * (0.55f + SP/20000.0f);  // increase rising error rate with SP
+    
+    proportional = pid_RPM.Kp * error;                                                                      // Proprtional
+    
+    // alternate averaged integral (error + prevError)/2
+    pid_RPM.integrator = pid_RPM.integrator + pid_RPM.Ki * pid_RPM.T * (error + pid_RPM.prevError);         // Intgeral
+        //pid.integrator = pid.integrator + pid.Ki * pid.T * error;                               // Intgeral
+    /* Anti-wind-up via integrator clamping */
+    LIMIT(pid_RPM.integrator,pid_RPM.limMinInt,pid_RPM.limMaxInt);
+                                    
+    /* Note: derivative on measurement, therefore minus sign in front of equation! */
+    pid_RPM.differentiator = -pid_RPM.Kd * (PV - pid_RPM.prevMeasurement) / pid_RPM.T;                      // Derivative
+    // alternate band-limited-derivative  (low pass filtered)
+    //pid_RPM.differentiator = -(2.0f * pid_RPM.Kd * (PV - pid_RPM.prevMeasurement)
+    //                     + (2.0f * pid_RPM.tau - pid_RPM.T) * pid_RPM.differentiator) / (2.0f * pid_RPM.tau + pid_RPM.T);
+    
+  
+    /* Compute output and apply limits */
+    pid_RPM.out = proportional + pid_RPM.integrator + pid_RPM.differentiator;	
+    LIMIT(pid_RPM.out,pid_RPM.limMin,pid_RPM.limMax);
+    
+    /* Store error and measurement for later use */
+    pid_RPM.prevError       = error;
+    pid_RPM.prevMeasurement = PV;
+    pid_RPM.prevPower = SpindleLaser::power;    // only needed for logging data during testing
+
+    pid_RPM.out = convertUnits(pid_RPM.out, CRPM, CPWM);
+    LIMIT(pid_RPM.out,1,SPINDLE_LASER_PWM_RES);
+        
+    // pwr unit is always PWM range  
+    // tried bypassing wrappers with apply_power() which took from 38 to 68us, and calling direct
+    // to LPC176x::pwm_write_ratio(), but it only reduced to 48us, so not worth it.
+    SpindleLaser::apply_power(pid_RPM.out);
+
+  }
+
+
+    //TG - 9/28/21 copies temp.bed PID constants to pid_RPM struct constants
+    void copy_PID_constants(void){
+      pid_RPM.Kp =  Temperature::temp_bed.pid.Kp;
+      pid_RPM.Ki =  unscalePID_i(Temperature::temp_bed.pid.Ki);
+      pid_RPM.Kd =  unscalePID_d(Temperature::temp_bed.pid.Kd);
+
+      // scale according to setpoint range, corrects for non-symetric overshoots/undershoots
+      // try some compensation to the K factors based on where the motor is heading
+      if (errorSign<0){         // for speed going down
+        if(SP>19999){           // needs more than standard gain 
+         pid_RPM.Kp *= 1.9;
+         pid_RPM.Ki *= 1.9; 
+        }
+        else if (SP>14999){     // needs standard gain
+          pid_RPM.Kp *= 1.0;
+          pid_RPM.Ki *= 1.0;
+        }
+        else{                   // below 15000 wants less than standard gain
+          pid_RPM.Kp *= 0.55;
+          pid_RPM.Ki *= 0.55;
+        }
+      }
+
+      if (errorSign>0){         // for speed going up
+        // everything below 15000 has standard gain
+        if(SP>15000){           // needs a little extra gain above 15000
+          pid_RPM.Kp *= 1.3;
+          pid_RPM.Ki *= 1.3;
+        }
+        else if(SP>20000){      // needs a lot more gain above 20000
+          pid_RPM.Kp *= 1.8;
+          pid_RPM.Ki *= 1.8;
+        }                       
+      }
+      return;
+
+      //#define EXP_TEST_ENABLED
+      //TG - 9/30/21 This is the experimental hack section to fine tune the PID to the DeWalt 660 (other motors will need different tweaks)
+      #if ENABLED(EXP_TEST_ENABLED)
+
+      //if (errorSign<0 && SP<15000 && abs(error)<11000){ // for negative errors(decreasing speed needed) only, the DeWalt seems to undershoot the
+      //  pid_RPM.Kp *= 0.50;         // setpoint more when the setpoint is below mid speed (150000)
+      //  pid_RPM.Ki *= 0.50;         // so we decrease the gain factors till we get acceptable undershoot
+      //  pid_RPM.Kd *= 0.50;
+      //}
+      //if (SP>15000){                // for positive errors(increasing speed needed), the DeWalt seems to undershoot the
+      //  pid_RPM.Kp *= 1.70;         // setpoint more when the setpoint is above mid-speed (15000)
+      //  pid_RPM.Ki *= 1.70;         // so we increase the gain factors, it needs this increased gain in the negative direction
+      //  pid_RPM.Kd *= 1.70;         // also till below mid-speed (15000), so we don't test for errorSign here
+      //}
+
+      //TG - 10/1/21  This compensation method applies a variable factor based on size of error, to Kp,Ki,Kd as follows:
+      // if negative error, KpFactor is scaled with error from 225% to 15% (equation mx + b), but no less than 15%
+      // the gain needs to be reduced as the error diminishes to avoid severe undershoot when target setpoint goes down
+      if (errorSign<0)  {
+      pid_RPM.KpFactor = (7.5e-5 * abs(error) + .15);                       // get factor according to size of error and equation
+      pid_RPM.KpFactor = pid_RPM.KpFactor<0.15 ? 0.15 : pid_RPM.KpFactor;   // limit low end
+      
+      //NOT SURE ABOUT THIS YET - BUT ANY DROPS IN SPEED WHEN SP IS ABOVE 10000 ARE VERY SLOW!!
+      //This speeds up Kfactor according to target SP, higher SP needs faster speed down.
+      if(SP>24000)                             
+        pid_RPM.KpFactor = pid_RPM.KpFactor * 7.0;
+      if(SP>18000)                             
+        pid_RPM.KpFactor = pid_RPM.KpFactor * 5.0;                    
+      else if(SP>12000)               
+        pid_RPM.KpFactor = pid_RPM.KpFactor * 1.8; 
+      else if(SP>8000)               
+        pid_RPM.KpFactor = pid_RPM.KpFactor * 1.0;       
+      else 
+        pid_RPM.KpFactor = pid_RPM.KpFactor * 0.65; 
+
+      pid_RPM.Kp *= pid_RPM.KpFactor;                       // apply factor
+      pid_RPM.Ki *= pid_RPM.KpFactor;
+      pid_RPM.Kd *= pid_RPM.KpFactor;
+    }
+
+      // if positive error, KpFactor is scaled with error from 351% to 85% (equation mx + b), but no less than 100%
+      // the gain needs to be increased for large positive error to avoid severe undershoot when target setpoint goes up
+      if (errorSign>0)  {
+      pid_RPM.KpFactor = (9.5e-5 * abs(error) + 0.9);      // get factor according to size of error and equation
+      pid_RPM.KpFactor = pid_RPM.KpFactor<1.0 ? 1.0 : pid_RPM.KpFactor;     // limit low end
+      
+      //NOT SURE ABOUT THIS YET - BUT ANY INCREASES IN SPEED WHEN SP IS ABOVE 12000 ARE VERY SLOW!
+      //TRY TO SPEED IT UP?? 
+      if(SP>20000 && abs(error) < 12000)                             
+        pid_RPM.KpFactor = pid_RPM.KpFactor * 1.6;
+      //if(SP>18000)                                                     
+      //  pid_RPM.KpFactor = pid_RPM.KpFactor * 1.02;                    
+      //else if(SP>12000)              
+      //  pid_RPM.KpFactor = pid_RPM.KpFactor * 1.01; 
+      //else if(SP>8000)               
+      //  pid_RPM.KpFactor = pid_RPM.KpFactor * 0.90;       
+      //else
+      //  pid_RPM.KpFactor = pid_RPM.KpFactor * 0.80;
+
+     pid_RPM.Kp *= pid_RPM.KpFactor;                      // apply factor 
+     pid_RPM.Ki *= pid_RPM.KpFactor;
+     pid_RPM.Kd *= pid_RPM.KpFactor; 
+    }    
+      #endif // #if ENABLED(EXP_TEST_ENABLED)
+
+
+    }
+
+    // My original method check error from target and decide how to trim the PWM (ocr), SpindleLaser::power is always in PWM (ocr) units 
+    void computePID_WindowMethod(void)
+    {
+    uint16_t hysteresis = 150;
+    int16_t ocr_step;         // must handle +/- need signed int
+    uint16_t OPR;
+    uint16_t new_OCR=0;
+    static uint16_t integral;
+  
+    if (pid_RPM.newTarget == 1)
+      integral = 0;
+  
+    OPR = convertUnits(SpindleLaser::power, CPWM, CRPM);              // get current power in RPM units
+    
+    integral += error/8;
+    ocr_step = error /18 + integral;                                  // calc step, it will be + or - as needed
+    
+    if (abs(PV-SP) > hysteresis)                                      // if outside of band, compensate                                      
+      new_OCR = ocr_step;
+    else
+      new_OCR =  OPR;                                                 // otherwise just hold steady
+    
+    new_OCR = convertUnits(new_OCR, CRPM, CPWM);
+    LIMIT(new_OCR,1,SPINDLE_LASER_PWM_RES);
+    SpindleLaser::apply_power(new_OCR);     // change pwr unit from RPM to PWM range
+    }
+    #endif // SPINDLE_USE_PID
+  #pragma endregion  
+  
+  #pragma region Timer3 ISR handler for PERIOD_MEASURE_MODE
+    // PERIOD_MEASURE_MODE, capture timer count every interrupt (RPM sensor pulse), subtract previous count to get period in usec
+    #ifdef PERIOD_MEASURE_MODE
+    //void TIMER3_IRQHandler(void)
+    HAL_RPM_TIMER_ISR()
+    {
+    	unsigned int current = 0 ;
+      unsigned int period = 0;
+      static unsigned int previous = 0;
+
+      LPC_TIM3->IR |= (1<<4);                         //Clear Interrupt Flag for Capture Channel 0
+    	current = LPC_TIM3->CR0;                  
+
+      if(current < previous)                          //TC has overflowed, so adjust for it
+    		period = 0xFFFFFFFF + current - previous;
+    	else
+    		period = current - previous;                  //otherwise get delta from last interrupt
+      
+      // filter out any erroneous period value which may occur from an invalid previous value from last time spindle stopped (ISR stopped)
+      if(period>2000U && period<60000000U){           // only update measured_RPM if period is reasonable 60,000,000(1rpm) to 2,000(30000rpm)
+        measured_RPM = (60.0/(period * TIMER_RES));   // Convert to frequency, 1us is Timer resolution
+        LIMIT(measured_RPM,0,30000);
+        cutter.ACTUAL_RPM = measured_RPM;             //TG 12/20/22 added because this is what TFT displays
+      }
+      previous = current;                            //LPC_TIM3->CR0, save for next interrupt calculation
+      RPM_NO_SIGNAL =0;                              //TG 12/21/22 keep this counter at zero when we have valid RPM signal
+    }	
+    #endif // PERIOD_MEASURE_MODE
+  #pragma endregion // Timer3 ISR handler for PERIOD_MEASURE_MODE
+  
+  #pragma region - Miscellaneous function for units conversion
+  uint16_t MarlinUnitsToRPM(float_t val)
+  {
+    return  CUTTER_UNIT_IS(PWM255) ? val * (SPEED_POWER_MAX-SPEED_POWER_MIN) / SPINDLE_LASER_PWM_RES  + 0.5f:
+            CUTTER_UNIT_IS(PERCENT) ? val * (SPEED_POWER_MAX-SPEED_POWER_MIN) / 100.0f  + 0.5f:
+            CUTTER_UNIT_IS(SERVO) ? val * (SPEED_POWER_MAX-SPEED_POWER_MIN) / 180  + 0.5f:
+            val;
+  }
+
+  //TG - 9/3/21 new function
+  // convert input value from one unit to another unit. Works best when both use the same unit.
+  uint16_t convertUnits(float_t val, CTYPE unit_in, CTYPE unit_out)
+  {
+    uint16_t cval;
+    
+    switch(unit_out)
+    {
+      case CPWM:  //output is PWM
+        cval = (unit_in == CPCT) ? val * SPINDLE_LASER_PWM_RES / 100.0f  + 0.5f :
+               (unit_in == CRPM) ? val * SPINDLE_LASER_PWM_RES / (SPEED_POWER_MAX-SPEED_POWER_MIN) + 0.5f:
+               (unit_in == CSERVO) ? val: 
+                val;
+        break;
+
+      case CPCT:  //targeting Marlin PCT mode
+        cval = (unit_in == CPWM) ? val * 100.0f / SPINDLE_LASER_PWM_RES  + 0.5f:
+               (unit_in == CRPM) ? val * 100.0f / (SPEED_POWER_MAX-SPEED_POWER_MIN) + 0.5f:
+               (unit_in == CSERVO) ? val * 100.0f / 180  + 0.5f:
+                val;
+        break;
+
+      case CRPM:  //targeting Marlin RPM mode
+        cval = (unit_in == CPWM) ? val * (SPEED_POWER_MAX-SPEED_POWER_MIN) / SPINDLE_LASER_PWM_RES  + 0.5f:
+               (unit_in == CPCT) ? val * (SPEED_POWER_MAX-SPEED_POWER_MIN) / 100.0f  + 0.5f:
+               (unit_in == CSERVO) ? val * (SPEED_POWER_MAX-SPEED_POWER_MIN) / 180  + 0.5f:
+                val;
+        break;
+
+      case CSERVO:  //targeting Marlin RPM mode
+        cval = (unit_in == CPWM) ? val:
+               (unit_in == CPCT) ? val * 180 / 100.0f + 0.5f:
+               (unit_in == CRPM) ? val * 180 / (SPEED_POWER_MAX-SPEED_POWER_MIN)  + 0.5f:
+                val;
+        break;
+
+      default:
+        cval = val;
+       break;
+    }
+    return cval;
+  }
+
+  void send_M117_msg(char * msg){
+    ui.set_status(msg);
+  }
+
+  #pragma endregion
+
+  #endif // #if ENABLED(USE_RPM_SENSOR)
+#endif // TARGET_LPC1768
diff --git a/Marlin/src/module/rpmSensor/rpmTimer.h b/Marlin/src/module/rpmSensor/rpmTimer.h
new file mode 100644
index 0000000000..6119c31a86
--- /dev/null
+++ b/Marlin/src/module/rpmSensor/rpmTimer.h
@@ -0,0 +1,260 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * Based in Marlin/HAL/timers.h adapted for using LPC_TMR3 to count rpm pulses with 2 different methods
+ * Also adds PID Speed control algorithm
+ * T. Gioiosa 2/19/21, 9/16/21
+ * Marlin 3D Printer Firmware
+ *
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2016 Bob Cousins bobcousins42@googlemail.com
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * HAL For LPC1768
+ */
+
+#if ENABLED(USE_RPM_SENSOR)
+
+#include <stdint.h>
+#include "../../core/macros.h"
+#include <LPC17xx.h>
+
+#pragma region  - Bit position names for use in SBI, CBI, or other bit manipulations
+#define SBIT_TIMER2 22  // Timer 2 power/clock control bit position in Power Control for Peripherals Register (PCONP)
+#define SBIT_TIMER3 23  // Timer 3 power/clock control bit position in Power Control for Peripherals Register (PCONP)
+#define SBIT_CNTEN 0    // Counter Enable control bit position in Timer Control Register (TCR)
+#define SBIT_MR0 0      // Timer Interrupt Register flag bit position for match channel 0
+#define SBIT_MR1 1      // Timer Interrupt Register flag bit position for match channel 1
+
+// These are for the Match Control register bit positions only!
+#define SBIT_MR0I  0 // Timer 0 Interrupt when TC matches MR0
+#define SBIT_MR0R  1 // Timer 0 Reset TC on Match
+#define SBIT_MR0S  2 // Timer 0 Stop TC and PC on Match
+#define SBIT_MR1I  3
+#define SBIT_MR1R  4
+#define SBIT_MR1S  5
+#define SBIT_MR2I  6
+#define SBIT_MR2R  7
+#define SBIT_MR2S  8
+#define SBIT_MR3I  9
+#define SBIT_MR3R 10
+#define SBIT_MR3S 11
+#pragma endregion
+
+#pragma region  - Defines to support the PID calculations
+//TG - these vars supports the PID calculations
+extern uint16_t hysteresis;
+extern uint16_t new_power;
+extern float_t error;
+extern uint16_t SP;                      
+extern uint16_t PV;                      
+extern float_t proportional;
+// struct definition for PID routine
+typedef struct {
+	float Kp;                   /* Controller gains */
+	float Ki;
+	float Kd;
+	float tau;                  /* Derivative low-pass filter time constant */
+	float limMin;               /* Output limits */
+	float limMax;
+	float limMinInt;            /* Integrator limits */
+	float limMaxInt;
+	float T;                    /* Sample time (in seconds) */
+	float integrator;           /* Controller "memory" */
+	float prevError;			      /* Required for integrator */
+	float differentiator;
+	float prevMeasurement;		  /* Required for differentiator */
+	float prevPower;
+  float out;                  /* Controller output */
+  float KpFactor;             /* experimental dynamic scale factor */
+  uint8_t newTarget;          /* flag indicates when a new Setpoint has been set */
+} PIDController;
+
+/* Controller parameters */             //   T = 0.25s          T = 0.50s         T = 1.00s
+#define PID_KP  0.30f                   // PID_KP  0.16f      PID_KP  0.17f     PID_KP  0.10f                   
+#define PID_KI  0.35f                   // PID_KI  0.28f      PID_KI  0.23f     PID_KI  0.18f
+#define PID_KD  0.00f                   // PID_KD  0.00f      PID_KD  0.00f     PID_KD  0.00f
+#define PID_TAU 0.02f
+#define PID_LIM_MIN -SPEED_POWER_MAX
+#define PID_LIM_MAX  SPEED_POWER_MAX
+#define PID_LIM_MIN_INT -SPEED_POWER_MAX
+#define PID_LIM_MAX_INT  SPEED_POWER_MAX
+#define SAMPLE_TIME_S 0.001f * RPM_SAMPLE_TIME       // sample rate in ms      
+extern PIDController pid_RPM;
+
+typedef enum  {       //TG 9/3/21 added to support unit conversions for RPM routines
+  CPWM = 0,
+  CPCT,
+  CRPM,  
+  CSERVO,
+  CONVERT_PWR_SIZE
+} CTYPE;
+#pragma endregion
+
+#pragma region  - Defines to Setup Timer 3 for RPM use
+//TG - 9/17/21  Marlin HAL has already assigned PWM to Timer 3, but we need Timer3 for RPM sensing,
+//     so we will reassign PWM to Timer 2 and define Timer 3 as the RPM timer
+#ifdef MF_TIMER_PWM
+  #undef MF_TIMER_PWM
+  #define MF_TIMER_PWM   2   //TG Re-define Index for PWM to Timer 2 since HAL has already defined it as Timer 3 (use modified SoftwarePWM.cpp !!)
+#endif
+#define MF_TIMER_RPM  3      //TG We assign RPM functions to Timer 3
+typedef uint32_t rpm_timer_t;
+//TG 9/1/21 The following provide functionality for timer 3 use as RPM_Timer, which are not found in HAL timer.h
+#define ENABLE_RPM_INTERRUPT() RPM_timer_enable_interrupt(MF_TIMER_RPM)
+#define DISABLE_RPM_INTERRUPT() RPM_timer_disable_interrupt(MF_TIMER_RPM)
+#define RPM_ISR_ENABLED() RPM_timer_interrupt_enabled(MF_TIMER_RPM)
+#ifndef HAL_RPM_TIMER_ISR
+  #define HAL_RPM_TIMER_ISR() _HAL_TIMER_ISR(MF_TIMER_RPM)   //TG 9/1/21 fixed this
+#endif
+#define RPM_TIMER_PTR _HAL_TIMER(MF_TIMER_RPM)
+#pragma endregion
+
+#pragma region - Defines For RPM measurement
+// For RPM measurement using the gate method, 1sec gate width gives best compromise bewteen quick response and accuracy
+// Here are the numbers for other settings
+//  GATE_WIDTH    Response Time   Accuracy
+//   500ms        Very good       +/- 120 rpm  poor
+//  1000ms        good            +/- 60 rpm   fair
+//  2000ms        fair            +/- 30 rpm   good
+//  4000ms        poor            +/- 15 rpm   very good
+// RPM sensor pulses are counted during RPM_SAMPLE_TIME/RPM_TICK_RATE in seconds
+
+//#define RPM_TICK_USES_TEMP_TIMER_FREQUENCY_2    //TG - enable this if you want RPM_TICK to occur faster than TEMP_TIMER rate of 1ms
+#ifndef RPM_TICK_USES_TEMP_TIMER_FREQUENCY_2
+  #define RPM_SAMPLE_TIME         250           // Interval in msec to process PID and send speed updates to TFT
+  #define RPM_TICK_RATE  TEMP_TIMER_FREQUENCY   // RPM_tick Rate pps = TEMP_TIMER_RATE of 1000 pps, ISR every 1ms)
+#else
+  #define RPM_SAMPLE_TIME         250           // Interval in msec to process PID and send speed updates to TFT
+  #define TEMP_TIMER_FREQUENCY_2 2000           // a frequency higher than TEMP_TIMER_FREQUENCY, using MR1 of TEMP_TIMER
+  #define RPM_TICK_RATE  TEMP_TIMER_FREQUENCY_2 // RPM_tick Rate pps = TEMP_TIMER_RATE of 1000 pps, ISR every 1ms)
+#endif
+#pragma endregion
+
+#pragma region - Public functions
+
+extern float measured_RPM;
+void RPM_timer_init(uint8_t timer_num);
+void RPM_tick(void);
+uint16_t convertUnits(float_t val, CTYPE unit_in, CTYPE unit_out);
+uint16_t MarlinUnitsToRPM(float_t val);
+void send_M117_msg(char * msg);
+void computePID_Classic(void);
+void computePID_WindowMethod(void);
+void copy_PID_constants(void);
+//void TIMER3_IRQHandler(void);
+
+#pragma endregion
+
+
+#pragma region - RPM timer start, stop, reset, setcompare, getcompare, getcount, enable/disable interrupts, interruptenabled?, isr_prologue
+FORCE_INLINE static void RPM_timer_start(const uint8_t timer_num) {
+  if(timer_num == 2)
+    LPC_TIM2->TCR = 0x1; // Counter Start
+  else if(timer_num == 3)
+    LPC_TIM3->TCR = 0x1; // Counter Start
+}
+
+FORCE_INLINE static void RPM_timer_stop(const uint8_t timer_num) {
+  if(timer_num == 2)
+    LPC_TIM2->TCR = 0x0; // Counter Stop
+  else if(timer_num == 3) 
+    LPC_TIM3->TCR = 0x0; // Counter Stop
+}
+
+FORCE_INLINE static void RPM_timer_reset(const uint8_t timer_num) {
+  if(timer_num == 2)
+    LPC_TIM2->TCR = 0x2; // Counter Stop
+  else if(timer_num == 3) 
+    LPC_TIM3->TCR = 0x2; // Counter Stop
+}
+
+FORCE_INLINE static void RPM_timer_set_compare(const rpm_timer_t compare) {
+   RPM_TIMER_PTR->MR0 = compare;  // RPM Timer Match Register 0
+}
+
+FORCE_INLINE static rpm_timer_t RPM_timer_get_compare(void) {
+  return RPM_TIMER_PTR->MR0;
+}
+
+FORCE_INLINE static rpm_timer_t RPM_timer_get_count(void) {
+  return RPM_TIMER_PTR->TC; //    Rpm Timer Count
+}
+
+//TG these duplicate the same functions as in Marlin\src\HAL\LPC1768\timers.h, but for RPM_timer use
+FORCE_INLINE static void RPM_timer_enable_interrupt(const uint8_t timer_num) {
+  switch (timer_num) {
+    case 0: break;
+    case 1: break;
+    case 2: NVIC_EnableIRQ(TIMER2_IRQn); break; // Enable interrupt handler
+    case 3: NVIC_EnableIRQ(TIMER3_IRQn); break; // Enable interrupt handler
+  }
+}
+
+FORCE_INLINE static void RPM_timer_disable_interrupt(const uint8_t timer_num) {
+  switch (timer_num) {
+    case 0: break;
+    case 1: break;
+    case 2: NVIC_DisableIRQ(TIMER2_IRQn); break; // Disable interrupt handler
+    case 3: NVIC_DisableIRQ(TIMER3_IRQn); break; // Disable interrupt handler
+  }
+
+  // We NEED memory barriers to ensure Interrupts are actually disabled!
+  // ( https://dzone.com/articles/nvic-disabling-interrupts-on-arm-cortex-m-and-the )
+  __DSB();
+  __ISB();
+}
+
+FORCE_INLINE static bool RPM_timer_interrupt_enabled(const uint8_t timer_num) {
+  switch (timer_num) {
+    case 0: return 0;
+    case 1: return 0;
+    case 2: return NVIC_GetEnableIRQ(TIMER2_IRQn); // Check if interrupt is enabled or not
+    case 3: return NVIC_GetEnableIRQ(TIMER3_IRQn); // Check if interrupt is enabled or not
+  }
+  return false;
+}
+
+FORCE_INLINE static void RPM_timer_isr_prologue(const uint8_t timer_num) {
+  switch (timer_num) {
+    case 0: break;
+    case 1: break;
+    case 2: 
+    case 3: SBI(RPM_TIMER_PTR->IR, SBIT_CNTEN); break;    //TG SBI-set bit at position SBIT_CNTEN(=0) in IR register
+  }
+}
+
+#define HAL_RPM_timer_isr_epilogue(TIMER_NUM)
+#pragma endregion
+
+#pragma region - Other miscellaneous functions
+// if you want RPM_TICK to occur faster than TEMP_TIMER rate of 1ms
+#ifdef RPM_TICK_USES_TEMP_TIMER_FREQUENCY_2
+  FORCE_INLINE static void setupFastRPMTickTimer(void)
+  {
+  NVIC_DisableIRQ(TIMER1_IRQn);
+  LPC_TIM1->TCR = 0x0;                                              //TG pause timer to make change
+  LPC_TIM1->MCR = _BV(SBIT_MR0I) | _BV(SBIT_MR0R) | _BV(SBIT_MR1I); // add Int on MR1 match to MR0 match and reset on MR0 
+  LPC_TIM1->TCR = _BV(SBIT_CNTEN); // Counter Enable
+  TEMP_TIMER_PTR->MR1 = uint32_t(TEMP_TIMER_RATE) / RPM_TICK_RATE;; // set Match INT1 ISR to occur at TEMP_TIMER_FREQUENCY_2
+  NVIC_EnableIRQ(TIMER1_IRQn);
+  }
+#endif
+
+#pragma endregion
+
+#endif // #if ENABLED(USE_RPM_SENSOR)
diff --git a/Marlin/src/module/settings.cpp b/Marlin/src/module/settings.cpp
index 8b615f2faf..33572fe222 100644
--- a/Marlin/src/module/settings.cpp
+++ b/Marlin/src/module/settings.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -36,7 +36,7 @@
  */
 
 // Change EEPROM version if the structure changes
-#define EEPROM_VERSION "V87"
+#define EEPROM_VERSION "V87"  //TG - 10/7/21 added a setting at end for PID state
 #define EEPROM_OFFSET 100
 
 // Check the integrity of data offsets.
@@ -171,6 +171,10 @@
   #include "../lcd/extui/dgus/DGUSDisplayDef.h"
 #endif
 
+#if ENABLED(SPINDLE_FEATURE)
+  #include "../feature/spindle_laser.h"      //TG - 9/27/21 added
+#endif
+
 #pragma pack(push, 1) // No padding between variables
 
 #if HAS_ETHERNET
@@ -599,6 +603,11 @@ typedef struct SettingsDataStruct {
           shaping_y_zeta;      // M593 Y D
   #endif
 
+  //TG just serves to declare variable type and size for storage in struct, not really used
+  #if ENABLED(SPINDLE_FEATURE)  
+  //  bool use_pid;               //TG 7/25/22 removed, PID now handled in AVRTriac control board                                               
+  #endif
+
 } SettingsData;
 
 //static_assert(sizeof(SettingsData) <= MARLIN_EEPROM_SIZE, "EEPROM too small to contain SettingsData!");
@@ -1114,11 +1123,11 @@ void MarlinSettings::postprocess() {
     //
     {
       _FIELD_TEST(bedPID);
-      #if ENABLED(PIDTEMPBED)
+      #if EITHER(PIDTEMPBED,PIDSPINDLE_USE_PIDTEMPBED)	//TG 9/21/21 was #if was ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
         const auto &pid = thermalManager.temp_bed.pid;
-        const raw_pid_t bed_pid = { pid.p(), pid.i(), pid.d() };
+        const raw_pid_t bed_pid = { pid.p(), pid.i(), pid.d() };	// Store the unscaled PID values
       #else
-        const raw_pid_t bed_pid = { NAN, NAN, NAN };
+        const raw_pid_t bed_pid = { NAN, NAN, NAN };				// Store null
       #endif
       EEPROM_WRITE(bed_pid);
     }
@@ -1628,6 +1637,13 @@ void MarlinSettings::postprocess() {
       EEPROM_WRITE(ui.language);
     #endif
 
+    //
+     //TG - 9/27/21 additional settings to store to EEPROM after all standard settings above
+    //
+    #if ENABLED(SPINDLE_FEATURE)                //TG 7/25/22 removed, cutter.spindle_use_pid is now PIDFLAG and stored in AVR EEPROM   
+      //EEPROM_WRITE(cutter.spindle_use_pid);   //TG - 9/27/21 store directly from cutter struct (doesn't use pid_control defined in SettingsDataStruct)
+    #endif              
+
     //
     // Model predictive control
     //
@@ -1856,7 +1872,7 @@ void MarlinSettings::postprocess() {
         #else
           // MBL is disabled - skip the stored data
           for (uint16_t q = mesh_num_x * mesh_num_y; q--;) EEPROM_READ(dummyf);
-        #endif
+        #endif // MESH_BED_LEVELING
       }
 
       //
@@ -2082,7 +2098,7 @@ void MarlinSettings::postprocess() {
       {
         raw_pid_t pid;
         EEPROM_READ(pid);
-        #if ENABLED(PIDTEMPBED)
+        #if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
           if (!validating && !isnan(pid.p))
             thermalManager.temp_bed.pid.set(pid);
         #endif
@@ -3230,7 +3246,7 @@ void MarlinSettings::reset() {
   // Heated Bed PID
   //
 
-  #if ENABLED(PIDTEMPBED)
+  #if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
     thermalManager.temp_bed.pid.set(DEFAULT_bedKp, DEFAULT_bedKi, DEFAULT_bedKd);
   #endif
 
@@ -3391,6 +3407,13 @@ void MarlinSettings::reset() {
   //
   TERN_(DWIN_LCD_PROUI, DWIN_SetDataDefaults());
 
+  //
+  //TG - 9/27/21 additional settings to reset value to default from Configuration.h
+  //TG 7/22/22 commented out this is now PIDFLAG and saved in AVR EEPROM
+  //#if ENABLED(SPINDLE_FEATURE)
+  //  cutter.spindle_use_pid = SPINDLE_USE_PID;
+  //#endif
+  
   //
   // Model predictive control
   //
@@ -3734,6 +3757,17 @@ void MarlinSettings::reset() {
     #endif
 
     TERN_(HAS_MULTI_LANGUAGE, gcode.M414_report(forReplay));
+    
+        //TG 10/3/21 added this to include Waveform Logging status
+    #if BOTH(PID_WAVEFORM_LOGGING, SPINDLE_FEATURE)
+      CONFIG_ECHO_MSG(" PID Waveform Logging: ON");
+    #else
+      CONFIG_ECHO_MSG(" PID Waveform Logging: OFF");
+    #endif
+    //TG 10/3/21 added this to include Spindle_Use_PID flag status for terminal log output only
+    #if ENABLED(SPINDLE_FEATURE)
+      CONFIG_ECHO_MSG("Spindle Use PID: M7979: ", cutter.spindle_use_pid);
+    #endif
 
     //
     // Model predictive control
diff --git a/Marlin/src/module/speed_lookuptable.h b/Marlin/src/module/speed_lookuptable.h
new file mode 100644
index 0000000000..b173ebec08
--- /dev/null
+++ b/Marlin/src/module/speed_lookuptable.h
@@ -0,0 +1,168 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#if F_CPU == 16000000
+
+  const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {
+    { 62500, 55556}, { 6944, 3268}, { 3676, 1176}, { 2500, 607}, { 1893, 369}, { 1524, 249}, { 1275, 179}, { 1096, 135},
+    { 961, 105}, { 856, 85}, { 771, 69}, { 702, 58}, { 644, 49}, { 595, 42}, { 553, 37}, { 516, 32},
+    { 484, 28}, { 456, 25}, { 431, 23}, { 408, 20}, { 388, 19}, { 369, 16}, { 353, 16}, { 337, 14},
+    { 323, 13}, { 310, 11}, { 299, 11}, { 288, 11}, { 277, 9}, { 268, 9}, { 259, 8}, { 251, 8},
+    { 243, 8}, { 235, 7}, { 228, 6}, { 222, 6}, { 216, 6}, { 210, 6}, { 204, 5}, { 199, 5},
+    { 194, 5}, { 189, 4}, { 185, 4}, { 181, 4}, { 177, 4}, { 173, 4}, { 169, 4}, { 165, 3},
+    { 162, 3}, { 159, 4}, { 155, 3}, { 152, 3}, { 149, 2}, { 147, 3}, { 144, 3}, { 141, 2},
+    { 139, 3}, { 136, 2}, { 134, 2}, { 132, 3}, { 129, 2}, { 127, 2}, { 125, 2}, { 123, 2},
+    { 121, 2}, { 119, 1}, { 118, 2}, { 116, 2}, { 114, 1}, { 113, 2}, { 111, 2}, { 109, 1},
+    { 108, 2}, { 106, 1}, { 105, 2}, { 103, 1}, { 102, 1}, { 101, 1}, { 100, 2}, { 98, 1},
+    { 97, 1}, { 96, 1}, { 95, 2}, { 93, 1}, { 92, 1}, { 91, 1}, { 90, 1}, { 89, 1},
+    { 88, 1}, { 87, 1}, { 86, 1}, { 85, 1}, { 84, 1}, { 83, 0}, { 83, 1}, { 82, 1},
+    { 81, 1}, { 80, 1}, { 79, 1}, { 78, 0}, { 78, 1}, { 77, 1}, { 76, 1}, { 75, 0},
+    { 75, 1}, { 74, 1}, { 73, 1}, { 72, 0}, { 72, 1}, { 71, 1}, { 70, 0}, { 70, 1},
+    { 69, 0}, { 69, 1}, { 68, 1}, { 67, 0}, { 67, 1}, { 66, 0}, { 66, 1}, { 65, 0},
+    { 65, 1}, { 64, 1}, { 63, 0}, { 63, 1}, { 62, 0}, { 62, 1}, { 61, 0}, { 61, 1},
+    { 60, 0}, { 60, 0}, { 60, 1}, { 59, 0}, { 59, 1}, { 58, 0}, { 58, 1}, { 57, 0},
+    { 57, 1}, { 56, 0}, { 56, 0}, { 56, 1}, { 55, 0}, { 55, 1}, { 54, 0}, { 54, 0},
+    { 54, 1}, { 53, 0}, { 53, 0}, { 53, 1}, { 52, 0}, { 52, 0}, { 52, 1}, { 51, 0},
+    { 51, 0}, { 51, 1}, { 50, 0}, { 50, 0}, { 50, 1}, { 49, 0}, { 49, 0}, { 49, 1},
+    { 48, 0}, { 48, 0}, { 48, 1}, { 47, 0}, { 47, 0}, { 47, 0}, { 47, 1}, { 46, 0},
+    { 46, 0}, { 46, 1}, { 45, 0}, { 45, 0}, { 45, 0}, { 45, 1}, { 44, 0}, { 44, 0},
+    { 44, 0}, { 44, 1}, { 43, 0}, { 43, 0}, { 43, 0}, { 43, 1}, { 42, 0}, { 42, 0},
+    { 42, 0}, { 42, 1}, { 41, 0}, { 41, 0}, { 41, 0}, { 41, 0}, { 41, 1}, { 40, 0},
+    { 40, 0}, { 40, 0}, { 40, 0}, { 40, 1}, { 39, 0}, { 39, 0}, { 39, 0}, { 39, 0},
+    { 39, 1}, { 38, 0}, { 38, 0}, { 38, 0}, { 38, 0}, { 38, 1}, { 37, 0}, { 37, 0},
+    { 37, 0}, { 37, 0}, { 37, 0}, { 37, 1}, { 36, 0}, { 36, 0}, { 36, 0}, { 36, 0},
+    { 36, 1}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 1},
+    { 34, 0}, { 34, 0}, { 34, 0}, { 34, 0}, { 34, 0}, { 34, 1}, { 33, 0}, { 33, 0},
+    { 33, 0}, { 33, 0}, { 33, 0}, { 33, 0}, { 33, 1}, { 32, 0}, { 32, 0}, { 32, 0},
+    { 32, 0}, { 32, 0}, { 32, 0}, { 32, 0}, { 32, 1}, { 31, 0}, { 31, 0}, { 31, 0},
+    { 31, 0}, { 31, 0}, { 31, 0}, { 31, 1}, { 30, 0}, { 30, 0}, { 30, 0}, { 30, 0}
+  };
+
+  const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {
+    { 62500, 12500}, { 50000, 8334}, { 41666, 5952}, { 35714, 4464}, { 31250, 3473}, { 27777, 2777}, { 25000, 2273}, { 22727, 1894},
+    { 20833, 1603}, { 19230, 1373}, { 17857, 1191}, { 16666, 1041}, { 15625, 920}, { 14705, 817}, { 13888, 731}, { 13157, 657},
+    { 12500, 596}, { 11904, 541}, { 11363, 494}, { 10869, 453}, { 10416, 416}, { 10000, 385}, { 9615, 356}, { 9259, 331},
+    { 8928, 308}, { 8620, 287}, { 8333, 269}, { 8064, 252}, { 7812, 237}, { 7575, 223}, { 7352, 210}, { 7142, 198},
+    { 6944, 188}, { 6756, 178}, { 6578, 168}, { 6410, 160}, { 6250, 153}, { 6097, 145}, { 5952, 139}, { 5813, 132},
+    { 5681, 126}, { 5555, 121}, { 5434, 115}, { 5319, 111}, { 5208, 106}, { 5102, 102}, { 5000, 99}, { 4901, 94},
+    { 4807, 91}, { 4716, 87}, { 4629, 84}, { 4545, 81}, { 4464, 79}, { 4385, 75}, { 4310, 73}, { 4237, 71},
+    { 4166, 68}, { 4098, 66}, { 4032, 64}, { 3968, 62}, { 3906, 60}, { 3846, 59}, { 3787, 56}, { 3731, 55},
+    { 3676, 53}, { 3623, 52}, { 3571, 50}, { 3521, 49}, { 3472, 48}, { 3424, 46}, { 3378, 45}, { 3333, 44},
+    { 3289, 43}, { 3246, 41}, { 3205, 41}, { 3164, 39}, { 3125, 39}, { 3086, 38}, { 3048, 36}, { 3012, 36},
+    { 2976, 35}, { 2941, 35}, { 2906, 33}, { 2873, 33}, { 2840, 32}, { 2808, 31}, { 2777, 30}, { 2747, 30},
+    { 2717, 29}, { 2688, 29}, { 2659, 28}, { 2631, 27}, { 2604, 27}, { 2577, 26}, { 2551, 26}, { 2525, 25},
+    { 2500, 25}, { 2475, 25}, { 2450, 23}, { 2427, 24}, { 2403, 23}, { 2380, 22}, { 2358, 22}, { 2336, 22},
+    { 2314, 21}, { 2293, 21}, { 2272, 20}, { 2252, 20}, { 2232, 20}, { 2212, 20}, { 2192, 19}, { 2173, 18},
+    { 2155, 19}, { 2136, 18}, { 2118, 18}, { 2100, 17}, { 2083, 17}, { 2066, 17}, { 2049, 17}, { 2032, 16},
+    { 2016, 16}, { 2000, 16}, { 1984, 16}, { 1968, 15}, { 1953, 16}, { 1937, 14}, { 1923, 15}, { 1908, 15},
+    { 1893, 14}, { 1879, 14}, { 1865, 14}, { 1851, 13}, { 1838, 14}, { 1824, 13}, { 1811, 13}, { 1798, 13},
+    { 1785, 12}, { 1773, 13}, { 1760, 12}, { 1748, 12}, { 1736, 12}, { 1724, 12}, { 1712, 12}, { 1700, 11},
+    { 1689, 12}, { 1677, 11}, { 1666, 11}, { 1655, 11}, { 1644, 11}, { 1633, 10}, { 1623, 11}, { 1612, 10},
+    { 1602, 10}, { 1592, 10}, { 1582, 10}, { 1572, 10}, { 1562, 10}, { 1552, 9}, { 1543, 10}, { 1533, 9},
+    { 1524, 9}, { 1515, 9}, { 1506, 9}, { 1497, 9}, { 1488, 9}, { 1479, 9}, { 1470, 9}, { 1461, 8},
+    { 1453, 8}, { 1445, 9}, { 1436, 8}, { 1428, 8}, { 1420, 8}, { 1412, 8}, { 1404, 8}, { 1396, 8},
+    { 1388, 7}, { 1381, 8}, { 1373, 7}, { 1366, 8}, { 1358, 7}, { 1351, 7}, { 1344, 8}, { 1336, 7},
+    { 1329, 7}, { 1322, 7}, { 1315, 7}, { 1308, 6}, { 1302, 7}, { 1295, 7}, { 1288, 6}, { 1282, 7},
+    { 1275, 6}, { 1269, 7}, { 1262, 6}, { 1256, 6}, { 1250, 7}, { 1243, 6}, { 1237, 6}, { 1231, 6},
+    { 1225, 6}, { 1219, 6}, { 1213, 6}, { 1207, 6}, { 1201, 5}, { 1196, 6}, { 1190, 6}, { 1184, 5},
+    { 1179, 6}, { 1173, 5}, { 1168, 6}, { 1162, 5}, { 1157, 5}, { 1152, 6}, { 1146, 5}, { 1141, 5},
+    { 1136, 5}, { 1131, 5}, { 1126, 5}, { 1121, 5}, { 1116, 5}, { 1111, 5}, { 1106, 5}, { 1101, 5},
+    { 1096, 5}, { 1091, 5}, { 1086, 4}, { 1082, 5}, { 1077, 5}, { 1072, 4}, { 1068, 5}, { 1063, 4},
+    { 1059, 5}, { 1054, 4}, { 1050, 4}, { 1046, 5}, { 1041, 4}, { 1037, 4}, { 1033, 5}, { 1028, 4},
+    { 1024, 4}, { 1020, 4}, { 1016, 4}, { 1012, 4}, { 1008, 4}, { 1004, 4}, { 1000, 4}, { 996, 4},
+    { 992, 4}, { 988, 4}, { 984, 4}, { 980, 4}, { 976, 4}, { 972, 4}, { 968, 3}, { 965, 3}
+  };
+
+#elif F_CPU == 20000000
+
+  const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {
+    {62500, 54055}, {8445, 3917}, {4528, 1434}, {3094, 745}, {2349, 456}, {1893, 307}, {1586, 222}, {1364, 167},
+    {1197, 131}, {1066, 105}, {961, 86}, {875, 72}, {803, 61}, {742, 53}, {689, 45}, {644, 40},
+    {604, 35}, {569, 32}, {537, 28}, {509, 25}, {484, 23}, {461, 21}, {440, 19}, {421, 17},
+    {404, 16}, {388, 15}, {373, 14}, {359, 13}, {346, 12}, {334, 11}, {323, 10}, {313, 10},
+    {303, 9}, {294, 9}, {285, 8}, {277, 7}, {270, 8}, {262, 7}, {255, 6}, {249, 6},
+    {243, 6}, {237, 6}, {231, 5}, {226, 5}, {221, 5}, {216, 5}, {211, 4}, {207, 5},
+    {202, 4}, {198, 4}, {194, 4}, {190, 3}, {187, 4}, {183, 3}, {180, 3}, {177, 4},
+    {173, 3}, {170, 3}, {167, 2}, {165, 3}, {162, 3}, {159, 2}, {157, 3}, {154, 2},
+    {152, 3}, {149, 2}, {147, 2}, {145, 2}, {143, 2}, {141, 2}, {139, 2}, {137, 2},
+    {135, 2}, {133, 2}, {131, 2}, {129, 1}, {128, 2}, {126, 2}, {124, 1}, {123, 2},
+    {121, 1}, {120, 2}, {118, 1}, {117, 1}, {116, 2}, {114, 1}, {113, 1}, {112, 2},
+    {110, 1}, {109, 1}, {108, 1}, {107, 2}, {105, 1}, {104, 1}, {103, 1}, {102, 1},
+    {101, 1}, {100, 1}, {99, 1}, {98, 1}, {97, 1}, {96, 1}, {95, 1}, {94, 1},
+    {93, 1}, {92, 1}, {91, 0}, {91, 1}, {90, 1}, {89, 1}, {88, 1}, {87, 0},
+    {87, 1}, {86, 1}, {85, 1}, {84, 0}, {84, 1}, {83, 1}, {82, 1}, {81, 0},
+    {81, 1}, {80, 1}, {79, 0}, {79, 1}, {78, 0}, {78, 1}, {77, 1}, {76, 0},
+    {76, 1}, {75, 0}, {75, 1}, {74, 1}, {73, 0}, {73, 1}, {72, 0}, {72, 1},
+    {71, 0}, {71, 1}, {70, 0}, {70, 1}, {69, 0}, {69, 1}, {68, 0}, {68, 1},
+    {67, 0}, {67, 1}, {66, 0}, {66, 1}, {65, 0}, {65, 0}, {65, 1}, {64, 0},
+    {64, 1}, {63, 0}, {63, 1}, {62, 0}, {62, 0}, {62, 1}, {61, 0}, {61, 1},
+    {60, 0}, {60, 0}, {60, 1}, {59, 0}, {59, 0}, {59, 1}, {58, 0}, {58, 0},
+    {58, 1}, {57, 0}, {57, 0}, {57, 1}, {56, 0}, {56, 0}, {56, 1}, {55, 0},
+    {55, 0}, {55, 1}, {54, 0}, {54, 0}, {54, 1}, {53, 0}, {53, 0}, {53, 0},
+    {53, 1}, {52, 0}, {52, 0}, {52, 1}, {51, 0}, {51, 0}, {51, 0}, {51, 1},
+    {50, 0}, {50, 0}, {50, 0}, {50, 1}, {49, 0}, {49, 0}, {49, 0}, {49, 1},
+    {48, 0}, {48, 0}, {48, 0}, {48, 1}, {47, 0}, {47, 0}, {47, 0}, {47, 1},
+    {46, 0}, {46, 0}, {46, 0}, {46, 0}, {46, 1}, {45, 0}, {45, 0}, {45, 0},
+    {45, 1}, {44, 0}, {44, 0}, {44, 0}, {44, 0}, {44, 1}, {43, 0}, {43, 0},
+    {43, 0}, {43, 0}, {43, 1}, {42, 0}, {42, 0}, {42, 0}, {42, 0}, {42, 0},
+    {42, 1}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 1}, {40, 0},
+    {40, 0}, {40, 0}, {40, 0}, {40, 1}, {39, 0}, {39, 0}, {39, 0}, {39, 0},
+    {39, 0}, {39, 0}, {39, 1}, {38, 0}, {38, 0}, {38, 0}, {38, 0}, {38, 0},
+  };
+
+  const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {
+    {62500, 10417}, {52083, 7441}, {44642, 5580}, {39062, 4340}, {34722, 3472}, {31250, 2841}, {28409, 2368}, {26041, 2003},
+    {24038, 1717}, {22321, 1488}, {20833, 1302}, {19531, 1149}, {18382, 1021}, {17361, 914}, {16447, 822}, {15625, 745},
+    {14880, 676}, {14204, 618}, {13586, 566}, {13020, 520}, {12500, 481}, {12019, 445}, {11574, 414}, {11160, 385},
+    {10775, 359}, {10416, 336}, {10080, 315}, {9765, 296}, {9469, 278}, {9191, 263}, {8928, 248}, {8680, 235},
+    {8445, 222}, {8223, 211}, {8012, 200}, {7812, 191}, {7621, 181}, {7440, 173}, {7267, 165}, {7102, 158},
+    {6944, 151}, {6793, 145}, {6648, 138}, {6510, 133}, {6377, 127}, {6250, 123}, {6127, 118}, {6009, 113},
+    {5896, 109}, {5787, 106}, {5681, 101}, {5580, 98}, {5482, 95}, {5387, 91}, {5296, 88}, {5208, 86},
+    {5122, 82}, {5040, 80}, {4960, 78}, {4882, 75}, {4807, 73}, {4734, 70}, {4664, 69}, {4595, 67},
+    {4528, 64}, {4464, 63}, {4401, 61}, {4340, 60}, {4280, 58}, {4222, 56}, {4166, 55}, {4111, 53},
+    {4058, 52}, {4006, 51}, {3955, 49}, {3906, 48}, {3858, 48}, {3810, 45}, {3765, 45}, {3720, 44},
+    {3676, 43}, {3633, 42}, {3591, 40}, {3551, 40}, {3511, 39}, {3472, 38}, {3434, 38}, {3396, 36},
+    {3360, 36}, {3324, 35}, {3289, 34}, {3255, 34}, {3221, 33}, {3188, 32}, {3156, 31}, {3125, 31},
+    {3094, 31}, {3063, 30}, {3033, 29}, {3004, 28}, {2976, 28}, {2948, 28}, {2920, 27}, {2893, 27},
+    {2866, 26}, {2840, 25}, {2815, 25}, {2790, 25}, {2765, 24}, {2741, 24}, {2717, 24}, {2693, 23},
+    {2670, 22}, {2648, 22}, {2626, 22}, {2604, 22}, {2582, 21}, {2561, 21}, {2540, 20}, {2520, 20},
+    {2500, 20}, {2480, 20}, {2460, 19}, {2441, 19}, {2422, 19}, {2403, 18}, {2385, 18}, {2367, 18},
+    {2349, 17}, {2332, 18}, {2314, 17}, {2297, 16}, {2281, 17}, {2264, 16}, {2248, 16}, {2232, 16},
+    {2216, 16}, {2200, 15}, {2185, 15}, {2170, 15}, {2155, 15}, {2140, 15}, {2125, 14}, {2111, 14},
+    {2097, 14}, {2083, 14}, {2069, 14}, {2055, 13}, {2042, 13}, {2029, 13}, {2016, 13}, {2003, 13},
+    {1990, 13}, {1977, 12}, {1965, 12}, {1953, 13}, {1940, 11}, {1929, 12}, {1917, 12}, {1905, 12},
+    {1893, 11}, {1882, 11}, {1871, 11}, {1860, 11}, {1849, 11}, {1838, 11}, {1827, 11}, {1816, 10},
+    {1806, 11}, {1795, 10}, {1785, 10}, {1775, 10}, {1765, 10}, {1755, 10}, {1745, 9}, {1736, 10},
+    {1726, 9}, {1717, 10}, {1707, 9}, {1698, 9}, {1689, 9}, {1680, 9}, {1671, 9}, {1662, 9},
+    {1653, 9}, {1644, 8}, {1636, 9}, {1627, 8}, {1619, 9}, {1610, 8}, {1602, 8}, {1594, 8},
+    {1586, 8}, {1578, 8}, {1570, 8}, {1562, 8}, {1554, 7}, {1547, 8}, {1539, 8}, {1531, 7},
+    {1524, 8}, {1516, 7}, {1509, 7}, {1502, 7}, {1495, 7}, {1488, 7}, {1481, 7}, {1474, 7},
+    {1467, 7}, {1460, 7}, {1453, 7}, {1446, 6}, {1440, 7}, {1433, 7}, {1426, 6}, {1420, 6},
+    {1414, 7}, {1407, 6}, {1401, 6}, {1395, 7}, {1388, 6}, {1382, 6}, {1376, 6}, {1370, 6},
+    {1364, 6}, {1358, 6}, {1352, 6}, {1346, 5}, {1341, 6}, {1335, 6}, {1329, 5}, {1324, 6},
+    {1318, 5}, {1313, 6}, {1307, 5}, {1302, 6}, {1296, 5}, {1291, 5}, {1286, 6}, {1280, 5},
+    {1275, 5}, {1270, 5}, {1265, 5}, {1260, 5}, {1255, 5}, {1250, 5}, {1245, 5}, {1240, 5},
+    {1235, 5}, {1230, 5}, {1225, 5}, {1220, 5}, {1215, 4}, {1211, 5}, {1206, 5}, {1201, 5},
+  };
+
+#endif
diff --git a/Marlin/src/module/temperature.cpp b/Marlin/src/module/temperature.cpp
index b572690256..bbeccbad4a 100644
--- a/Marlin/src/module/temperature.cpp
+++ b/Marlin/src/module/temperature.cpp
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -24,6 +24,7 @@
  * temperature.cpp - temperature control
  */
 
+#pragma region TG - Includes and defines ****************************************************************************
 // Useful when debugging thermocouples
 //#define IGNORE_THERMOCOUPLE_ERRORS
 
@@ -37,6 +38,20 @@
 #include "planner.h"
 #include "printcounter.h"
 
+#include "src/feature/spindle_laser.h"
+
+#if ENABLED(TG_I2C_SUPPORT)	                    //TG 12/16/22 put #if clause
+  #include "../module/TG_I2C/TG_I2CSlave.h"     //TG 5/12/22 added for I2C comm with AVR Triac Controller board.
+#endif
+#if ENABLED(USE_RPM_SENSOR)
+  #include "../module/rpmSensor/RPMTimer.h"     //TG 12/20/22 put #if clause
+#else
+  #include "../HAL/LPC1768/timers.h"
+#endif 
+#if ENABLED(VFD_CONTROLLER)	                    //TG 12/16/22
+  #include "vfd.h"
+#endif
+
 #if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../feature/cooler.h"
   #include "../feature/spindle_laser.h"
@@ -208,12 +223,14 @@
   static constexpr uint8_t heater_ttbllen_map[HOTENDS] = ARRAY_BY_HOTENDS(TEMPTABLE_0_LEN REPEAT_S(1, HOTENDS, NEXT_TEMPTABLE_LEN));
 #endif
 
-Temperature thermalManager;
+Temperature thermalManager;   //TG - create an instance of the Temperature class named thermalManager
 
 PGMSTR(str_t_thermal_runaway, STR_T_THERMAL_RUNAWAY);
 PGMSTR(str_t_temp_malfunction, STR_T_MALFUNCTION);
 PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
+#pragma endregion TG - end Includes and defines
 
+#pragma region TG - Macros to include the heater id in temp errors **************************************************
 /**
  * Macros to include the heater id in temp errors. The compiler's dead-code
  * elimination should (hopefully) optimize out the unused strings.
@@ -236,7 +253,9 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #endif
 #define _E_FSTR(h,N) ((HOTENDS) > N && (h) == N) ? F(STR_E##N) :
 #define HEATER_FSTR(h) _BED_FSTR(h) _CHAMBER_FSTR(h) _COOLER_FSTR(h) _E_FSTR(h,1) _E_FSTR(h,2) _E_FSTR(h,3) _E_FSTR(h,4) _E_FSTR(h,5) _E_FSTR(h,6) _E_FSTR(h,7) F(STR_E0)
+#pragma endregion TG - end Macros to include the heater id in temp errors
 
+#pragma region TG - Initialize MAX TC objects/SPI
 //
 // Initialize MAX TC objects/SPI
 //
@@ -306,11 +325,10 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
   #undef MAXTC_INIT
 
 #endif
+#pragma endregion
 
-/**
- * public:
- */
-
+// public: *********************************************************************************************
+#pragma region TG - public variables and structures definitions *****************************************************
 #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
   bool Temperature::adaptive_fan_slowing = true;
 #endif
@@ -496,6 +514,42 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 
 #endif // HAS_FAN
 
+//==========================================================================================
+//               Spindle speed and report functions 
+//TG 5/25/21     Added this section to support SPINDLE RPM features
+//==========================================================================================
+#if ENABLED(SPINDLE_FEATURE)    //TG 1/17/20 added this for sending spindle speed S0: messages
+   extern Temperature::spindle_type Temperature::spindle_speed[SPINDLES];
+
+  // Set the desired spindle speed for an index
+  void Temperature::set_spindle_speed(uint8_t target, uint16_t speed) {
+    if (target >= SPINDLES) return;
+
+    spindle_speed[target].target = speed; // set desired speed
+    TERN_(REPORT_SPINDLE_CHANGE, report_spindle_speed(target));
+  }
+
+  // routine to copy measured RPM to spindle_speed[].actual
+  uint16_t Temperature::get_spindle_speed(uint8_t target) {
+    if (target >= SPINDLES) return 0;
+    spindle_speed[target].actual = cutter.ACTUAL_RPM;  //TG 12/24/22 supplied by rpmTimer.cpp or from I2C as ACTUAL_RPM
+    return spindle_speed[target].actual;
+}
+
+  #if ENABLED(REPORT_SPINDLE_CHANGE)
+    /**
+     * Report spindle speed
+     */
+    void Temperature::report_spindle_speed(const uint8_t target) {
+      if (target >= SPINDLES) return;
+      PORT_REDIRECT(SerialMask::All);
+      //SERIAL_ECHOLNPAIR_F("M3 P", target, " S", spindle_speed[target].actual, " Target", spindle_speed[target].target);
+      SERIAL_ECHOLNPGM("Spindle P", target, " A:", spindle_speed[target].actual, " T:", spindle_speed[target].target);
+    }
+  #endif
+#endif // ENABLED SPINDLE_FEATURE
+//TG - end Spindle speed *******************************************************************************
+
 #if WATCH_HOTENDS
   hotend_watch_t Temperature::watch_hotend[HOTENDS]; // = { { 0 } }
 #endif
@@ -573,13 +627,17 @@ PGMSTR(str_t_heating_failed, STR_T_HEATING_FAILED);
 #if ENABLED(PID_EXTRUSION_SCALING)
   int16_t Temperature::lpq_len; // Initialized in settings.cpp
 #endif
+#pragma endregion TG - public variables and structures definitions
 
-/**
- * private:
- */
+// private: ********************************************************************************************
+#pragma region TG - private variables and structures definitions ****************************************************
 
 volatile bool Temperature::raw_temps_ready = false;
 
+#if ENABLED(PID_EXTRUSION_SCALING)
+  int32_t Temperature::pes_e_position, Temperature::lpq[LPQ_MAX_LEN];
+  lpq_ptr_t Temperature::lpq_ptr = 0;
+#endif
 
 #if ENABLED(MPCTEMP)
   int32_t Temperature::mpc_e_position; // = 0
@@ -634,11 +692,11 @@ volatile bool Temperature::raw_temps_ready = false;
 #if ENABLED(PROBING_HEATERS_OFF)
   bool Temperature::paused_for_probing;
 #endif
+#pragma endregion TG - private variables and structures definitions
 
-/**
- * public:
- * Class and Instance Methods
- */
+// public: Class and Instance Methods************************************************************************
+
+#pragma region TG - PID Autotune ************************************************************************************
 
 #if HAS_PID_HEATING
 
@@ -1189,6 +1247,9 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   }
 }
 
+#pragma endregion TG - PID Autotune
+
+#pragma region TG - AutoFan *****************************************************************************************
 #define _EFANOVERLAP(A,B) _FANOVERLAP(E##A,B)
 
 #if HAS_AUTO_FAN
@@ -1305,10 +1366,9 @@ int16_t Temperature::getHeaterPower(const heater_id_t heater_id) {
   }
 
 #endif // HAS_AUTO_FAN
+#pragma endregion TG - AutoFan
 
-//
-// Temperature Error Handlers
-//
+#pragma region TG - Temperature Error Handlers **********************************************************************
 
 inline void loud_kill(FSTR_P const lcd_msg, const heater_id_t heater_id) {
   marlin_state = MF_KILLED;
@@ -1401,7 +1461,9 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
   #endif
   _temp_error(heater_id, F(STR_T_MINTEMP), GET_TEXT_F(MSG_ERR_MINTEMP));
 }
+#pragma endregion TG - end Temperature Error Handlers ***************************************************************
 
+#pragma region TG - PID handling standard HotEnd, Bed, Chamber ******************************************************
 #if HAS_PID_DEBUG
   bool Temperature::pid_debug_flag; // = false
 #endif
@@ -1902,6 +1964,10 @@ void Temperature::mintemp_error(const heater_id_t heater_id) {
 
 #endif // HAS_COOLER
 
+#pragma endregion TG - end PID handling *****************************************************************************
+
+#pragma region TG - Temperature::manage_heater() ********************************************************************
+
 /**
  * Manage heating activities for extruder hot-ends and a heated bed
  *  - Acquire updated temperature readings
@@ -2000,6 +2066,9 @@ void Temperature::task() {
 
   UNUSED(ms);
 }
+#pragma endregion TG - end Temperature::manage_heater() *************************************************************
+
+#pragma region TG - Thermistor setup, macro to scan thermistor tables, and functions for raw->celsius conversion ****
 
 #define TEMP_AD595(RAW)  ((RAW) * 5.0 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET)
 #define TEMP_AD8495(RAW) ((RAW) * 6.6 * 100.0 / float(HAL_ADC_RANGE) / (OVERSAMPLENR) * (TEMP_SENSOR_AD8495_GAIN) + TEMP_SENSOR_AD8495_OFFSET)
@@ -2026,7 +2095,7 @@ void Temperature::task() {
   }                                                                       \
 }while(0)
 
-#if HAS_USER_THERMISTORS
+#if HAS_USER_THERMISTORS  //TG - if has any custom user defined thermistors
 
   user_thermistor_t Temperature::user_thermistor[USER_THERMISTORS]; // Initialized by settings.load()
 
@@ -2508,6 +2577,7 @@ void Temperature::updateTemperaturesFromRawValues() {
 
 } // Temperature::updateTemperaturesFromRawValues
 
+#pragma region TG - Temperature::init() *****************************************************************************
 /**
  * Initialize the temperature manager
  *
@@ -2729,7 +2799,12 @@ void Temperature::init() {
     SET_INPUT_PULLUP(JOY_EN_PIN);
   #endif
 
-  HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);
+  HAL_timer_start(MF_TIMER_TEMP, TEMP_TIMER_FREQUENCY);  //TG sets up the TEMP_TIMER (Timer 1) to 1000Hz
+  
+  //TG 9/8/21 - used to add an MR1 match ISR to TEMP_TIMER for faster calls to RPM tick
+  #ifdef RPM_TICK_USES_TEMP_TIMER_FREQUENCY_2
+    setupFastRPMTickTimer();    
+  #endif
   ENABLE_TEMPERATURE_INTERRUPT();
 
   #if HAS_AUTO_FAN_0
@@ -2867,7 +2942,9 @@ void Temperature::init() {
     );
   #endif
 }
+#pragma endregion TG - end Temperature::init() *************************************************************************
 
+#pragma region TG - Thermal Runaway State Machine *******************************************************************
 #if HAS_THERMAL_PROTECTION
 
   #pragma GCC diagnostic push
@@ -3042,7 +3119,9 @@ void Temperature::disable_all_heaters() {
     WRITE_HEATER_COOLER(LOW);
   #endif
 }
+#pragma endregion TG - Thermal Runaway State Machine
 
+#pragma region TG - Print Job AutoStart *****************************************************************************
 #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
 
   bool Temperature::auto_job_over_threshold() {
@@ -3064,8 +3143,10 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // PRINTJOB_TIMER_AUTOSTART
+#pragma endregion TG - Print Job AutoStart
 
-#if ENABLED(PROBING_HEATERS_OFF)
+#pragma region TG - Heaters OFF when Probing ************************************************************************
+#if ENABLED(PROBING_HEATERS_OFF)        //TG - if enabled, turn off heaters when probing Z-axis
 
   void Temperature::pause_heaters(const bool p) {
     if (p != paused_for_probing) {
@@ -3082,8 +3163,10 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // PROBING_HEATERS_OFF
+#pragma endregion TG - Heaters OFF when Probing
 
-#if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
+#pragma region TG - Any multi-extruder that shares a single nozzle **************************************************
+#if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN) //TG - For Cyclops or any "multi-extruder" that shares a single nozzle.
 
   void Temperature::singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool) {
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
@@ -3102,8 +3185,10 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // SINGLENOZZLE_STANDBY_TEMP || SINGLENOZZLE_STANDBY_FAN
+#pragma endregion TG - Any multi-extruder that shares a single nozzle
 
-#if HAS_MAX_TC
+#pragma region TG - If using MAXIM temperature sensor chips *********************************************************
+#if HAS_MAX_TC                          //TG - if using MAXIM temperature sensor chips
 
   #ifndef THERMOCOUPLE_MAX_ERRORS
     #define THERMOCOUPLE_MAX_ERRORS 15
@@ -3276,7 +3361,9 @@ void Temperature::disable_all_heaters() {
   }
 
 #endif // HAS_MAX_TC
+#pragma endregion TG - Any multi-extruder that shares a single nozzle
 
+#pragma region TG - Raw temperature Updates *************************************************************************
 /**
  * Update raw temperatures
  *
@@ -3349,7 +3436,9 @@ void Temperature::readings_ready() {
   TERN_(HAS_JOY_ADC_Y, joystick.y.reset());
   TERN_(HAS_JOY_ADC_Z, joystick.z.reset());
 }
+#pragma endregion TG - end raw temerature Updates *******************************************************************
 
+#pragma region TG - HAL Temperature ISR Setup ***********************************************************************
 /**
  * Timer 0 is shared with millies so don't change the prescaler.
  *
@@ -3367,12 +3456,18 @@ void Temperature::readings_ready() {
  */
 HAL_TEMP_TIMER_ISR() {
   HAL_timer_isr_prologue(MF_TIMER_TEMP);
+  //SBI(TEMP_TIMER_PTR->IR, SBIT_MR0);              //TG 9/8/21 resets IR flag for match interrupt 0, does same as HAL_timer_isr_prologue()
+  #if ENABLED(USE_RPM_SENSOR)                       //TG 12/20/21 added #if 
+    RPM_tick();                                     // call RPM code every 1ms - only if enabled
+  #endif
 
-  Temperature::isr();
-
+  Temperature::isr();                               // call Marlin Temperature handler every 1ms
   HAL_timer_isr_epilogue(MF_TIMER_TEMP);
 }
 
+#pragma endregion TG - end HAL Temperature ISR Setup ****************************************************************
+
+#pragma region TG - The SoftPWM class ******************************************************************************* 
 #if ENABLED(SLOW_PWM_HEATERS) && !defined(MIN_STATE_TIME)
   #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
 #endif
@@ -3380,8 +3475,8 @@ HAL_TEMP_TIMER_ISR() {
 class SoftPWM {
 public:
   uint8_t count;
-  inline bool add(const uint8_t mask, const uint8_t amount) {
-    count = (count & mask) + amount; return (count > mask);
+  inline bool add(const uint8_t mask, const uint8_t amount) {   //TG - this func inc's count & mask by amount and returns 1 or 0
+    count = (count & mask) + amount; return (count > mask);     //  this is how the PWM duty cycle is determined
   }
   #if ENABLED(SLOW_PWM_HEATERS)
     bool state_heater;
@@ -3397,7 +3492,9 @@ public:
     }
   #endif
 };
+#pragma endregion TG - end The SoftPWM class ************************************************************************
 
+#pragma region TG - HAL Temperature ISR *****************************************************************************
 /**
  * Handle various ~1kHz tasks associated with temperature
  *  - Check laser safety timeout
@@ -3454,6 +3551,7 @@ void Temperature::isr() {
 
   #if DISABLED(SLOW_PWM_HEATERS)
 
+    //TG - define macro to switch PWM high or low (according to soft_pwm_amount) for hotend, heated_bed, heated_chamber, cooler, or fan_soft_pwm
     #if ANY(HAS_HOTEND, HAS_HEATED_BED, HAS_HEATED_CHAMBER, HAS_COOLER, FAN_SOFT_PWM)
       constexpr uint8_t pwm_mask = TERN0(SOFT_PWM_DITHER, _BV(SOFT_PWM_SCALE) - 1);
       #define _PWM_MOD(N,S,T) do{                           \
@@ -3463,9 +3561,9 @@ void Temperature::isr() {
     #endif
 
     /**
-     * Standard heater PWM modulation
+     * Standard heater PWM modulation   //TG - pwm_count ranges 0 - 127 max (128 max step resolution when SOFT_PWM_SCALE=0)
      */
-    if (pwm_count_tmp >= 127) {
+    if (pwm_count_tmp >= 127) {   // reset pwm_count when reached 127
       pwm_count_tmp -= 127;
 
       #if HAS_HOTEND
@@ -3473,8 +3571,8 @@ void Temperature::isr() {
         REPEAT(HOTENDS, _PWM_MOD_E);
       #endif
 
-      #if HAS_HEATED_BED
-        _PWM_MOD(BED, soft_pwm_bed, temp_bed);
+      #if HAS_HEATED_BED                        //TG - soft_pwm_bed is Soft_PWM Class instance, temp_bed is heater_info_t structure
+        _PWM_MOD(BED,soft_pwm_bed,temp_bed);    //TG - switches PWM high or low according to soft_pwm_amount using macro    
       #endif
 
       #if HAS_HEATED_CHAMBER
@@ -3491,6 +3589,8 @@ void Temperature::isr() {
           WRITE(CONTROLLER_FAN_PIN, soft_pwm_controller.add(pwm_mask, soft_pwm_controller_speed));
         #endif
 
+
+        //TG - define macro to switch PWM high or low for software_pwm fans
         #define _FAN_PWM(N) do{                                     \
           uint8_t &spcf = soft_pwm_count_fan[N];                    \
           spcf = (spcf & pwm_mask) + (soft_pwm_amount_fan[N] >> 1); \
@@ -3524,6 +3624,7 @@ void Temperature::isr() {
       #endif
     }
     else {
+      //TG - macro to force respective PWM pin to zero while it's counter<=pwm_count_tmp
       #define _PWM_LOW(N,S) do{ if (S.count <= pwm_count_tmp) WRITE_HEATER_##N(LOW); }while(0)
       #if HAS_HOTEND
         #define _PWM_LOW_E(N) _PWM_LOW(N, soft_pwm_hotend[N]);
@@ -3581,7 +3682,7 @@ void Temperature::isr() {
     // 3:                / 16 =  61.0352 Hz
     // 4:                /  8 = 122.0703 Hz
     // 5:                /  4 = 244.1406 Hz
-    pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);
+    pwm_count = pwm_count_tmp + _BV(SOFT_PWM_SCALE);  // increment count by 1,2,4,8,16,32 (2^SOFT_PWM_SCALE)
 
   #else // SLOW_PWM_HEATERS
 
@@ -3719,7 +3820,7 @@ void Temperature::isr() {
   #endif // SLOW_PWM_HEATERS
 
   //
-  // Update lcd buttons 488 times per second
+  // Update lcd buttons 488 times per second (toggles do_buttons to divide by 2)
   //
   static bool do_buttons;
   if ((do_buttons ^= true)) ui.update_buttons();
@@ -3934,9 +4035,13 @@ void Temperature::isr() {
   // Periodically call the planner timer service routine
   planner.isr();
 }
+#pragma endregion TG - end Temperature::isr() ***********************************************************************
+
+#pragma region TG - support functions for reporting temps, autoreporting, wait_for_heating **************************
 
 #if HAS_TEMP_SENSOR
-  /**
+
+  /** //TG this is what reports temperatures for M105, AUTOREPORT
    * Print a single heater state in the form:
    *        Bed: " B:nnn.nn /nnn.nn"
    *    Chamber: " C:nnn.nn /nnn.nn"
@@ -3945,6 +4050,7 @@ void Temperature::isr() {
    *  Redundant: " R:nnn.nn /nnn.nn"
    *   Extruder: " T0:nnn.nn /nnn.nn"
    *   With ADC: " T0:nnn.nn /nnn.nn (nnn.nn)"
+   *With Spindle:" S0:nnn.nn /nnn.nn"   //TG 5/25/21 Added spindle speed
    */
   static void print_heater_state(const heater_id_t e, const_celsius_float_t c, const_celsius_float_t t
     OPTARG(SHOW_TEMP_ADC_VALUES, const float r)
@@ -3955,6 +4061,9 @@ void Temperature::isr() {
         #if HAS_TEMP_HOTEND
           k = 'T'; break;
         #endif
+      #if ENABLED(SPINDLE_FEATURE)    //TG 1/17/20 added this for S0: rpm messages
+         case SP_0: case SP_1:case SP_2: k='S'; break;
+      #endif
       #if HAS_TEMP_BED
         case H_BED: k = 'B'; break;
       #endif
@@ -3975,8 +4084,13 @@ void Temperature::isr() {
       #endif
     }
     SERIAL_CHAR(' ', k);
-    #if HAS_MULTI_HOTEND
-      if (e >= 0) SERIAL_CHAR('0' + e);
+    #if EITHER(HAS_MULTI_HOTEND,SPINDLE_FEATURE) //TG 1/17/20 added the SPINDLE term
+      if (k=='S') {
+        if (e >= 8) SERIAL_CHAR('0' + e-8);   // spindles (8 - 10) come after hotends (0 - 7) 
+      }
+    else {
+        if (e >= 0) SERIAL_CHAR('0' + e);     // heat probe, redundant probe, bed, chamber all have e < 0
+      }
     #endif
     #ifdef SERIAL_FLOAT_PRECISION
       #define SFP _MIN(SERIAL_FLOAT_PRECISION, 2)
@@ -4022,6 +4136,15 @@ void Temperature::isr() {
     #if HAS_MULTI_HOTEND
       HOTEND_LOOP() print_heater_state((heater_id_t)e, degHotend(e), degTargetHotend(e) OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e)));
     #endif
+
+    #if ENABLED(SPINDLE_FEATURE)    //TG 1/17/20 added this to test S0: messages
+      GET_SPINDLES_LOOP() get_spindle_speed(e);
+      GET_SPINDLES_LOOP() print_heater_state((heater_id_t)(e+8),spindle_speed[e].target, spindle_speed[e].actual   // create Sn:t/c mess
+        OPTARG(SHOW_TEMP_ADC_VALUES, rawHotendTemp(e))
+        ); 
+    #endif
+
+
     SERIAL_ECHOPGM(" @:", getHeaterPower((heater_id_t)target_extruder));
     #if HAS_HEATED_BED
       SERIAL_ECHOPGM(" B@:", getHeaterPower(H_BED));
@@ -4041,11 +4164,19 @@ void Temperature::isr() {
     #endif
   }
 
+  //===================================================================================================
+  //TG M155 Autoreport code, it sends the string " B:25.00 /0.00 S0:0.00 /0.00 @:0 B@:0 WCS: -1 VFD: 0"
+  //===================================================================================================
   #if ENABLED(AUTO_REPORT_TEMPERATURES)
     AutoReporter<Temperature::AutoReportTemp> Temperature::auto_reporter;
-    void Temperature::AutoReportTemp::report() {
+    void Temperature::AutoReportTemp::report() 
+    { 
       print_heater_states(active_extruder OPTARG(HAS_TEMP_REDUNDANT, ENABLED(AUTO_REPORT_REDUNDANT)));
-      SERIAL_EOL();
+      #ifdef REPORT_WCS  //TG 10/4/22 appended WCS to AutoReport string
+        serial_echopair_P(" WCS: ", gcode.active_coordinate_system); 
+      #endif
+      //TG 2/28/23 appended VFD connection state to AutoReport string
+      serial_echolnpair_P(" VFD: ", VFDpresent); 
     }
   #endif
 
@@ -4600,6 +4731,7 @@ void Temperature::isr() {
 
       } while (wait_for_heatup && TEMP_COOLER_CONDITIONS);
 
+      // Prevent a wait-forever situation if R is misused i.e. M191 R0
       // If wait_for_heatup is set, temperature was reached, no cancel
       if (wait_for_heatup) {
         wait_for_heatup = false;
@@ -4613,3 +4745,4 @@ void Temperature::isr() {
   #endif // HAS_COOLER
 
 #endif // HAS_TEMP_SENSOR
+#pragma endregion TG - end support functions for reporting temps, autoreporting, wait_for_heating *******************
\ No newline at end of file
diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b7f388cbb6..cd7278f479 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -56,10 +56,26 @@ typedef enum : int8_t {
   H_BOARD = HID_BOARD,
   H_CHAMBER = HID_CHAMBER,
   H_BED = HID_BED,
-  H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,
+  H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7, SP_0,SP_1,SP_2,  //TG 1/17/20 added spindles at end (8,9,10)
   H_NONE = -128
 } heater_id_t;
 
+#if ENABLED(PID_EXTRUSION_SCALING)
+  typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
+#endif
+
+#define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0 & H)) // Always use 'H' to suppress warning
+#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, NAN)
+#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
+#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
+#if ENABLED(PIDTEMP)
+  #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
+  #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
+#else
+  #define _PID_Kc(H) 1
+  #define _PID_Kf(H) 0
+#endif
+
 /**
  * States for ADC reading in the ISR
  */
@@ -144,12 +160,10 @@ enum ADCSensorState : char {
 //
 // PID
 //
-
 typedef struct { float p, i, d; } raw_pid_t;
 typedef struct { float p, i, d, c, f; } raw_pidcf_t;
 
-#if HAS_PID_HEATING
-
+#if EITHER(HAS_PID_HEATING, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(HAS_PID_HEATING), added PIDSPINDLE_USE_PIDTEMPBED
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
@@ -233,7 +247,7 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
 
 #endif
 
-#if ENABLED(PIDTEMP)
+#if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)
 
   /// @brief Extrusion scaled PID class
   template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ>
@@ -454,7 +468,7 @@ struct PIDHeaterInfo : public HeaterInfo {
   typedef heater_info_t hotend_info_t;
 #endif
 #if HAS_HEATED_BED
-  #if ENABLED(PIDTEMPBED)
+  #if EITHER(PIDTEMPBED, PIDSPINDLE_USE_PIDTEMPBED)   //TG 9/21/21 was #if ENABLED(PIDTEMPBED), added PIDSPINDLE_USE_PIDTEMPBED
     typedef struct PIDHeaterInfo<PID_t<MIN_BED_POWER, MAX_BED_POWER>> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
@@ -848,6 +862,32 @@ class Temperature {
       static celsius_float_t analog_to_celsius_redundant(const raw_adc_t raw);
     #endif
 
+    //*******************************************************************************************************
+    //TG 5/25/21 Added this section to support SPINDLE RPM features
+    #if ENABLED(SPINDLE_FEATURE)        //TG 1/17/20 added to test sending S0: messages
+      struct spindle_type
+      {
+        uint16_t target;    //TG changed from uint8_t for RPM 9/21/21
+        uint16_t actual;    // changed from uint8_t for RPM
+      };
+     
+      static spindle_type spindle_speed[SPINDLES];
+      #define SET_SPINDLES_LOOP(I) LOOP_L_N(I, SPINDLES)
+      static void set_spindle_speed(const uint8_t target, const uint16_t speed);
+      static uint16_t get_spindle_speed(const uint8_t target);
+      #if ENABLED(REPORT_SPINDLE_CHANGE)
+        static void report_spindle_speed(const uint8_t target);
+      #endif
+      static constexpr inline uint8_t spindlePercent(const uint8_t speed) { return ui8_to_percent(speed); }
+    #endif // SPINDLE_FEATURE
+     
+    static inline void zero_spindle_speeds() {
+    #if ENABLED(SPINDLE_FEATURE)
+      SET_SPINDLES_LOOP(i) set_spindle_speed(i, 0);
+    #endif
+    }
+   //*******************************************************************************************************  
+
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
@@ -1173,7 +1213,7 @@ class Temperature {
      */
     #if HAS_PID_HEATING
 
-      #if HAS_PID_DEBUG
+      #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
         static bool pid_debug_flag;
       #endif
 
diff --git a/Marlin/src/module/vfd.cpp b/Marlin/src/module/vfd.cpp
new file mode 100644
index 0000000000..4e5c8586d4
--- /dev/null
+++ b/Marlin/src/module/vfd.cpp
@@ -0,0 +1,357 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * 
+ * VFD Controller support via UART3 TX/RX which connects to a TTL-to-RS485 adapter to provide Modbus communication
+ * 
+ * Serial UART routines based on defining and using the LCD_SERIAL_PORT name.
+ * To begin, we need a UART to talk to the VFD and UART3 is the only UART left available on the SGEN board.
+ * 
+ * Stock Marlin defines SERIAL_PORT , SERIAL_PORT_2, and SERIAL_PORT_3 as possibleUART objects.
+ * SERIAL_PORT is the main serial port on the board to use for communication with a host, and is = 0 usually the TFT port.
+ * SERIAL_PORT_2 is a secondary serial port on the board to use for communication with a host and is = -1 the USB port.
+ * SERIAL_PORT_3 is not assigned in stock Marlin, although it could be used for a serial LCD or an MMU device.
+ * 
+ * Each of the above three names(if defined) will get assembled into a MultiSerial object (see serial.h and serial_hook.h)
+ * The MultiSerial object replicates output to all three ports but can selectively mask each one to hide the others, however
+ * all G-Code parsing and output work through this MultiSerial object.
+ * 
+ * For that reason we can't use the identifier SERIAL_PORT_3 for isolated communication to a connected device. We need the
+ * channel to work with that device exclusively, and not in a shared situation (where all G-Code transactions will get mixed
+ * in with device-only intended communication).
+ * 
+ * Instead use the identifier LCD_SERIAL_PORT. It doesn't get included into the MultiSerial object, so it can be isolated
+ * to exclusive communication to/from a connected device).
+ * 
+ * Assigning a port number to LCD_SERIAL_PORT creates MSerial3 (as an instance of the ForwardSerial class) that 
+ * references an instance of MarlinSerial named _MSerial3 using LPC_UART3, which inherits class HardwareSerial
+ * in HardwareSerial.h. Finally an identifier LCD_SERIAL is #defined to be the _MSerial3 object. (whew!)
+ *
+ * T. Gioiosa 12/16/22
+ * updated 2/16/23
+ */
+
+#include "../inc/MarlinConfig.h" // needed for the next line #if ENABLED
+#if ENABLED(VFD_CONTROLLER)			 //TG 12/16/22
+
+#include <src/MarlinCore.h>
+#include "vfd.h"
+#include <src/sd/cardreader.h>
+
+// write/read buffers for Modbus serial
+byte mbCommandMsg[maxCommandMsgSize] = {0};     
+byte mbResponseMsg[maxResponseMsgSize] = {0};   
+byte mbCommandLen = 0;
+byte mbResponseLen = 0;
+
+bool tftPrinting = false;					// this flag is received from TFT to indicate if it is printing from SD
+bool VFDpresent = false;					// this flag is set from MarlinCore call to initialReadVFD() below
+bool statusPollingAllowed = true;	// used to block getVFDStatus if needed
+byte VFD_precision = 0;						// will be either 10 or 100, read at startup
+uint16_t sw_ver;
+uint16_t cpu_ver;
+iregBits inputReg;								// struct containing frequencies, voltages, current, temp, etc.
+uint32_t next_status_time;				// interval that the status function will execute at
+byte VFDstatusbyte;
+
+// This code gets called from the MarliCore.cpp idle() loop. It will only execute every 10 secconds when
+// printing, or every 2 seconds when not printing. It always tests the VFDpresent flag first, if false
+// then try to re-connect. If unsuccessful, just exit till next interval.
+// If VFDpresent flag is true, then VFD status is read into VFDstatusbyte and decoded, followed by reading
+// the VFD input registers and placing that data into inputReg structure. 
+// An M7987 msg with all status data is then sent to the TFT so it can refresh it's data.
+// If at any time the VFDpresent flag goes false, on next entry here we'll try to re-connect(stopping the motor)
+// and will keep trying to re-connect. Once the VFD reconnects, status reading continues. Otherwise no status
+// reading will be done until the VFD is connected, and the status reading will be skipped.
+void getVFDStatus()
+{
+	bool status;		// holds return flag for any Modbus write commands true if write successful, false otherwise
+	static char Msg[96] = {0};		// buffer for sprintf message strings 
+	
+	// do some checking to see if we should run
+	if (!ELAPSED(millis(),next_status_time)) {return;}	// skip and return if not time to run
+	if (statusPollingAllowed == false) {return;}			  // somebody else is using RS485 comm at the moment (this is the only place this flag is tested)
+	
+	// so far ok, now set up for next run interval
+	bool ANY_PRINTING = (card.flag.sdprinting && !card.flag.abort_sd_printing) || tftPrinting;	//TG state of On-board SD/USB printing or TFT SD/USB printing
+	next_status_time = millis() + (ANY_PRINTING ? 10000UL : 2000UL);																//TG 2/16/23 next interval 10s if printing or 2s if idle
+
+	// is the VFD connection status still good?
+	if (VFDpresent == false) {													// if VFD disconnected then
+		initialReadVFD(true);															// try to re-connect, might as well stop motor too in case it kept running after disconnect
+		statusPollingAllowed = true;											// allow us to try here again (if initialReadVFD() failed it sets statusPollingAllowed=false)
+		SERIAL_ECHOPGM(Msg);
+		SERIAL_EOL();
+		if (VFDpresent == false) return;									// leave if still disconnected
+	}
+			
+	// everything is good so let's get the status info.....
+	
+	// request VFD status byte, if successful the response will be in global mbResponseMsg[] array, index 4
+	// VFD responds in 16ms with 7-byte msg (5+2 data) at 7.2ms width
+	status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, VEVOR_PARM_ADDR_BITS, 0x0001);
+	if (status==true)
+	{
+		VFDstatusbyte = mbResponseMsg[4];							// status returns as 2 bytes, msb[3] & lsb[4], we want lsb
+	}
+	else {VFDpresent=false;}							// if the VFD has stopped responding change status to not present
+
+	statusPollingAllowed = false; 				// prevent infinite loop, otherwise idle() will call back here recursively
+	idle();																// allow background hardware tasks to run (prevents comm pile-up)
+	statusPollingAllowed = true;
+
+	// now read the Input Register Area for various operating parameters, adjust for decimal point where needed
+	// request 4 registers starting at Read Holding Register 0220H for Input Registers 0000H-0003FH (freq_out, freq_set, current_out, speed_out)
+	// VFD responds in 16ms with 13-byte msg (5+8 data) at 13.4ms width
+	status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, VEVOR_INPUT_REG_BITS, 0x0004);
+	if (status==true)
+	{
+		inputReg.freq_out = (mbResponseMsg[3]<<8) + mbResponseMsg[4];
+		inputReg.freq_set = (mbResponseMsg[5]<<8) + mbResponseMsg[6];
+		inputReg.current_out = (mbResponseMsg[7]<<8) + mbResponseMsg[8];
+		inputReg.speed_out = (mbResponseMsg[9]<<8) + mbResponseMsg[10];	
+	}
+	else {VFDpresent=false;}							// if the VFD has stopped responding change status to not present
+	
+	statusPollingAllowed = false; 				// prevent infinite loop, otherwise idle() will call back here recursively
+	idle();																// allow background hardware tasks to run (prevents comm pile-up)
+	statusPollingAllowed = true;
+
+	// request 3 registers starting at Read Holding Register 0224H for Input Registers 0004H-0006FH (dc_voltage, ac_voltage, temperature)
+	// VFD responds in 16ms with 11-byte msg (5+6 data) at 11.2ms width
+	status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, VEVOR_INPUT_REG_BITS+4, 0x0003);
+	if (status==true)
+	{
+		inputReg.dc_voltage = (mbResponseMsg[3]<<8) + mbResponseMsg[4];
+		inputReg.ac_voltage = (mbResponseMsg[5]<<8) + mbResponseMsg[6];
+		inputReg.temperature = (mbResponseMsg[7]<<8) + mbResponseMsg[8];
+	}
+	else {VFDpresent=false;}							// if the VFD has stopped responding change status to not present
+
+	statusPollingAllowed = false; 				// prevent infinite loop, otherwise idle() will call back here recursively
+	idle();																// allow background hardware tasks to run (prevents comm pile-up)
+	statusPollingAllowed = true;
+
+	// request 2 registers starting at Read Holding Register 022AH for Input Registers 000AH-000BFH (fault_code, total_hours)
+	// VFD responds in 16ms with 9-byte msg (5+4 data) at 9.2ms width
+	status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, VEVOR_INPUT_REG_BITS+10, 0x0002);
+	if (status==true)
+	{
+		inputReg.fault_code = (mbResponseMsg[3]<<8) + mbResponseMsg[4];
+		inputReg.total_hours = (mbResponseMsg[5]<<8) + mbResponseMsg[6];
+	}
+	else {VFDpresent=false;}							// if the VFD has stopped responding change status to not present
+	
+	statusPollingAllowed = false; 				// prevent infinite loop, otherwise idle() will call back here recursively
+	idle();																// allow background hardware tasks to run  (prevents comm pile-up)
+	statusPollingAllowed = true;
+
+	// finally send the latest VFD registers and status to TFT
+  sprintf(Msg,"M7987 OF%d SF%d OC%d OR%d DC%d AC%u TP%d LF%d RH%d ST%d DP%d\n", 
+          inputReg.freq_out, inputReg.freq_set, inputReg.current_out, inputReg.speed_out,
+          inputReg.dc_voltage, inputReg.ac_voltage,inputReg.temperature, inputReg.fault_code,
+          inputReg.total_hours, VFDstatusbyte, VFD_precision);
+  
+	PORT_REDIRECT(SERIAL_PORTMASK(SERIAL_PORT));    // ensure we send to the TFT (in case source was not the TFT)
+  //PORT_REDIRECT(SerialMask::All);								// for testing output with Pronterface or Repetier send to all serial ports
+	SERIAL_ECHOPGM(Msg);
+	PORT_RESTORE();																	// sets port redirection back to previous value 
+}
+
+// Read initial state of VFD and optionally stop the motor if stopMotor=true
+// this gets called by from MarlinCore.cpp idle(), it accomplishes these tasks:
+// 1. stops the VFD motor if possible and if stopMotor parm = true
+// 2. tries to read VFD's decimal precision setting so we know what factor to apply when reading VFD input registers
+// 3. read the VFD software version
+// 4. read the VFD motor CPU version
+// all steps must be successful for the VFDpresent flag to be set true (and statusPollingAllowed also), if any one
+// step fails(except the first motor Stop attempt), the rest are skipped and the VFDpresent flag is set to
+// false (the statusPollingAllowed flag also stays false).
+// The resulting VFDpresent flag gets sent to the TFT automatically at Temperature::AutoReportTemp::report()
+// it is appended to the line sent by Marlin M155 Autoreport interval.
+void initialReadVFD(bool stopMotor)
+{
+	bool status = true;							// start with true in case we skip motor stop code
+	statusPollingAllowed = false; 	// don't allow interference from periodic status polling
+  static char Msg[18] = {0};			// buffer for sprintf message strings 
+
+	if(stopMotor)
+	{
+		// make sure first thing done is try to stop the motor in case it's running 
+  	status = writeVevorVFD(VFDnum, MODBUS_WRITE_FUNC_REG, VEVOR_MAIN_CONTROL_BITS, sRUN_STOP);
+		// if first attempt failed, try one more time
+		if(status==false)
+		  status = writeVevorVFD(VFDnum, MODBUS_WRITE_FUNC_REG, VEVOR_MAIN_CONTROL_BITS, sRUN_STOP);
+	}
+	
+	// try to read the VFD's decimal precision setting, mbResponseMsg[4] holds the return data
+	if (status==true)
+		status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, 169, 0x0001);
+	if (status==true)
+		VFD_precision = (mbResponseMsg[4] + 1) * 10;	// 10 if mbResponseMsg[4] = 0, or 100 if mbResponseMsg[4] = 1
+	else
+		VFD_precision = 10;														// if an error occurred set default at 10
+	
+	// read the VFD software version
+	if (status==true)
+		status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, 181, 0x0001);
+	if (status==true)
+		sw_ver = mbResponseMsg[4];
+	
+  // read the VFD motor CPU version  
+	if (status==true)
+	  status = writeVevorVFD(VFDnum, MODBUS_READ_HOLD_REG, 189, 0x0001);
+	
+	if (status==true)
+	{	
+		cpu_ver = mbResponseMsg[4];
+		VFDpresent = true;														// made it through all the status checks, VFD is connected
+		statusPollingAllowed = true;									// VFD is connected, OK to allow status polling now
+	}
+	else
+		VFDpresent = false;														// set flag if no VFD responded
+			
+	PORT_REDIRECT(SERIAL_PORTMASK(SERIAL_PORT));  	// ensure we send to the TFT (in case source was not the TFT)
+	sprintf(Msg,"M7987 OF0 DP%d\n",VFD_precision);
+	SERIAL_ECHOPGM(Msg);														// setting DP to 255 flags VFD no-response to TFT
+	PORT_RESTORE(); 
+	    
+}
+
+/* Serial port routines begin here, we communicate to VFD via serial port connected to RS485 converter to VFD */
+#ifdef LCD_SERIAL_PORT  //TG 12/16/22
+
+// read bytes of length len into buffer at *data, if len=0 nothing will be done and just returns zero
+uint8_t Serial_readNbytes(uint8_t* data, int len){
+	uint8_t i;
+	for( i=0; i < (len-1); i++)	{data[i]= 0;}				// clear buffer first
+	
+	while ((len > 0) & (LCD_SERIAL.available()>0))	// till len bytes or no more available			
+	{
+		*data = LCD_SERIAL.read();										// read bytes into buffer
+		++data;
+		--len;				
+	}
+
+	if (len > 0) 					// if len > 0, there weren't enough bytes available to read
+		return  len;				// return #bytes that were not read
+	else 									// return success (0) if all bytes sent
+		return 0;
+}
+
+// format the supplied variables into a Modbus message for the Vevor VFD, and store it in
+// a global array with a calulated CRC as the last two bytes of the array. Then call to
+// LCD_SERIAL.write with the address of the array and the size in bytes.
+// Return true if ok, false if error 
+bool writeVevorVFD(byte dev_addr, const byte func, uint16_t param_addr, uint16_t data)
+{
+	byte i,j;
+	// clear arrays
+	for (i=0; i<maxCommandMsgSize;i++) {mbCommandMsg[i] = 0;}
+	for (i=0; i<maxResponseMsgSize;i++) {mbResponseMsg[i] = 0;}
+	
+	// start by calculating size of byte array we'll need for the message, then create a dynamic array of that size
+	mbCommandLen = 2 + sizeof(param_addr) + sizeof(data) + 2;		// address, cmd bytes(2) + parm + data + crc bytes(2), put in global var
+
+	// fill the array with everything but the CRC bytes (dynamic array should be accessed by index not as a pointer)
+	mbCommandMsg[0] = dev_addr;    					
+	mbCommandMsg[1] = func;
+	mbCommandMsg[2] = (param_addr & 0xFF00)>>8;
+	mbCommandMsg[3] = param_addr & 0xFF;
+	mbCommandMsg[4] = (data & 0xFF00)>>8;
+	mbCommandMsg[5] = data & 0xFF;
+		
+	// next, calculate the 16-bit CRC for the above bytes and add them as last two bytes of the array
+	uint16_t crc  = 0xFFFF;
+	byte crclen = mbCommandLen - 2;							// create the CRC, but don't count the 2 bytes for the CRC
+	i=j=0;
+	while(crclen--)
+	{  
+	  crc = crc ^ mbCommandMsg[i++];
+    for(j=0; j<8; j++)
+    {
+    if (crc & 1)
+      crc = (crc >> 1) ^ 0xA001;
+    else
+      crc >>= 1;
+		}
+	}
+	mbCommandMsg[i++] = crc & 0xFF;							// put CRC lsbyte in dest at totalLen - 2
+  mbCommandMsg[i]   = (crc & 0xFF00) >> 8;		// put CRC msbyte in dest at totalLen - 1	
+	
+  
+	// next, write completed mbCommandMsg[] to the serial port and wait till TX buffer is empty
+		_delay_ms(50);	 // VFD protocol needs about 50ms space between commands
+		
+	WRITE(P2_12,1);    //TG - ***** for scope measurement normally commented out
+	LCD_SERIAL.write((char*)&mbCommandMsg[0], (size_t)mbCommandLen);
+  while(LCD_SERIAL.TXbufferEmpty()==1){;}			// 1=TX busy  0=TX empty
+	WRITE(P2_12,0);
+	
+	// the Vevor VFD takes about 16ms to respond at 9600baud
+	uint32_t timeout = millis() + 20UL;					// 16ms + 25% timeout for no response
+	mbResponseLen = 0;
+	// wait until first byte is received or timeout occurs
+	while(mbResponseLen==0 && !ELAPSED(millis(),timeout)) {mbResponseLen = LCD_SERIAL.available();}
+	
+	// got first byte so allow for longest expected response to be received into serial buffer
+	_delay_ms(16);	// largest response message should be 13 bytes or 13.5ms, add 25%																					
+	
+	// read the received bytes into global mbResponseMsg[], caller can inspect it, but also return status boolean if error
+	mbResponseLen = LCD_SERIAL.available();								// get response length
+	Serial_readNbytes(&mbResponseMsg[0], mbResponseLen);	// read that number of bytes (or zero) into global buffer
+  if (mbResponseMsg[1] & 0x80 || mbResponseMsg[1]==0)		// check for error flag (bit7 set), or first byte null (timeout)
+	{
+		WRITE(P4_28,0);    //TG - ***** for scope measurement normally commented out
+    asm("nop");
+		asm("nop");
+		return false;
+	}
+	else
+	{
+		WRITE(P4_28,1);
+	  return true;
+	  
+	}
+}	
+
+
+// takes an input source array ptr, a dest array ptr, and the src array size and forms a
+// Modbus message into dest array. The array will contain ADDR, SRC BYTES, and calculated CRC 
+uint16_t createModbusMsg(byte *dest, byte cmd, uint16_t parm, uint16_t data)
+{
+	uint16_t crc  = 0xFFFF;
+	byte j;
+  
+	byte totalLen = 2 + sizeof(parm) + sizeof(data) + 2;		// address, cmd bytes (2) + parm + data + crc bytes(2)
+	byte *destcopy = dest;					// copy start of dest for later cause we manipulate it
+
+	*dest++ = VFDnum;    						// put the address byte
+	*dest++ = cmd;
+	*dest++ = (parm & 0xFF00)>>8;
+	*dest++ = parm & 0xFF;
+	*dest++ = (data & 0xFF00)>>8;
+	*dest++ = data & 0xFF;
+		
+	dest = destcopy;								// reset dest ptr back to first element
+	totalLen -= 2;									// create the CRC, but don't count the 2 bytes for the CRC
+	while(totalLen--)
+	{  
+	  crc = crc ^ *dest++;
+    for(j=0; j<8; j++)
+    {
+    if (crc & 1)
+      crc = (crc >> 1) ^ 0xA001;
+    else
+      crc >>= 1;
+		}
+	}
+	*dest++ = crc & 0xFF;						// put CRC lsbyte in dest at totalLen - 2
+  *dest   = (crc & 0xFF00) >> 8;	// put CRC msbyte in dest at totalLen - 1	
+	return crc;
+}	
+
+#endif // #ifdef LCD_SERIAL_PORT
+#endif // #if ENABLED(VFD_CONTROLLER)
+
+
+
+
diff --git a/Marlin/src/module/vfd.h b/Marlin/src/module/vfd.h
new file mode 100644
index 0000000000..94d2b624bf
--- /dev/null
+++ b/Marlin/src/module/vfd.h
@@ -0,0 +1,118 @@
+/** //TG MODIFIED BY T.GIOIOSA
+ * Serial UART routines based on LCD_SERIAL_PORT
+ * T. Gioiosa 1216/22
+ * 
+ */
+
+//#pragma once
+#ifndef _VFD_H_
+#define _VFD_H_
+
+#include <src/MarlinCore.h>
+#if ENABLED(VFD_CONTROLLER)  //TG 12/16/22
+
+#include <stdint.h>
+#define maxCommandMsgSize 8
+#define maxResponseMsgSize 16
+//TG note that for the following to have a SINGLE INSTANCE shared by all .cpp files that include vfd.h,
+//they must be declared 'extern' here and defined in one .cpp file (vfd.cpp in this case).
+//If they were declared and defined here as 'static byte mbCommandMsg[]', etc. then every .cpp file
+//would get it's OWN COPY and thus it's not really shared properly. 
+extern byte mbCommandMsg[maxCommandMsgSize];              // global array for writing Modbus msg
+extern byte mbResponseMsg[maxResponseMsgSize];            // global array for receiving response msg
+extern byte mbCommandLen;
+extern byte mbResponseLen;
+
+const byte VFDnum = 0x01;                       // specify Modbus address of the VFD
+extern byte VFD_precision;                      // decimal precision of communication for VFD (tenths or hundredths)
+extern byte VFDstatusbyte;                      // holds the 8 status bits from VFD operation
+extern uint16_t sw_ver;
+extern uint16_t cpu_ver;
+extern bool VFDpresent;                         // this flag is set from MarlinCore call to initialReadVFD() below
+extern bool statusPollingAllowed;               // used to block getVFDStatus if needed
+
+
+const byte MODBUS_READ_HOLD_REG = 0x03;         // Modbus functions
+const byte MODBUS_READ_INPUT_REG = 0x04;
+const byte MODBUS_WRITE_FUNC_REG = 0x06;
+
+const byte sRUN_FWD = 0x03;                     // VFD control bits
+const byte sRUN_REV = 0x05;
+const byte sRUN_STOP = 0x08;
+
+typedef struct 
+{
+  uint16_t  freq_out;
+  uint16_t  freq_set;
+  uint16_t  current_out;
+  uint16_t  speed_out;
+  uint16_t  dc_voltage;
+  uint16_t  ac_voltage;
+  uint16_t  temperature;
+  uint16_t  counter;
+  uint16_t  PID_target;
+  uint16_t  PID_feedback;
+  uint16_t  fault_code;
+  uint16_t  total_hours;
+}iregBits;
+extern iregBits inputReg;
+
+// some Holding Register definitions for the Vevor VFD (these locations can be read/write anytime, they are not cycle limited EEPROM)
+const uint16_t VEVOR_MAIN_CONTROL_BITS    = 0x0200;   // BIT0-BIT7 mapping parameter address 0048Hï½ž004FH (Write only, use 0x210 to read)
+                                                      // 0048 Operation 0000â€”Invalid FF00ï¼ˆor 100ï¼Œbit8 = 1ï¼‰ï¼Valid
+                                                      // 0049 Forward 0000â€”Invalid FF00ï¼Valid
+                                                      // 004A Reverse 0000â€”Invalid FF00ï¼Valid
+                                                      // 004B Stop 0000â€”Invalid FF00ï¼Valid
+                                                      // 004C Forward/reverse switch 0000â€”Invalid FF00ï¼Valid
+                                                      // 004D JOG 0000â€”Invalid FF00ï¼Valid
+                                                      // 004E JOG Forward 0000â€”Invalid FF00ï¼Valid
+                                                      // 004F JOG Reverse 0000â€”Invalid FF00ï¼Valid
+
+const uint16_t VEVOR_FREQUENCY            = 0x0201;   // set frequency desired
+
+const uint16_t VEVOR_PARM_ADDR_BITS       = 0x0210;   // param register mapping 0000H ~ 000FH (read only, use 0x200 to write)
+                                                      // 0000 Operation 0â€“Stop 1â€“Operating
+                                                      // 0001 JOG 0â€“Invalid 1â€“JOG
+                                                      // 0002 Forward/reverse 0â€“Forward 1â€“Reverse
+                                                      // 0003 In operation 0â€“Stop 1â€“In operation
+                                                      // 0004 In jogging 0â€“Invalid 1â€“In jogging
+                                                      // 0005 In forward/reverse rotation 0â€“In forward rotation 1â€“In reverse rotation
+                                                      // 0006 In braking  0â€“Invalid 1â€“In braking
+                                                      // 0007 Frequency tracking  0â€“Invalid 1â€“Frequency
+
+const uint16_t VEVOR_INPUT_REG_BITS       = 0x0220;   // input register mapping 0000H ~ 000FH 
+                                                      // 0x0220+0000 Output frequency
+                                                      // 0x0220+0001 Set frequency
+                                                      // 0x0220+0002 Output current
+                                                      // 0x0220+0003 Output speed
+                                                      // 0x0220+0004 DC voltage
+                                                      // 0x0220+0005 AC voltage
+                                                      // 0x0220+0006 temperature
+                                                      // 0x0220+0007 Counter 
+                                                      // 0x0220+0008 PID target value
+                                                      // 0x0220+0009 PID feedback value
+                                                      // 0x0220+000A Current fault 
+                                                      // 0x0220+000B Total operating hours
+
+// table of arrays containing the various commands for VFD, the last two bytes have to be filled in with CRC
+const byte spindle_send_runfwd[] = {0x06, 0x02, 0x00, 0x00, 0x03};					// WriteSingleFuncReg 0x200 data=0x03
+const byte spindle_send_runrev[] = {0x06, 0x02, 0x00, 0x00, 0x05};					// WriteSingleFuncReg 0x200 data=0x05
+const byte spindle_send_stop[] = {0x06, 0x02, 0x00, 0x00, 0x08 };						// WriteSingleFuncReg 0x200 data=0x08
+const byte spindle_send_speed[] = {0x06, 0x02, 0x01, 0x00, 0x00};						// WriteSingleFuncReg 0x201 data=sH,sL
+const byte spindle_read_serial[] = {0x03, 0x00, 181, 0x00, 0x01};						// ReadHoldingRegister F181 1byte
+const byte spindle_read_status[] = {0x03, 0x02, 0x10, 0x00, 0x01};					// ReadHoldingRegister 0x210 Main ctl bits 0-7
+const byte spindle_read_fo_fi_cur_spd[] = {0x03, 0x02, 0x20, 0x00, 0x04};		// ReadHoldingRegister 0x220 4bytes
+const byte spindle_read_dc_ac_temp[] = {0x03, 0x02, 0x24, 0x00, 0x03};			// ReadHoldingRegister 0x224 3bytes
+const byte spindle_read_fault_hours[] = {0x03, 0x02, 0x2A, 0x00, 0x02};			// ReadHoldingRegister 0x22A 2bytes
+
+
+extern bool tftPrinting;
+uint8_t Serial_readNbytes( uint8_t* data, int len);
+uint16_t createModbusMsg(byte* dest, byte cmd, uint16_t parm, uint16_t data);
+bool writeVevorVFD(byte dev_addr, const byte func, uint16_t param_addr, uint16_t data);
+void getVFDStatus();
+void initialReadVFD(bool stopMotor);
+
+#endif // #ifndef _VFD_H_
+
+#endif // #if ENABLED(VFD_CONTROLLER)
\ No newline at end of file
diff --git a/Marlin/src/pins/lpc1768/pins_MKS_SBASE.h b/Marlin/src/pins/lpc1768/pins_MKS_SBASE.h
index cf12a98aef..b5a989812e 100644
--- a/Marlin/src/pins/lpc1768/pins_MKS_SBASE.h
+++ b/Marlin/src/pins/lpc1768/pins_MKS_SBASE.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -34,18 +34,18 @@
   #define BOARD_WEBSITE_URL "github.com/makerbase-mks/MKS-SBASE"
 #endif
 
-#define LED_PIN                            P1_18  // Used as a status indicator
-#define LED2_PIN                           P1_19
-#define LED3_PIN                           P1_20
-#define LED4_PIN                           P1_21
+#define LED_PIN                            P1_18  // D1 Used as a status indicator
+#define LED2_PIN                           P1_19  // D2
+#define LED3_PIN                           P1_20  // D3
+#define LED4_PIN                           P1_21  // D4
 
 //
 // Servos
 //
-#define SERVO0_PIN                         P1_23  // J8-3 (low jitter)
-#define SERVO1_PIN                         P2_12  // J8-4
-#define SERVO2_PIN                         P2_11  // J8-5
-#define SERVO3_PIN                         P4_28  // J8-6
+#define SERVO0_PIN                         P1_23  // J8-3 (low jitter) PWM1[4]
+#define SERVO1_PIN                         P2_12  // J8-4 not PWM
+#define SERVO2_PIN                         P2_11  // J8-5 not PWM
+#define SERVO3_PIN                         P4_28  // J8-6 not PWM
 
 //
 // Limit Switches - Not Interrupt Capable
@@ -340,8 +340,10 @@
 #endif
 
 // UNUSED
-//#define PIN_P0_02                        P0_02  // AUX1 (Interrupt Capable/ADC/Serial Port 0)
-//#define PIN_P0_03                        P0_03  // AUX1 (Interrupt Capable/ADC/Serial Port 0)
+#define PIN_P0_27                          P0_27  // EXP2/Onboard SD
+#define PIN_P0_28                          P0_28  // EXP2
+#define PIN_P0_02                        P0_02  // AUX1 (Interrupt Capable/ADC/Serial Port 0)
+#define PIN_P0_03                        P0_03  // AUX1 (Interrupt Capable/ADC/Serial Port 0)
 
 /**
  *  PWMs
diff --git a/Marlin/src/pins/lpc1769/pins_MKS_SGEN.h b/Marlin/src/pins/lpc1769/pins_MKS_SGEN.h
index 23bcecc78d..3b9b4a5d71 100644
--- a/Marlin/src/pins/lpc1769/pins_MKS_SGEN.h
+++ b/Marlin/src/pins/lpc1769/pins_MKS_SGEN.h
@@ -1,4 +1,4 @@
-/**
+/** //TG MODIFIED BY T.GIOIOSA
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -56,3 +56,37 @@
   // Reduce baud rate to improve software serial reliability
   #define TMC_BAUD_RATE                    19200
 #endif
+
+//TG 1/21/20 added this for case light
+#if ENABLED(CASE_LIGHT_ENABLE) && !defined(CASE_LIGHT_PIN) && !defined(SPINDLE_LASER_ENA_PIN)
+  #if !HAS_HEATED_BED                             
+    #define CASE_LIGHT_PIN                  P2_05  // no BED, can use BED PWM as on/off
+  #elif EXTRUDERS<=1
+    #define CASE_LIGHT_PIN                  P2_06  // no extruders, can use HTR2 output
+  #elif !HAS_TMC_UART                             // Use J8 if possible
+    #define CASE_LIGHT_PIN				   P1_22  // Pullup or pulldown!
+  #endif
+#endif
+
+//TG 1/21/20 added this for Spindle/Laser
+// M3/M4/M5 - Spindle/Laser Control
+// IF 
+#if HAS_CUTTER && !defined(SPINDLE_LASER_ENA_PIN)
+  #if !HAS_HEATED_BED && EXTRUDERS==0 && SPINDLE_LASER_USE_FAN_HEATER_PINS 
+     #undef FAN_PIN 
+     #define SPINDLE_LASER_PWM_PIN			   P2_04  // no extruders, can use FAN PWM output
+	   #undef HEATER_1_PIN
+     #define SPINDLE_LASER_ENA_PIN         P2_06  // no extruders, can use HTR2 output
+	   #undef HEATER_0_PIN
+     #define SPINDLE_DIR_PIN               P2_07  // no extruders, can use HTR1 output
+     #undef HEATER_BED_PIN
+     #define VACUUM_ENA_PIN				         P2_05  // no BED, can use BED PWM as on/off
+  #elif !defined(HAS_TMC_UART)                    // Use J8 if possible only when no TMC_UART drivers in use
+    #define SPINDLE_LASER_ENA_PIN          P2_11  // Pullup or pulldown!
+    #define SPINDLE_LASER_PWM_PIN          P1_23  // Hardware PWM has a conflict with SDSS pin
+    #define SPINDLE_DIR_PIN                P2_12  // Pullup or pulldown!
+    #define VACUUM_ENA_PIN			           P1_22  // Pullup or pulldown!
+  #else
+    #error "No auto-assignable Spindle/Laser pins available."
+  #endif
+#endif
\ No newline at end of file
diff --git a/Marlin/src/pins/lpc1769/pins_TH3D_EZBOARD.h b/Marlin/src/pins/lpc1769/pins_TH3D_EZBOARD.h
index 12a7934a3e..f794e178f9 100644
--- a/Marlin/src/pins/lpc1769/pins_TH3D_EZBOARD.h
+++ b/Marlin/src/pins/lpc1769/pins_TH3D_EZBOARD.h
@@ -131,6 +131,12 @@
 #ifndef E0_AUTO_FAN_PIN
   #define E0_AUTO_FAN_PIN           AUTO_FAN_PIN
 #endif
+#ifndef E1_AUTO_FAN_PIN
+  #define E1_AUTO_FAN_PIN           AUTO_FAN_PIN
+#endif
+#ifndef E2_AUTO_FAN_PIN
+  #define E2_AUTO_FAN_PIN           AUTO_FAN_PIN
+#endif
 
 //
 // SD Card
diff --git a/Marlin/src/pins/pinsDebug_list.h b/Marlin/src/pins/pinsDebug_list.h
index 39e07c739a..c4bf23b7dd 100644
--- a/Marlin/src/pins/pinsDebug_list.h
+++ b/Marlin/src/pins/pinsDebug_list.h
@@ -1,4 +1,4 @@
-/**
+/**  //TG MODIFIED *****
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
@@ -1248,6 +1248,11 @@
 #if PIN_EXISTS(SPINDLE_LASER_PWM)
   REPORT_NAME_DIGITAL(__LINE__, SPINDLE_LASER_PWM_PIN)
 #endif
+//TG 6/27/21 added this to list of assigned pins
+#if PIN_EXISTS(VACUUM_ENA)
+  REPORT_NAME_DIGITAL(__LINE__, VACUUM_ENA_PIN)
+#endif
+//TG 6/27/21 end of addition
 
 #if PIN_EXISTS(SR_CLK)
   REPORT_NAME_DIGITAL(__LINE__, SR_CLK_PIN)
diff --git a/Marlin/src/pins/stm32f4/pins_INDEX_REV03.h b/Marlin/src/pins/stm32f4/pins_INDEX_REV03.h
new file mode 100644
index 0000000000..a9828c5bda
--- /dev/null
+++ b/Marlin/src/pins/stm32f4/pins_INDEX_REV03.h
@@ -0,0 +1,162 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * STM32F407VET6 on Index PnP Mobo Rev03
+ * Website - https://indexmachines.io/
+ */
+
+#define ALLOW_STM32DUINO
+#include "env_validate.h"
+
+#define BOARD_INFO_NAME      "Index Mobo Rev03"
+#define DEFAULT_MACHINE_NAME "Index Pick and Place"
+
+/**
+ * By default, the extra stepper motor configuration is:
+ * I = Left Head
+ * J = Right Head
+ * K = Auxiliary (Conveyor belt)
+ */
+
+#define SRAM_EEPROM_EMULATION
+#define MARLIN_EEPROM_SIZE                0x2000  // 8KB
+
+// I2C MCP3426 (16-Bit, 240SPS, dual-channel ADC)
+#define HAS_MCP3426_ADC
+
+//
+// Servos
+//
+#define SERVO0_PIN                          PB10
+#define SERVO1_PIN                          PB11
+
+//
+// Limit Switches
+//
+#define X_STOP_PIN                          PC6
+#define Y_STOP_PIN                          PD15
+#define Z_STOP_PIN                          PD14
+
+// None of these require limit switches by default, so we leave these commented
+// here for your reference.
+// #define I_MIN_PIN                           PA8
+// #define I_MAX_PIN                           PA8
+// #define J_MIN_PIN                           PD13
+// #define J_MAX_PIN                           PD13
+// #define K_MIN_PIN                           PC9
+// #define K_MAX_PIN                           PC9
+
+//
+// Steppers
+//
+#define X_STEP_PIN                          PB15
+#define X_DIR_PIN                           PB14
+#define X_ENABLE_PIN                        PD9
+#define X_SERIAL_TX_PIN                     PD8
+#define X_SERIAL_RX_PIN                     PD8
+
+#define Y_STEP_PIN                          PE15
+#define Y_DIR_PIN                           PE14
+#define Y_ENABLE_PIN                        PB13
+#define Y_SERIAL_TX_PIN                     PB12
+#define Y_SERIAL_RX_PIN                     PB12
+
+#define Z_STEP_PIN                          PE7
+#define Z_DIR_PIN                           PB1
+#define Z_ENABLE_PIN                        PE9
+#define Z_SERIAL_TX_PIN                     PE8
+#define Z_SERIAL_RX_PIN                     PE8
+
+#define I_STEP_PIN                          PC4
+#define I_DIR_PIN                           PA4
+#define I_ENABLE_PIN                        PB0
+#define I_SERIAL_TX_PIN                     PC5
+#define I_SERIAL_RX_PIN                     PC5
+
+#define J_STEP_PIN                          PE11
+#define J_DIR_PIN                           PE10
+#define J_ENABLE_PIN                        PE13
+#define J_SERIAL_TX_PIN                     PE12
+#define J_SERIAL_RX_PIN                     PE12
+#define K_SERIAL_TX_PIN                     PA2
+#define K_SERIAL_RX_PIN                     PA2
+
+#define K_STEP_PIN                          PD6
+#define K_DIR_PIN                           PD7
+#define K_ENABLE_PIN                        PA3
+
+// Reduce baud rate to improve software serial reliability
+#define TMC_BAUD_RATE                      19200
+
+// Not required for this board. Fails to compile otherwise.
+// PD0 is not connected on this board.
+#define TEMP_0_PIN                          PD0
+
+// General use mosfets, useful for things like pumps and solenoids
+#define FAN_PIN                             PE2
+#define FAN1_PIN                            PE3
+#define FAN2_PIN                            PE4
+#define FAN3_PIN                            PE5
+
+#define FAN_SOFT_PWM_REQUIRED
+
+// Neopixel Rings
+#define NEOPIXEL_PIN                        PC7
+#define NEOPIXEL2_PIN                       PC8
+
+// SPI
+#define MISO_PIN                            PB4
+#define MOSI_PIN                            PB5
+#define SCK_PIN                             PB3
+
+// I2C
+#define I2C_SDA_PIN                         PB7
+#define I2C_SCL_PIN                         PB6
+
+/**
+ * The index mobo rev03 has 3 aux ports. We define them here so they may be used
+ * in other places and to make sure someone doesn't have to go look up the pinout
+ * in the board files. Each 12 pin aux port has this pinout:
+ *
+ * VDC    1   2    GND
+ * 3.3V   3   4    SCL  (I2C_SCL_PIN)
+ * PWM1   5   6    SDA  (I2C_SDA_PIN)
+ * PWM2   7   8    CIPO (MISO_PIN)
+ * A1     9  10    COPI (MOSI_PIN)
+ * A2     11 12    SCK  (SCK_PIN)
+ */
+#define INDEX_AUX1_PWM1                     PA15
+#define INDEX_AUX1_PWM2                     PA5
+#define INDEX_AUX1_A1                       PC0
+#define INDEX_AUX1_A2                       PC1
+
+#define INDEX_AUX2_PWM1                     PA6
+#define INDEX_AUX2_PWM2                     PA7
+#define INDEX_AUX2_A1                       PC2
+#define INDEX_AUX2_A2                       PC3
+
+#define INDEX_AUX3_PWM1                     PB8
+#define INDEX_AUX3_PWM2                     PB9
+#define INDEX_AUX3_A1                       PA0
+#define INDEX_AUX3_A2                       PA1
diff --git a/Marlin/src/pins/stm32f4/pins_MKS_MONSTER8.h b/Marlin/src/pins/stm32f4/pins_MKS_MONSTER8.h
new file mode 100644
index 0000000000..0e960a17e2
--- /dev/null
+++ b/Marlin/src/pins/stm32f4/pins_MKS_MONSTER8.h
@@ -0,0 +1,390 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#define ALLOW_STM32DUINO
+#include "env_validate.h"
+
+#if HOTENDS > 3 || E_STEPPERS > 5
+  #error "MKS Monster supports up to 3 hotends and 5 E-steppers."
+#elif HAS_FSMC_TFT
+  #error "MKS Monster doesn't support FSMC-based TFT displays."
+#endif
+
+#define BOARD_INFO_NAME "MKS Monster8 V1.x"
+
+#define HAS_OTG_USB_HOST_SUPPORT                  // USB Flash Drive support
+#define USES_DIAG_JUMPERS
+
+//#define DISABLE_DEBUG
+
+// Avoid conflict with TIMER_TONE
+#define STEP_TIMER 10
+
+// Use one of these or SDCard-based Emulation will be used
+//#define SRAM_EEPROM_EMULATION                   // Use BackSRAM-based EEPROM emulation
+//#define FLASH_EEPROM_EMULATION                  // Use Flash-based EEPROM emulation
+#define I2C_EEPROM                                // Need use jumpers set i2c for EEPROM
+#define MARLIN_EEPROM_SIZE                0x1000  // 4KB
+#define I2C_SCL_PIN                         PB8   // I2C_SCL and CAN_RX
+#define I2C_SDA_PIN                         PB9   // I2C_SDA and CAN_TX
+
+//
+// Servos
+//
+#define SERVO0_PIN                          PA8   // Enable BLTOUCH
+
+//
+// Limit Switches for diag signal
+//
+#define X_DIAG_PIN                          PA14  // Driver0 diag signal is connect to X-
+#define Y_DIAG_PIN                          PA15  // Driver1 diag signal is connect to Y-
+#define Z_DIAG_PIN                          PB13  // Driver2 diag signal is connect to Z-
+#define E0_DIAG_PIN                         PA13  // Driver3 diag signal is connect to X+
+#define E1_DIAG_PIN                         PC5   // Driver4 diag signal is connect to Y+
+#define E2_DIAG_PIN                         PB12  // Driver5 diag signal is connect to Z+
+#define E3_DIAG_PIN                         -1    // Driver6 diag signal is not connect
+#define E4_DIAG_PIN                         -1    // Driver7 diag signal is not connect
+
+// Limit Switches for endstop
+#define X_MIN_PIN                           PA14
+#define X_MAX_PIN                           PA13
+#define Y_MIN_PIN                           PA15
+#define Y_MAX_PIN                           PC5
+#define Z_MIN_PIN                           PB13
+#define Z_MAX_PIN                           PB12
+
+//
+// Steppers
+// Driver 0  1  2  3  4  5  6  7
+// For    X  Y  Z  E0 E1 E2 E3 E4(default pin settings)
+//
+//Driver0
+#define X_ENABLE_PIN                        PC15
+#define X_STEP_PIN                          PC14
+#define X_DIR_PIN                           PC13
+#ifndef X_CS_PIN
+  #define X_CS_PIN                          PE6
+#endif
+//Driver1
+#define Y_ENABLE_PIN                        PC15
+#define Y_STEP_PIN                          PE5
+#define Y_DIR_PIN                           PE4
+#ifndef Y_CS_PIN
+  #define Y_CS_PIN                          PE3
+#endif
+//Driver2
+#define Z_ENABLE_PIN                        PE2
+#define Z_STEP_PIN                          PE1
+#define Z_DIR_PIN                           PE0
+#ifndef Z_CS_PIN
+  #define Z_CS_PIN                          PB7
+#endif
+//Driver3
+#define E0_ENABLE_PIN                       PB6
+#define E0_STEP_PIN                         PB5
+#define E0_DIR_PIN                          PB4
+#ifndef E0_CS_PIN
+  #define E0_CS_PIN                         PB3
+#endif
+//Driver4
+#define E1_ENABLE_PIN                       PD7
+#define E1_STEP_PIN                         PD6
+#define E1_DIR_PIN                          PD5
+#ifndef E1_CS_PIN
+  #define E1_CS_PIN                         PD4
+#endif
+//Driver5
+#define E2_ENABLE_PIN                       PD3
+#define E2_STEP_PIN                         PD2
+#define E2_DIR_PIN                          PD1
+#ifndef E2_CS_PIN
+  #define E2_CS_PIN                         PD0
+#endif
+//Driver6
+#define E3_ENABLE_PIN                       PC8
+#define E3_STEP_PIN                         PC7
+#define E3_DIR_PIN                          PC6
+#ifndef E3_CS_PIN
+  #define E3_CS_PIN                         PD15
+#endif
+//Driver7
+#define E4_ENABLE_PIN                       PD14
+#define E4_STEP_PIN                         PD13
+#define E4_DIR_PIN                          PD12
+#ifndef E4_CS_PIN
+  #define E4_CS_PIN                         PD11
+#endif
+
+//
+// Software SPI pins for TMC2130 stepper drivers
+// This board only supports SW SPI for stepper drivers
+//
+#if HAS_TMC_SPI
+  #define TMC_USE_SW_SPI
+#endif
+#if ENABLED(TMC_USE_SW_SPI)
+  #if !defined(TMC_SW_MOSI) || TMC_SW_MOSI == -1
+    #define TMC_SW_MOSI                     PE14
+  #endif
+  #if !defined(TMC_SW_MISO) || TMC_SW_MISO == -1
+    #define TMC_SW_MISO                     PE13
+  #endif
+  #if !defined(TMC_SW_SCK) || TMC_SW_SCK == -1
+    #define TMC_SW_SCK                      PE12
+  #endif
+#endif
+
+#if HAS_TMC_UART
+  //
+  // Software serial
+  // No Hardware serial for steppers
+  //
+  #define X_SERIAL_TX_PIN                   PE6
+  #define X_SERIAL_RX_PIN        X_SERIAL_TX_PIN
+
+  #define Y_SERIAL_TX_PIN                   PE3
+  #define Y_SERIAL_RX_PIN        Y_SERIAL_TX_PIN
+
+  #define Z_SERIAL_TX_PIN                   PB7
+  #define Z_SERIAL_RX_PIN        Z_SERIAL_TX_PIN
+
+  #define E0_SERIAL_TX_PIN                  PB3
+  #define E0_SERIAL_RX_PIN      E0_SERIAL_TX_PIN
+
+  #define E1_SERIAL_TX_PIN                  PD4
+  #define E1_SERIAL_RX_PIN      E1_SERIAL_TX_PIN
+
+  #define E2_SERIAL_TX_PIN                  PD0
+  #define E2_SERIAL_RX_PIN      E2_SERIAL_TX_PIN
+
+  #define E3_SERIAL_TX_PIN                  PD15
+  #define E3_SERIAL_RX_PIN      E3_SERIAL_TX_PIN
+
+  #define E4_SERIAL_TX_PIN                  PD11
+  #define E4_SERIAL_RX_PIN      E4_SERIAL_TX_PIN
+
+  // Reduce baud rate to improve software serial reliability
+  #define TMC_BAUD_RATE                    19200
+#endif
+
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN                          PC1   // TH0
+#define TEMP_1_PIN                          PC2   // TH1
+#define TEMP_2_PIN                          PC3   // TH2
+#define TEMP_BED_PIN                        PC0   // TB
+
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN                        PB1   // HE0
+#define HEATER_1_PIN                        PB0   // HE1
+#define HEATER_2_PIN                        PA3   // HE2
+#define HEATER_BED_PIN                      PB10  // H-BED
+
+#define FAN_PIN                             PA2   // FAN0
+#define FAN1_PIN                            PA1   // FAN1
+#define FAN2_PIN                            PA0   // FAN2
+
+//
+// Misc. Functions
+//
+#define PW_DET                              PC5   // Y+
+#define PW_OFF                              PB12  // Z+
+#define MT_DET_1_PIN                      PW_DET
+#define MT_DET_2_PIN                      PW_OFF
+#ifndef FIL_RUNOUT_PIN
+  #define FIL_RUNOUT_PIN            MT_DET_1_PIN
+#endif
+#ifndef FIL_RUNOUT2_PIN
+  #define FIL_RUNOUT2_PIN           MT_DET_2_PIN
+#endif
+
+//
+// Power Supply Control
+//
+#if ENABLED(MKS_PWC)
+  #define PS_ON_PIN                       PW_OFF
+  #define KILL_PIN                        PW_DET
+  #define KILL_PIN_STATE                    HIGH
+#endif
+
+// Random Info
+#define USB_SERIAL                          -1    // USB Serial
+
+/**
+ *                  ------                                      ------
+ *   (BEEPER) PB2  |10  9 | PE10 (BTN_ENC)    (SPI1 MISO) PA6  |10  9 | PA5 (SPI1 SCK)
+ *   (LCD_EN) PE11 | 8  7 | PD10 (LCD_RS)       (BTN_EN1) PE9  | 8  7 | PA4 (SPI1 CS)
+ *   (LCD_D4) PD9    6  5 | PD8  (LCD_D5)       (BTN_EN2) PE8    6  5 | PA7 (SPI1 MOSI)
+ *   (LCD_D6) PE15 | 4  3 | PE7  (LCD_D7)       (SPI1_RS) PB11 | 4  3 | RESET
+ *             GND | 2  1 | 5V                             GND | 2  1 | 3.3V
+ *                  ------                                      ------
+ *                   EXP1                                        EXP2
+ */
+#define EXP1_03_PIN                         PE7
+#define EXP1_04_PIN                         PE15
+#define EXP1_05_PIN                         PD8
+#define EXP1_06_PIN                         PD9
+#define EXP1_07_PIN                         PD10
+#define EXP1_08_PIN                         PE11
+#define EXP1_09_PIN                         PE10
+#define EXP1_10_PIN                         PB2
+
+#define EXP2_03_PIN                         -1    // RESET
+#define EXP2_04_PIN                         PB11
+#define EXP2_05_PIN                         PA7
+#define EXP2_06_PIN                         PE8
+#define EXP2_07_PIN                         PA4
+#define EXP2_08_PIN                         PE9
+#define EXP2_09_PIN                         PA5
+#define EXP2_10_PIN                         PA6
+
+#if ENABLED(SDSUPPORT)
+  #ifndef SDCARD_CONNECTION
+    #define SDCARD_CONNECTION            ONBOARD
+  #endif
+  #if SD_CONNECTION_IS(ONBOARD)
+    #define ENABLE_SPI3
+    #define SD_SS_PIN                       -1
+    #define SDSS                            PC9
+    #define SD_SCK_PIN                      PC10
+    #define SD_MISO_PIN                     PC11
+    #define SD_MOSI_PIN                     PC12
+    #define SD_DETECT_PIN                   PC4   // SD_DETECT_PIN doesn't work with NO_SD_HOST_DRIVE disabled
+  #elif SD_CONNECTION_IS(LCD)
+    #define ENABLE_SPI1
+    #define SDSS                     EXP2_07_PIN
+    #define SD_SCK_PIN               EXP2_09_PIN
+    #define SD_MISO_PIN              EXP2_10_PIN
+    #define SD_MOSI_PIN              EXP2_05_PIN
+    #define SD_DETECT_PIN            EXP2_04_PIN
+  #endif
+#endif
+
+#if ANY(TFT_COLOR_UI, TFT_CLASSIC_UI)
+  #define TFT_CS_PIN                 EXP1_04_PIN
+  #define TFT_SCK_PIN                EXP2_09_PIN
+  #define TFT_MISO_PIN               EXP2_10_PIN
+  #define TFT_MOSI_PIN               EXP2_05_PIN
+  #define TFT_DC_PIN                 EXP1_03_PIN
+  #define TFT_RST_PIN                EXP1_07_PIN
+  #define TFT_A0_PIN                  TFT_DC_PIN
+
+  #define TFT_RESET_PIN              EXP1_07_PIN
+  #define TFT_BACKLIGHT_PIN          EXP1_08_PIN
+
+  #define TOUCH_BUTTONS_HW_SPI
+  #define TOUCH_BUTTONS_HW_SPI_DEVICE          1
+
+  #define LCD_BACKLIGHT_PIN          EXP1_08_PIN
+  #ifndef TFT_WIDTH
+    #define TFT_WIDTH                        480
+  #endif
+  #ifndef TFT_HEIGHT
+    #define TFT_HEIGHT                       320
+  #endif
+
+  #define TOUCH_CS_PIN               EXP1_06_PIN  // SPI1_NSS
+  #define TOUCH_SCK_PIN              EXP2_09_PIN  // SPI1_SCK
+  #define TOUCH_MISO_PIN             EXP2_10_PIN  // SPI1_MISO
+  #define TOUCH_MOSI_PIN             EXP2_05_PIN  // SPI1_MOSI
+
+  #define LCD_READ_ID                       0xD3
+  #define LCD_USE_DMA_SPI
+
+  #define TFT_BUFFER_SIZE                  14400
+
+  #ifndef TOUCH_CALIBRATION_X
+    #define TOUCH_CALIBRATION_X           -17253
+  #endif
+  #ifndef TOUCH_CALIBRATION_Y
+    #define TOUCH_CALIBRATION_Y            11579
+  #endif
+  #ifndef TOUCH_OFFSET_X
+    #define TOUCH_OFFSET_X                   514
+  #endif
+  #ifndef TOUCH_OFFSET_Y
+    #define TOUCH_OFFSET_Y                   -24
+  #endif
+  #ifndef TOUCH_ORIENTATION
+    #define TOUCH_ORIENTATION    TOUCH_LANDSCAPE
+  #endif
+
+#elif HAS_WIRED_LCD
+
+  #define LCD_PINS_ENABLE            EXP1_08_PIN
+  #define LCD_PINS_RS                EXP1_07_PIN
+  #define LCD_BACKLIGHT_PIN                 -1
+
+  // MKS MINI12864 and MKS LCD12864B; If using MKS LCD12864A (Need to remove RPK2 resistor)
+  #if ENABLED(MKS_MINI_12864)
+
+    #define ENABLE_SPI1
+    #define FORCE_SOFT_SPI
+    #define DOGLCD_A0                EXP1_04_PIN
+    #define DOGLCD_CS                EXP1_05_PIN
+    #define DOGLCD_SCK               EXP2_09_PIN
+    #define DOGLCD_MOSI              EXP2_05_PIN
+    //#define LCD_BACKLIGHT_PIN               -1
+    //#define LCD_RESET_PIN                   -1
+
+  #elif ENABLED(FYSETC_MINI_12864_2_1)
+
+    #define DOGLCD_CS                EXP1_08_PIN
+    #define DOGLCD_A0                EXP1_07_PIN
+    #define LCD_PINS_DC                DOGLCD_A0
+    #define LCD_BACKLIGHT_PIN               -1
+    #define LCD_RESET_PIN            EXP1_06_PIN
+    #define NEOPIXEL_PIN             EXP1_05_PIN
+    #define DOGLCD_MOSI              EXP2_05_PIN
+    #define DOGLCD_SCK               EXP2_09_PIN
+    #if SD_CONNECTION_IS(ONBOARD)
+      #define FORCE_SOFT_SPI
+    #endif
+    //#define LCD_SCREEN_ROT_180
+
+  #else
+
+    #define LCD_PINS_D4              EXP1_06_PIN
+    #if ENABLED(ULTIPANEL)
+      #define LCD_PINS_D5            EXP1_05_PIN
+      #define LCD_PINS_D6            EXP1_04_PIN
+      #define LCD_PINS_D7            EXP1_03_PIN
+    #endif
+
+    #define BOARD_ST7920_DELAY_1              96
+    #define BOARD_ST7920_DELAY_2              48
+    #define BOARD_ST7920_DELAY_3             600
+
+  #endif // !MKS_MINI_12864
+
+#endif // HAS_WIRED_LCD
+
+#if ANY(TFT_COLOR_UI, TFT_CLASSIC_UI, HAS_WIRED_LCD)
+  #define BEEPER_PIN                 EXP1_10_PIN
+  #define BTN_EN1                    EXP2_08_PIN
+  #define BTN_EN2                    EXP2_06_PIN
+  #define BTN_ENC                    EXP1_09_PIN
+#endif
diff --git a/Marlin/src/pins/stm32f4/pins_STEVAL_3DP001V1.h b/Marlin/src/pins/stm32f4/pins_STEVAL_3DP001V1.h
new file mode 100644
index 0000000000..0b527a6fdb
--- /dev/null
+++ b/Marlin/src/pins/stm32f4/pins_STEVAL_3DP001V1.h
@@ -0,0 +1,325 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+// Source: https://github.com/stm32duino/Arduino_Core_STM32/blob/master/variants/ST3DP001_EVAL/variant.cpp
+
+/**
+ * HOW TO COMPILE
+ *
+ * PlatformIO - Use the STM32F401VE_STEVAL environment (or the "Auto Build Marlin" extension).
+ *
+ * Arduino - Tested with 1.8.10
+ *      Install library per https://github.com/stm32duino/Arduino_Core_STM32
+ *      Make the following selections under the TOOL menu in the Arduino IDE
+ *          Board: "3D printer boards"
+ *          Board part number: "STEVAL-3DP001V1"
+ *          U(S)ART support: "Enabled (generic "Serial")"
+ *          USB support (if available): "CDC (no generic "Serial")"
+ *          Optimize: "Smallest (-Os default)"
+ *          C Runtime Library: "newlib Nano (default)"
+ */
+
+#include "env_validate.h"
+
+#ifndef MACHINE_NAME
+  #define MACHINE_NAME "STEVAL-3DP001V1"
+#endif
+
+//
+// Limit Switches
+//
+#define X_MIN_PIN                           PD8   // X_STOP
+#define Y_MIN_PIN                           PD9   // Y_STOP
+#define Z_MIN_PIN                           PD10  // Z_STOP
+
+#define X_MAX_PIN                           PD0   // W_STOP
+#define Y_MAX_PIN                           PA8   // V_STOP
+#define Z_MAX_PIN                           PD11  // U_STOP
+
+//
+// Z Probe (when not Z_MIN_PIN)
+//
+//#ifndef Z_MIN_PROBE_PIN
+//  #define Z_MIN_PROBE_PIN                 PA4   // SPI1_CS
+//#endif
+
+//
+// Filament runout
+//
+//#define FIL_RUNOUT_PIN                    PA3   // BED_THERMISTOR_3
+
+//
+// Steppers
+//
+
+#define X_STEP_PIN                          PE14  // X_PWM
+#define X_DIR_PIN                           PE15  // X_DIR
+#define X_ENABLE_PIN                        PE13  // X_RESET
+#define X_CS_PIN                            PA4   // SPI1_CS
+
+#define Y_STEP_PIN                          PB10  // Y_PWM
+#define Y_DIR_PIN                           PE9   // Y_DIR
+#define Y_ENABLE_PIN                        PE10  // Y_RESET
+#define Y_CS_PIN                            PA4   // SPI1_CS
+
+#define Z_STEP_PIN                          PC6   // Z_PWM
+#define Z_DIR_PIN                           PC0   // Z_DIR
+#define Z_ENABLE_PIN                        PC15  // Z_RESET
+#define Z_CS_PIN                            PA4   // SPI1_CS
+
+#define E0_STEP_PIN                         PD12  // E1_PW
+#define E0_DIR_PIN                          PC13  // E1_DIR
+#define E0_ENABLE_PIN                       PC14  // E1_RESET
+#define E0_CS_PIN                           PA4   // SPI1_CS
+
+#define E1_STEP_PIN                         PE5   // E2_PWM
+#define E1_DIR_PIN                          PE6   // E2_DIR
+#define E1_ENABLE_PIN                       PE4   // E2_RESET
+#define E1_CS_PIN                           PA4   // SPI1_CS
+
+#define E2_STEP_PIN                         PB8   // E3_PWM
+#define E2_DIR_PIN                          PE2   // E3_DIR
+#define E2_ENABLE_PIN                       PE3   // E3_RESET
+#define E2_CS_PIN                           PA4   // SPI1_CS
+
+// needed to pass a sanity check
+#define X2_CS_PIN                           PA4   // SPI1_CS
+#define Y2_CS_PIN                           PA4   // SPI1_CS
+#define Z2_CS_PIN                           PA4   // SPI1_CS
+#define Z3_CS_PIN                           PA4   // SPI1_CS
+#define E3_CS_PIN                           PA4   // SPI1_CS
+#define E4_CS_PIN                           PA4   // SPI1_CS
+#define E5_CS_PIN                           PA4   // SPI1_CS
+
+#if HAS_L64XX
+  #define L6470_CHAIN_SCK_PIN               PA5   // SPI1_SCK
+  #define L6470_CHAIN_MISO_PIN              PA6   // SPI1_MISO
+  #define L6470_CHAIN_MOSI_PIN              PA7   // SPI1_MOSI
+  #define L6470_CHAIN_SS_PIN                PA4   // SPI1_CS
+
+  //#define SD_SCK_PIN       L6470_CHAIN_SCK_PIN
+  //#define SD_MISO_PIN     L6470_CHAIN_MISO_PIN
+  //#define SD_MOSI_PIN     L6470_CHAIN_MOSI_PIN
+#else
+  //#define SD_SCK_PIN                      PB13  // SPI2_SCK
+  //#define SD_MISO_PIN                     PB14  // SPI2_MISO
+  //#define SD_MOSI_PIN                     PB15  // SPI2_MOSI
+#endif
+
+/**
+ * Macro to reset/enable L6474 stepper drivers
+ *
+ * IMPORTANT - To disable (bypass) L6474s, install the corresponding
+ *             resistors (R11 - R17) and change the "V" to "0" for the
+ *             corresponding pins here:
+ */
+#define ENABLE_RESET_L64XX_CHIPS(V)   do{ OUT_WRITE(X_ENABLE_PIN, V); \
+                                          OUT_WRITE(Y_ENABLE_PIN, V); \
+                                          OUT_WRITE(Z_ENABLE_PIN, V); \
+                                          OUT_WRITE(E0_ENABLE_PIN,V); \
+                                          OUT_WRITE(E1_ENABLE_PIN,V); \
+                                          OUT_WRITE(E2_ENABLE_PIN,V); \
+                                        }while(0)
+
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN                          PA0   // Analog Input 3
+#define TEMP_1_PIN                          PA1   // Analog Input 4
+#define TEMP_2_PIN                          PA2   // Analog Input 5
+#define TEMP_BED_PIN                        PC2   // Analog Input 0
+#define TEMP_BED_1_PIN                      PC3   // Analog Input 1
+#define TEMP_BED_2_PIN                      PA3   // Analog Input 2
+
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN                        PC7   // E1_HEAT_PWM
+#define HEATER_1_PIN                        PB0   // E2_HEAT_PWM
+#define HEATER_2_PIN                        PB1   // E3_HEAT_PWM
+#define HEATER_BED_PIN                      PD14  // BED_HEAT_1 FET
+#define HEATER_BED_1_PIN                    PD13  // BED_HEAT_2 FET
+#define HEATER_BED_2_PIN                    PD15  // BED_HEAT_3 FET
+
+#define FAN_PIN                             PC4   // E1_FAN   PWM pin, Part cooling fan FET
+#define FAN1_PIN                            PC5   // E2_FAN   PWM pin, Extruder fan FET
+#define FAN2_PIN                            PE8   // E3_FAN   PWM pin, Controller fan FET
+
+#ifndef E0_AUTO_FAN_PIN
+  #define E0_AUTO_FAN_PIN                   PC5   // FAN1_PIN
+#endif
+
+//
+// Misc functions
+//
+#define LED_PIN                             -1    // PE1  Green LED Heartbeat
+#define PS_ON_PIN                           -1
+#define KILL_PIN                            -1
+#define POWER_LOSS_PIN                      -1    // PWR_LOSS / nAC_FAULT
+
+//
+// LCD / Controller
+//
+//#define SD_DETECT_PIN                     PA15  // SD_CARD_DETECT
+//#define BEEPER_PIN                        PC9   // SDIO_D1
+//#define LCD_PINS_RS                       PE9   // Y_DIR
+//#define LCD_PINS_ENABLE                   PE8   // E3_FAN
+//#define LCD_PINS_D4                       PB12  // SPI2_CS
+//#define LCD_PINS_D5                       PB13  // SPI2_SCK
+//#define LCD_PINS_D6                       PB14  // SPI2_MISO
+//#define LCD_PINS_D7                       PB15  // SPI2_MOSI
+//#define BTN_EN1                           PC4   // E1_FAN
+//#define BTN_EN2                           PC5   // E2_FAN
+//#define BTN_ENC                           PC3   // BED_THERMISTOR_2
+
+//
+// Extension pins
+//
+//#define EXT0_PIN                          PB0   // E2_HEAT
+//#define EXT1_PIN                          PB1   // E3_HEAT
+//#define EXT2_PIN                          PB2   // not used (tied to ground)
+//#define EXT3_PIN                          PD8   // X_STOP
+//#define EXT4_PIN                          PD9   // Y_STOP
+//#define EXT5_PIN                          PD10  // Z_STOP
+//#define EXT6_PIN                          PD11  // U_STOP
+//#define EXT7_PIN                          PD12  // E1_PWM
+//#define EXT8_PIN                          PB10  // Y_PWM
+
+// WIFI
+// PD3   CTS
+// PD4   RTS
+// PD5   TX
+// PD6   RX
+// PB5   WIFI_WAKEUP
+// PE11  WIFI_RESET
+// PE12  WIFI_BOOT
+
+// I2C USER
+// PB7   SDA
+// PB6   SCL
+
+// JTAG
+// PA13  JTAG_TMS/SWDIO
+// PA14  JTAG_TCK/SWCLK
+// PB3   JTAG_TDO/SWO
+
+//
+// Onboard SD support
+//
+#ifndef SDCARD_CONNECTION
+  #define SDCARD_CONNECTION              ONBOARD
+#endif
+
+#if SD_CONNECTION_IS(ONBOARD)
+
+  #define SDIO_SUPPORT                            // Use SDIO for onboard SD
+  #if DISABLED(SDIO_SUPPORT)
+    #define SOFTWARE_SPI                          // Use soft SPI for onboard SD
+    #define SDSS                            PC11
+    #define SD_SCK_PIN                      PC12
+    #define SD_MISO_PIN                     PC8
+    #define SD_MOSI_PIN                     PD2
+  #endif
+
+  //#define SD_DETECT_PIN                   PA15
+
+#endif
+
+#ifndef SDSS
+  #define SDSS                              PA4   // SPI1_CS
+#endif
+
+// OTG
+// PA11   OTG_DM
+// PA12   OTG_DP
+
+// USER_PINS
+// PD7    USER3
+// PB9    USER1
+// PE0    USER2
+// PB4    USER4
+
+// USERKET
+// PE7    USER_BUTTON
+
+// PA9    TX
+// PA10   RX
+
+// IR/PROBE
+// PD1    IR_OUT
+// PC1    IR_ON
+
+/**
+ * Logical pin vs. port/pin cross reference
+ *
+ * PA0    E1_THERMISTOR           PD0    W_STOP
+ * PA1    E2_THERMISTOR           PD1    IR_OUT
+ * PA2    E3_THERMISTOR           PD2    SDIO_CMD
+ * PA3    BED_THERMISTOR_3        PD3    CTS
+ * PA4    SPI1_CS                 PD4    RTS
+ * PA5    SPI1_SCK                PD5    TX
+ * PA6    SPI1_MISO               PD6    RX
+ * PA7    SPI1_MOSI               PD7    USER3
+ * PA8    V_STOP                  PD8    X_STOP
+ * PA9    TX                      PD9    Y_STOP
+ * PA10   RX                      PD10   Z_STOP
+ * PA11   OTG_DM                  PD11   U_STOP
+ * PA12   OTG_DP                  PD12   E1_PWM
+ * PA13   JTAG_TMS/SWDIO          PD13   BED_HEAT_2
+ * PA14   JTAG_TCK/SWCLK          PD14   BED_HEAT_1
+ * PA15   SD_CARD_DETECT          PD15   BED_HEAT_3
+ *
+ * PB0    E2_HEAT_PWM             PE0    USER2
+ * PB1    E3_HEAT_PWM             PE1    STATUS_LED
+ * PB2    ---                     PE2    E3_DIR
+ * PB3    JTAG_TDO/SWO            PE3    E3_RESET
+ * PB4    USER4                   PE4    E2_RESET
+ * PB5    WIFI_WAKEUP             PE5    E2_PWM
+ * PB6    SCL                     PE6    E2_DIR
+ * PB7    SDA                     PE7    USER_BUTTON
+ * PB8    E3_PWM                  PE8    E3_FAN
+ * PB9    USER1                   PE9    Y_DIR
+ * PB10   Y_PWM                   PE10   Y_RESET
+ * PB11   ---                     PE11   WIFI_RESET
+ * PB12   SPI2_CS                 PE12   WIFI_BOOT
+ * PB13   SPI2_SCK                PE13   X_RESET
+ * PB14   SPI2_MISO               PE14   X_PWM
+ * PB15   SPI2_MOSI               PE15   X_DIR
+ *
+ * PC0    Z_DIR
+ * PC1    IR_ON
+ * PC2    BED_THERMISTOR_1
+ * PC3    BED_THERMISTOR_2
+ * PC4    E1_FAN
+ * PC5    E2_FAN
+ * PC6    Z_PWM
+ * PC7    E1_HEAT_PWM
+ * PC8    SDIO_D0
+ * PC9    SDIO_D1
+ * PC10   SDIO_D2
+ * PC11   SDIO_D3
+ * PC12   SDIO_CK
+ * PC13   E1_DIR
+ * PC14   E1_RESET
+ * PC15   Z_RESET
+ */
diff --git a/Marlin/src/pins/stm32h7/pins_BTT_SKR_SE_BX.h b/Marlin/src/pins/stm32h7/pins_BTT_SKR_SE_BX.h
new file mode 100644
index 0000000000..9eb0acf144
--- /dev/null
+++ b/Marlin/src/pins/stm32h7/pins_BTT_SKR_SE_BX.h
@@ -0,0 +1,235 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#if NOT_TARGET(STM32H7)
+  #error "Oops! Select an STM32H7 board in 'Tools > Board.'"
+#endif
+
+#define BOARD_INFO_NAME      "BTT SKR SE BX"
+#define DEFAULT_MACHINE_NAME "BIQU-BX"
+
+// Onboard I2C EEPROM
+#define I2C_EEPROM
+#define MARLIN_EEPROM_SIZE                0x1000  // 4KB (24C32 ... 32Kb = 4KB)
+
+#define HAS_OTG_USB_HOST_SUPPORT                  // USB Flash Drive support
+
+//
+// Limit Switches
+//
+#define X_MIN_PIN                           PB11
+#define X_MAX_PIN                           PD13
+#define Y_MIN_PIN                           PB12
+#define Y_MAX_PIN                           PB13
+#define Z_MIN_PIN                           PD12
+#define Z_MAX_PIN                           PD11
+
+#define FIL_RUNOUT_PIN                      PD13
+#define FIL_RUNOUT2_PIN                     PB13
+
+#define LED_PIN                             PA13
+#define BEEPER_PIN                          PA14
+
+#define TFT_BACKLIGHT_PIN                   PB5
+
+#define POWER_MONITOR_PIN                   PB0
+#define RPI_POWER_PIN                       PE5
+
+#define SAFE_POWER_PIN                      PI11
+#define SERVO0_PIN                          PA2
+
+//
+// Z Probe (when not Z_MIN_PIN)
+//
+#ifndef Z_MIN_PROBE_PIN
+  #define Z_MIN_PROBE_PIN                   PH2   // Probe
+#endif
+
+//
+// Steppers
+//
+#define X_STEP_PIN                          PG13
+#define X_DIR_PIN                           PG12
+#define X_ENABLE_PIN                        PG14
+#define X_CS_PIN                            PG10
+
+#define Y_STEP_PIN                          PB3
+#define Y_DIR_PIN                           PD3
+#define Y_ENABLE_PIN                        PB4
+#define Y_CS_PIN                            PD4
+
+#define Z_STEP_PIN                          PD7
+#define Z_DIR_PIN                           PD6
+#define Z_ENABLE_PIN                        PG9
+#define Z_CS_PIN                            PD5
+
+#define E0_STEP_PIN                         PC14
+#define E0_DIR_PIN                          PC13
+#define E0_ENABLE_PIN                       PC15
+#define E0_CS_PIN                           PI8
+
+#define E1_STEP_PIN                         PA8
+#define E1_DIR_PIN                          PC9
+#define E1_ENABLE_PIN                       PD2
+#define E1_CS_PIN                           PC8
+
+//
+// Software SPI pins for TMC2130 stepper drivers
+//
+#if ENABLED(TMC_USE_SW_SPI)
+  #ifndef TMC_SW_MOSI
+    #define TMC_SW_MOSI                     PC6
+  #endif
+  #ifndef TMC_SW_MISO
+    #define TMC_SW_MISO                     PG3
+  #endif
+  #ifndef TMC_SW_SCK
+    #define TMC_SW_SCK                      PC7
+  #endif
+#endif
+
+#if HAS_TMC_UART
+  /**
+   * TMC2208/TMC2209 stepper drivers
+   *
+   * Hardware serial communication ports.
+   * If undefined software serial is used according to the pins below
+   */
+  //#define X_HARDWARE_SERIAL  Serial
+  //#define X2_HARDWARE_SERIAL Serial1
+  //#define Y_HARDWARE_SERIAL  Serial1
+  //#define Y2_HARDWARE_SERIAL Serial1
+  //#define Z_HARDWARE_SERIAL  Serial1
+  //#define Z2_HARDWARE_SERIAL Serial1
+  //#define E0_HARDWARE_SERIAL Serial1
+  //#define E1_HARDWARE_SERIAL Serial1
+  //#define E2_HARDWARE_SERIAL Serial1
+  //#define E3_HARDWARE_SERIAL Serial1
+  //#define E4_HARDWARE_SERIAL Serial1
+  //#define E5_HARDWARE_SERIAL Serial1
+  //#define E6_HARDWARE_SERIAL Serial1
+  //#define E7_HARDWARE_SERIAL Serial1
+
+  #define X_SERIAL_TX_PIN                   PG10
+  #define X_SERIAL_RX_PIN        X_SERIAL_TX_PIN
+
+  #define Y_SERIAL_TX_PIN                   PD4
+  #define Y_SERIAL_RX_PIN        Y_SERIAL_TX_PIN
+
+  #define Z_SERIAL_TX_PIN                   PD5
+  #define Z_SERIAL_RX_PIN        Z_SERIAL_TX_PIN
+
+  #define E0_SERIAL_TX_PIN                  PI8
+  #define E0_SERIAL_RX_PIN      E0_SERIAL_TX_PIN
+
+  #define E1_SERIAL_TX_PIN                  PC8
+  #define E1_SERIAL_RX_PIN      E1_SERIAL_TX_PIN
+
+  // Reduce baud rate to improve software serial reliability
+  #define TMC_BAUD_RATE                    19200
+#endif
+
+//
+// Temperature Sensors
+//
+#define TEMP_0_PIN                          PH4   // TH0
+#define TEMP_1_PIN                          PA3   // TH1
+#define TEMP_BED_PIN                        PH5   // TB
+
+//
+// Heaters / Fans
+//
+#define HEATER_0_PIN                        PC4
+#define HEATER_1_PIN                        PC5
+#define HEATER_BED_PIN                      PA4
+
+#define FAN_PIN                             PA5   // "FAN0"
+#define FAN1_PIN                            PA6   // "FAN1"
+#define FAN2_PIN                            PA7   // "FAN2"
+
+#define NEOPIXEL_PIN                        PH3
+#define NEOPIXEL2_PIN                       PB1
+
+#if HAS_LTDC_TFT
+
+  // LTDC_LCD Timing
+  #define LTDC_LCD_CLK                        50  // LTDC clock frequency = 50Mhz
+  #define LTDC_LCD_HSYNC                      30  // Horizontal synchronization
+  #define LTDC_LCD_HBP                       114  // Horizontal back porch
+  #define LTDC_LCD_HFP                        16  // Horizontal front porch
+  #define LTDC_LCD_VSYNC                       3  // Vertical synchronization
+  #define LTDC_LCD_VBP                        32  // Vertical back porch
+  #define LTDC_LCD_VFP                        10  // Vertical front porch
+
+  #define TFT_BACKLIGHT_PIN                 PB5
+  #define LCD_DE_PIN                        PF10
+  #define LCD_CLK_PIN                       PG7
+  #define LCD_VSYNC_PIN                     PI9
+  #define LCD_HSYNC_PIN                     PI10
+  #define LCD_R7_PIN                        PG6   // R5
+  #define LCD_R6_PIN                        PH12
+  #define LCD_R5_PIN                        PH11
+  #define LCD_R4_PIN                        PH10
+  #define LCD_R3_PIN                        PH9
+  #define LCD_G7_PIN                        PI2   // G6
+  #define LCD_G6_PIN                        PI1
+  #define LCD_G5_PIN                        PI0
+  #define LCD_G4_PIN                        PH15
+  #define LCD_G3_PIN                        PH14
+  #define LCD_G2_PIN                        PH13
+  #define LCD_B7_PIN                        PI7   // B5
+  #define LCD_B6_PIN                        PI6
+  #define LCD_B5_PIN                        PI5
+  #define LCD_B4_PIN                        PI4
+  #define LCD_B3_PIN                        PG11
+
+  // GT911 Capacitive Touch Sensor
+  #if ENABLED(TFT_TOUCH_DEVICE_GT911)
+    #define GT911_RST_PIN                   PE4
+    #define GT911_INT_PIN                   PE3
+    #define GT911_SW_I2C_SCL_PIN            PE2
+    #define GT911_SW_I2C_SDA_PIN            PE6
+  #endif
+
+#endif
+
+#if IS_NEWPANEL
+  #define BTN_EN1                           PH6
+  #define BTN_EN2                           PH7
+  #define BTN_ENC                           PH8
+#endif
+
+//
+// SD card
+//
+#ifndef SDCARD_CONNECTION
+  #define SDCARD_CONNECTION              ONBOARD
+#endif
+
+#define SOFTWARE_SPI
+#define SDSS                                PA15
+#define SD_SS_PIN                           SDSS
+#define SD_SCK_PIN                          PC10
+#define SD_MISO_PIN                         PC11
+#define SD_MOSI_PIN                         PC12
+#define SD_DETECT_PIN                       PI3
diff --git a/Marlin/src/sd/cardreader.cpp b/Marlin/src/sd/cardreader.cpp
index fb2721a2b2..18e703ce5b 100644
--- a/Marlin/src/sd/cardreader.cpp
+++ b/Marlin/src/sd/cardreader.cpp
@@ -20,6 +20,16 @@
  *
  */
 
+
+//TG 5/2/22 Added this to suppress "warning: 'void* memset(void*, int, size_t)' clearing an object of non-trivial type
+//                                 'class SdFile'; use assignment or value-initialization instead [-Wclass-memaccess]
+// on line 172 ZERO(workDirParents)
+// The 'GCC diagnostic ignored pragma' makes this effective ONLY for this source file. If the "-Wclass-memaccess" were
+// added in platformio.ini it would affect all files in the project, and this particular "-Wclass-memaccess" can only
+// be used with .cpp files, not .c files (there are still some .c files in Marlin and this would cause many more errors).
+#pragma GCC diagnostic ignored "-Wclass-memaccess"
+
+
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(SDSUPPORT)
diff --git a/Modifications to BigTreeTech TFT35 V3.docx b/Modifications to BigTreeTech TFT35 V3.docx
new file mode 100644
index 0000000000..0ece2f190e
--- /dev/null
+++ b/Modifications to BigTreeTech TFT35 V3.docx	
@@ -0,0 +1,614 @@
+Modifications to BigTreeTech TFT35 V3.0 Source Code
+
+C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\Copy to SD Card root directory to update - Unified Menu Material theme\config.ini
+  36,2: #//TG 11/1/20 changed from 5 to 6 for 250000 baud
+  151,2: #//TG 11/1/20 changed this
+  185,2: #//TG 11/1/20 changed BED was 150
+  202,2: #//TG 11/1/20 changed these
+  272,2: #//TG 11/1/20 modified these (6 maximum)
+  313,3: ##//TG 11/1/20 enabled this
+  318,2: #//TG 11/1/20 changed this was 0, SWX1 sensor is non-inverting
+  323,2: #//TG increased due to false triggers (was 100)
+  439,2: #//TG 11/1/20 enabled this
+  444,2: #//TG 11/1/20 enabled this
+
+C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\API\menu.c
+    5,1: //TG this code draws, handles, processes, and responds to menus
+
+C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\API\parseACK.c
+ 550,33: // Parse and store ABL type //TG Is this broken??
+
+C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\API\Settings.h
+  30,40: #define ICON_FLASH_SIGN       20201031 //TG (YYYYMMDD) change if any icon(s) is added or removed
+
+C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\Menu\FeatureSettings.c
+    4,1:  //TG Layout for the page
+   55,1:  //TG here is where you would expand the list if needed, but also need to expand
+  111,5:  //TG this list item has only a LABEL value, no ON/OFF TOGGLE (red dot)
+ 361,29:  #ifdef LED_COLOR_PIN  //TG only on the E3 version
+ 372,35:  #ifdef LCD_LED_PWM_CHANNEL  //TG LCD brightness control
+ 440,35:  void menuFeatureSettings(void)    //TG handles the Feature List Menu up,dn, and back buttons
+ 449,51:  key_num = menuKeyGetValue();                  //TG get a pressed key?
+ 452,51:  case KEY_ICON_5:                              //TG  up arrow, load prev list
+ 462,51:  case KEY_ICON_6:                              //TG  dn arrow, load next list
+ 472,51:  case KEY_ICON_7:                              //TG back arrow, load prev infoMenu
+
+C:\Users\tony\Documents\3D Printers\Marlin Firmware\BIGTREETECH-TouchScreenFirmware-master\TFT\src\User\Menu\SettingsMenu.c
+ 120,59:  {ICON_BACKGROUND,              LABEL_BACKGROUND},    //TG available button?
+ 121,59:  {ICON_BACKGROUND,              LABEL_BACKGROUND},    //TG available button?
+
+Creating/Adding custom icon buttons to menus
+
+To create a new icon for a button to be used in menus, first choose a name for the icon CUSTOM_1, then create a .bmp file for the button and name it CUSTOM_1.bmp
+
+Now, to be able to use it in menus do the following:
+
+First, we must add a few new keywords into these 4 files so the rest of the code knows about our new icon:
+
+TFT\src\User\API\icon_list.inc				add   X_ICON (CUSTOM_1) this makes ICON_CUSTOM_1	
+TFT\src\User\API\Language\Language.inc		add   X_WORD (CUSTOM_1) this makes LABEL_CUSTOM_1
+TFT\src\User\API\Language\language_en.h		add   #define STRING_CUSTOM_1	  "TG Menu"
+TFT\src\User\API\Language\language_keywords.h	add   #define LANG_KEY_CUSTOM_1	  "label_custom_1:"
+Note: language_keywords.h is only needed if config file option is desired!
+
+Any time a new keyword is added to the 4 files above, we have to change these signs in TFT\src\User\API\Settings.h:
+
+#define LANGUAGE_FLASH_SIGN   20201107 //(YYYYMMDD) change if any keyword(s) in language pack is							 added or removed
+#define ICON_FLASH_SIGN       20201107 //(YYYYMMDD) change if any icon(s) is added or removed
+
+Now, to implement the new icon as a button in a menu, we find an empty slot in one of the existing menus and
+modify the const MENUITEMS array for that parent menu. For example, we'll use the Settings Menu as the parent
+menu for our new button because it has some empty positions in it (each menu page can have 7 buttons max).
+
+So open the code file for the Settings Menu (TFT\src\User\Menu\SettingsMenu.c in this case).
+We see there is a const MENUITEMS array named settingsItems and we also see this array has two unused
+entries at indexes 5 and 6 (they're set to ICON_BACKGROUND,LABEL_BACKGROUND which means empty).
+So we can add our new button in like so, replacing with our new values as shown below:
+const MENUITEMS settingsItems = {
+    // title
+    LABEL_SETTINGS,
+    // icon                     label
+    {{ICON_SCREEN_SETTINGS,     LABEL_SCREEN_SETTINGS},
+     {ICON_MACHINE_SETTINGS,    LABEL_MACHINE_SETTINGS},
+     {ICON_FEATURE_SETTINGS,    LABEL_FEATURE_SETTINGS},
+     {ICON_SCREEN_INFO,         LABEL_SCREEN_INFO},
+     {ICON_CONNECTION_SETTINGS, LABEL_CONNECTION_SETTINGS},
+     {ICON_CUSTOM_1,            LABEL_CUSTOM_1},     <-- we overwrite previous ICON_BACKGROUND, LABEL_BACKGROUND
+     {ICON_BACKGROUND,          LABEL_BACKGROUND},	    with the icon name and text label of our custom icon
+     {ICON_BACK,                LABEL_BACK},}
+  };
+
+Next, we need to add some code to handle what happens when our custom button is pressed. There's usually
+a code block like the one shown shown below for the parent menu. It's usually found not too far after the
+const MENUITEMS <parentmenu_name>  block we modified above. Put your handling code in this code block.
+
+while(infoMenu.menu[infoMenu.cur] == menuSettings)
+  {
+    key_num = menuKeyGetValue();
+    switch(key_num)
+    {
+      case KEY_ICON_0:
+        infoMenu.menu[++infoMenu.cur] = menuScreenSettings;
+        break;
+
+      case KEY_ICON_1:
+        mustStoreCmd("M503 S0\n");
+        infoMenu.menu[++infoMenu.cur] = menuMachineSettings;
+        break;
+
+      case KEY_ICON_2:
+        infoMenu.menu[++infoMenu.cur] = menuFeatureSettings;
+        break;
+
+      case KEY_ICON_3:
+        infoMenu.menu[++infoMenu.cur] = menuInfo;
+        break;
+
+      case KEY_ICON_4:
+        infoMenu.menu[++infoMenu.cur] = menuConnectionSettings;
+        break;
+
+      case KEY_ICON_5:							<-- here we add the case for custom_1 button
+        infoMenu.menu[++infoMenu.cur] = menuTGmenu;	    		    at position 5 in the menu. You can call
+        break;								    another menu or handle some task here.
+                             Also notice there is no KEY_ICON_6, 
+      case KEY_ICON_7:							    since that menu position is blank.
+        infoMenu.cur--;
+        break;
+
+      default:
+        break;
+    }
+    loopProcess();
+  }
+
+Finally, we need to create a .c and .h module to perform some action (i.e. handle the menuTGmenu call above). Here is the C code file, TGmenu.c
+
+#include "TGmenu.h"
+#include "SendGcode.h"
+#include "includes.h"
+  
+//extern char gcodeBuf[CMD_MAX_CHAR];
+//char* gcodeBufPtr = &gcodeBuf[0];
+
+void menuTGmenu(void)						<-- here is the new function to draw new menu
+{
+  //TG examples of variable usage
+/*
+static uint8_t ublSlot;
+static bool ublIsSaving = true;
+static bool ublSlotSaved = false;
+*/
+
+  
+
+MENUITEMS TGmenuItems = {					<-- this is the new MENUITEMS structure
+    // title
+    LABEL_TGMENU,
+    // icon                         label
+    {{ICON_Z_0,                     LABEL_Z_0},
+     {ICON_Z_300,                   LABEL_Z_300},
+     {ICON_M503,                    LABEL_M503},
+     {ICON_BACKGROUND,              LABEL_BACKGROUND},
+     {ICON_BACKGROUND,              LABEL_BACKGROUND},
+     {ICON_BACKGROUND,              LABEL_BACKGROUND},
+     {ICON_BACKGROUND,              LABEL_BACKGROUND},
+     {ICON_BACK,                    LABEL_BACK}}
+  };
+
+  KEY_VALUES key_num = KEY_IDLE;
+
+The switch below is not used, just included to show how to modify an existing menu dynamically 
+//TG this looks like an example of how to modify an existing menu on the fly based on
+ //   information or other variables elsewhere in code
+ /* switch (infoMachineSettings.leveling)
+  {
+    case BL_BBL:
+      autoLevelingItems.title.index = LABEL_ABL_SETTINGS_BBL;
+      break;
+
+    case BL_UBL:
+      autoLevelingItems.title.index = LABEL_ABL_SETTINGS_UBL;
+      autoLevelingItems.items[1].icon = ICON_EEPROM_SAVE;
+      autoLevelingItems.items[1].label.index = LABEL_SAVE;
+      autoLevelingItems.items[2].icon = ICON_EEPROM_RESTORE;
+      autoLevelingItems.items[2].label.index = LABEL_LOAD;
+      break;
+
+    default:
+      break;
+  }
+*/
+
+
+  menuDrawPage(&TGmenuItems);					<-- call to draw the menu
+
+  while (infoMenu.menu[infoMenu.cur] == menuTGmenu)		<-- now wait in loop for an item to be pressed
+  {
+    key_num = menuKeyGetValue();				<-- find out what menu item was touched
+    switch (key_num)						<-- do something for current touched menu item
+    {
+      case KEY_ICON_0:
+        storeCmd("G1 Z0\n");
+        break;
+
+      case KEY_ICON_1:
+        storeCmd("G1 Z300\n");
+        break;
+
+      case KEY_ICON_2:
+      /*
+      gcodeBuf[0]=(char)'M';
+      gcodeBuf[1]=(char)'5';
+      gcodeBuf[2]=(char)'0';
+      gcodeBuf[3]=(char)'3';
+      gcodeBuf[4]=(char)'/n';
+      gcodeBuf[5]=0;
+      storeCmd(gcodeBuf);
+      */
+
+        storeCmd("M503\n");
+        //gcodeBuf[0] = 0;
+        infoMenu.menu[++infoMenu.cur] = menuTerminal;
+        break;
+
+      case KEY_ICON_7:						<-- the "back" item sets current menu to previous
+        infoMenu.cur--;
+        break;
+
+      default:
+        break;
+    }
+
+    loopProcess();
+  }
+}
+And here is the .h file, TGmenu.h
+
+#ifndef _TGMENU_H_
+#define _TGMENU_H_
+
+   #ifdef __cplusplus
+   extern "C" {
+   #endif
+   
+   #include <stdbool.h>
+   
+   void menuTGmenu(void);
+   
+   #ifdef __cplusplus
+   }
+   #endif
+
+#endif
+
+
+We are done!
+
+
+Creating a parameter available to set in the config.ini file
+
+1. Define a keyword in TFT\src\User\API\config.inc 				example: X_CONFIG(BAUDRATE).
+2. Put a #define in TFT\src\User\API\config.inc			#define CONFIG_BAUDRATE  "baudrate:"  (where "baudrate:" matches the way it appears in config.ini)
+3. Then create a `string identifier' and value in TFT\src\User\config.ini, 	example:  baudrate:6 
+4. Put a default #define in TFT\src\User\Configuration.h			example:  #define BAUDRATE 6	 
+      (to define a default value if nothing is present in config.ini).
+5. In file src\User\API\config.c must have a `case:' statement in function parseConfigKey() to process the keyword
+       For example: case: C_INDEX_BAUDRATE, to set the value from the config.ini file.
+6. In file TFT\src\User\API\Settings.h add the parameter to the SETTINGS struct for it to be available to the rest of the program and for EEPROM save/load.		
+			
+To have a parameter value changeable on the LCD Features page 		
+	             
+7. In file TFT\src\User\Menu\FeatureSettings.c         
+  Add an "SKEY" keyword in the SKEY_LIST enum in file	example: SKEY_BAUDRATE		
+ 
+8. In file TFT\src\User\API\Language\language_keywords.h  
+  Add a `LANG_KEY' and text string to file			example: LANG_KEY_NEWNAME  "label_Baudrate:"
+  				
+9. In at least One TFT\src\User\API\Language\language.h file 
+  Add a #define STRING_BAUDRATE			example: #define STRING_BAUDRATE  "Baudrate"		
+10. In file TFT\src\User\API\Language\Language.inc
+  Add an X_WORD (which becomes LABEL_name)    example: X_WORD (BAUDRATE) produces LABEL_BAUDRATE	
+	              
+11. In file TFT\src\User\Menu\FeatureSettings.c 
+  Add a line item to LISTITEM settingPage[] in the order you want to see it, for example:
+   {ICONCHAR_TOGGLE_ON,  LIST_TOGGLE,  LABEL_LASER_MODE,  LABEL_BACKGROUND} 		for an ON/OFF button	
+        {ICONCHAR_BLANK,   LIST_CUSTOMVALUE,   LABEL_SPINDLE_ROTATION,    LABEL_CW} 		for a drop down list 
+        (note: for a dropdown list you also need to define  a LABEL item array for possible list values) at top of FeatureSettings.c		
+12. Add case: SKEY_BAUDRATE to functions updateFeatureSettings() and loadFeatureSettings() to handle loading and updating of the feature. 		
+
+			
+For an Icon only		
+  1. create an X_ICON name in icon_list.inc		
+  2. Add a LANG_KEY_name and string to language_keywords.h.  ex: LANG_KEY_ICONNAME  "Baudrate:"
+  3. Add a #define STRING_NEWNAME to at least One language.h file  ex: #define STRING_BAUDRATE  "Baudrate " in language_en.h
+  4. Add an X_WORD to Language.inc which will become LABEL_   ex: X_WORD (BAUDRATE) produces LABEL_BAUDRATE		
+NOTE: After changing/adding/removing a keyword, change the CONFIG_FLASH_SIGN in Settings.h and PARA_SIGN in flashStore.c
+
+
+Notes on Debugging the BTT TFT35 using PlatformIO and STLink probe
+
+If you don't have a STLink probe, the STM32F4 discovery kit has a STLink V2 on-board and it can be configured to talk to the on-board STM32 chip or an External application board. To use the STM32F4 discovery kit as a pure STLink probe, remove the two jumpers which changes the board from Discovery to STLink mode. 
+
+
+
+Next, connect  the external target board to connector  CN2 (pinout below).
+
+
+
+
+Prepare the PlatformIO project for debugging
+
+The source code project from BigTreeTech on GitHub is downloaded as a zip file. Once unzipped, opening the folder in PlatformIO should allow you to compile without errors. However, to use a debugger, several items need to be modified in the platformio.ini file (or through the platformio project GUI):
+
+  # Add a custom board definition describing the board, mcu, flash, and RAM, etc.
+  # Copy the custom board.json file to the buildroot\boards folder (and to whichever platform folder you want in %USER%\.platformio\platforms\CHOSEN PLATFORM\boards, so it will be available to any project)
+  # Change platformio.ini settings so that a firmware.elf and firmware.bin are created
+  # Setup PlatformIO debug options
+
+Custom board creation
+
+You can skip this step if the board you're debugging is already available in PlatformIO. This wasn't the case for the BTT35 and it's STM32F207VC chip, so one must be custom made.
+
+You can start by finding an existing board that resembles your board and/or chip and use it as a base to modify.
+There was an existing json file for the STM32F207VC in the buildroot\boards folder of the downloaded GitHub project, and an existing ST-Nucleo-F207ZG board with our chip in the PlatformIO boards database, so we'll use those as a base and make a few small changes.
+
+One important note was to add the "product_line" token because a recent update to PlatformIO caused compile failures without it!
+
+Here is the STM32F207VC.json board file and the changes (some from ST-Nucleo-F207ZG) needed in yellow:
+{
+  "build": {
+    "core": "stm32",
+    "cpu": "cortex-m3",
+    "extra_flags": "-DSTM32F207xx",
+    "f_cpu": "120000000L",
+    "mcu": "stm32f207vct6",
+    "product_line": "STM32F207xx",			<- needed to compile with latest PIO updates			 
+    "variant": "stm32f2"
+    "hwids": [						<- maybe not necessary but added to identify chip
+      [
+        "0x0411",
+        "0x0002"
+      ]
+    ]			  
+  },
+  "connectivity": [
+    "can",
+    "ethernet"
+  ],
+  "debug": {
+    "default_tools": [
+      "stlink"						<- was cmsis-dap, needs to be stlink
+    ],
+    "jlink_device": "STM32F207VC",			<- make sure this is the right chip
+    "onboard_tools": [
+      "stlink"						<- was cmsis-dap, needs to be stlink
+    ],
+    "openocd_target": "stm32f2x",
+    "svd_path": "STM32F20x.svd"
+  },
+  "frameworks": [
+    "arduino",
+    "cmsis",						<- extra supported framework choice added		
+    "mbed",
+    "stm32cube",					<- tried stm32cube, but had HAL errors on compile
+    "libopencm3",					<- extra supported framework choice added
+    "zephyr"						<- extra supported framework choice added			 
+  ],
+  "name": "BTT TFT35 V3",				<- give it a new appropriate name
+  "upload": {
+    "maximum_ram_size": 49152,			<- make sure flash and ram sizes are correct!
+    "maximum_size": 262144,
+    "protocol": "stlink",				<- was cmsis-dap, needs to be stlink
+    "protocols": [
+      "jlink",
+      "stlink",
+      "blackmagic",
+      "mbed",
+      "cmsis-dap",					<- extra supported protocol added
+      "dfu"						<- extra supported protocol added
+    ]
+  },
+  "url": "http://www.st.com/content/st_com/en/products/microcontrollers/stm32-32-bit-arm-cortex-mcus/stm32f2-series/stm32f207/stm32f207vc.html",			<- updated to point to correct link for this chip
+  "vendor": "ST"
+}
+
+The above file was renamed as btt_tft35_v3.json and saved to the project buildroot\boards folder and to %USER%\.platformio\platforms\ststm32\boards and ststm32@8.0.0\boards folders.
+
+
+Making required changes to platform.ini for debugging
+
+There are a lot of sections in this file, mostly concerned with all the optional environments for each of the BTT TFT variants. We can really simply this by removing all the un-needed targets, after all we only have the TFT35 V3.0 to work on so why not?
+
+Hence we'll only look at the sections that need to be changed for stlink debugging to work.
+
+The ini file begins with section [platformio], here is defined the source folder to be compiled, the path to the boards_dir, and the default_envs to be built. In our case, the only environment we want built is BIGTREE_TFT35_V3_0, although there can be multiples.
+
+Next section is [common], use this to define keys and values that can be included into other sections by using the ${common.keyname} syntax to include them.
+
+Next is a custom section named [stm32f2xx], it defines a default_src_filter key that includes the default_src_filter from the [common] section, and adds a few more filters particular to the STM32F2xx series chips. A build_flags key is defined that includes the build_flags from the [common] section and additionally defines "__STATIC_INLINE"  for the compiler as well as including some source/library files unique to the STM32F2xx series chips.
+
+Finally we come to our defined environment section [env:BIGTREE_TFT35_V3_0]. The env: prefix denotes that this is an environment which can be chosen for the project. Here we define the platform, framework, and board that is pertinent to our system we want to debug. We also define the upload_protocol and debug_tool keys for our system. We define the src_filter and build_flag keys by expanding upon those in the [stm32f2xx] section. 
+An extra_scripts key can also be put here or in the [common] section if needed. 
+The debug_tool key is set here as stlink.
+
+
+Note: The "as received from GitHub" platformio.ini file has an extra_scripts key in the [common] section or the [env:BIGTREE_TFT35_V3_0] section. One entry is pre:buildroot/scripts/custom_filename.py which renames the normal compiler output of firmware.bin to the form "HARDWARE"."SOFTWARE_VERSION", resulting in the file BIGTREE_TFT35_V3.0.26.x.bin.  Optionally another entry  key post:buildroot/scripts/short_out_filename.py is used to shorten the filename and get rid of the ".x".
+
+Both of these entries need to be commented out so the standard compiler output will produce the files firmware.bin and firmware.elf (needed for the debugger) !
+
+
+Now let's take a closer look at the platform.ini with all the changes for debugging:
+
+[platformio]
+src_dir = TFT
+boards_dir=buildroot\boards		; use boards dir in project, comment out to use boards in core_dir
+default_envs = BIGTREE_TFT35_V3_0	; our default build environment to use
+
+[common]
+; src_filter +/- determines what files to include when building
+; use Hal/stm32f2_f4xx>, not Hal/stm32f10x, maybe better to move these to [stm32f10x], [stm32f2xx] sections
+default_src_filter = +<src/*> -<src/Libraries> -<src/User/Hal/stm32f10x> +<src/User/Hal/stm32f2_f4xx>
+build_flags = 
+	-fmax-errors=5
+	-g3				<- g3 for full debug symbols, g is normal release build
+	-ggdb
+	-Wno-missing-braces
+	-DUSE_STDPERIPH_DRIVER=
+	-ITFT/src/User/Fatfs		<-specifically tell compiler/linker to use these sources
+	-ITFT/src/User/Hal
+	-ITFT/src/User/Menu
+	-ITFT/src/User/Variants
+	-ITFT/src/User
+	-ITFT/src/User/API
+	-ITFT/src/User/API/UI
+	-ITFT/src/User/API/Gcode
+	-ITFT/src/User/API/Language
+	-ITFT/src/User/API/Vfs
+	-ITFT/src/User/Hal
+	-ITFT/src/User/Hal/STM32_USB_HOST_Library/Core/inc
+	-ITFT/src/User/Hal/STM32_USB_HOST_Library/Class/MSC/inc
+	-ITFT/src/User/Hal/STM32_USB_HOST_Library/Usr/inc
+	-ITFT/src/User/Hal/STM32_USB_OTG_Driver/inc
+	-DSOFTWARE_VERSION=26.x	<- used by custom_filename.py
+	-DSOFTWARE_VERSION_SHORT=26   <- used by short_out_filename.py
+
+extra_scripts = 
+	pre:buildroot/scripts/custom_filename.py		<- these can stay here, but we will not use them in	
+	post:buildroot/scripts/short_out_filename.py		<- our BIGTREE_TFT35_V3_0 environment, instead we
+	post:buildroot/scripts/auto_gen_language_pack.py	<- will define our own 
+
+
+
+[stm32f10x]		<- this is not used, maybe it can be deleted?
+default_src_filter = ${common.default_src_filter} +<src/Libraries/cmsis/stm32f10x> +<src/Libraries/fwlib/stm32f10x> +<src/User/Hal/stm32f10x>
+build_flags = 
+	${common.build_flags}
+	-D__STATIC_INLINE=
+	-ITFT/src/Libraries/cmsis/Core-CM3
+	-ITFT/src/Libraries/cmsis/stm32f10x
+	-ITFT/src/Libraries/fwlib/stm32f10x
+	-ITFT/src/Libraries/fwlib/stm32f10x/inc
+	-ITFT/src/User/Hal/stm32f10x
+
+[stm32f2xx]		<- we want this one
+; don't use cmsis/stm32f2xx, but use fwlib/stm32fxx and use HAL from project
+default_src_filter = ${common.default_src_filter} -<src/Libraries/cmsis/stm32f2xx> +<src/Libraries/fwlib/stm32f2xx> +<src/User/Hal/stm32f2_f4xx>
+build_flags = 
+	${common.build_flags}
+	-D__STATIC_INLINE=
+	-ITFT/src/Libraries/cmsis/Core-CM3		<-specifically tell compiler/linker to use these sources
+	-ITFT/src/Libraries/cmsis/stm32f2xx
+	-ITFT/src/Libraries/fwlib/stm32f2xx
+	-ITFT/src/Libraries/fwlib/stm32f2xx/inc
+	-ITFT/src/User/Hal/stm32f2_f4xx
+
+
+[env:BIGTREE_TFT35_V3_0]				<- our desired environment section
+build_type = debug
+debug_build_flags = -O1  - ggdb3  - g3
+debug_tool = stlink		; use stlink for debugging
+debug_load_mode = modified				; upload to target only when firmware is modified
+debug_load_cmds = 
+  set remotetimeout 120					; set target response timeout to 2 minutes
+  show remotetimeout					; display value to make sure it set
+platform = ststm32@11.0.0	; specifically use version 11.0.0
+framework = cmsis
+board = btt_tft35_v3		; custom board in buildroot\boards
+;upload_protocol = stlink				; stlink not supported by cmsis-dap, so we have to use stlink here
+upload_protocol = custom	<- define a custom protocol cause the built-in upload writes flash at 0x08000000
+upload_command =  $PROJECT_PACKAGES_DIR\tool-stm32duino\texane-stlink\st-flash write $SOURCE 0x8008000
+
+; don't include Startup folder from project, it conflicts with same files in core_dir
+src_filter = ${stm32f2xx.default_src_filter} -<src/Libraries/Startup/stm32f2xx>
+extra_scripts = 
+	;pre:buildroot/scripts/custom_filename.py   ;comment out to keep output as firmware.bin and firmware.elf
+	buildroot/scripts/stm32f2xx_0x8000_iap.py
+	;post:buildroot/scripts/bin2elf.py		<- I'm testing this to copy named.bin to named.elf instead
+build_flags = 
+	${stm32f2xx.build_flags}
+	-DSTM32F2XX=
+	-DHSE_VALUE=8000000ul
+   -DVECT_TAB_FLASH=0x08008000	<- for some reason this is ignored so we have a custom upload protocol texane-stlink with base set to 0x08008000
+	-DRAM_SIZE=48					; Available RAM size in kbytes
+	-DHARDWARE="BIGTREE_TFT35_V3.0"		<- used by custom_filename.py		
+	-DHARDWARE_SHORT="B35V30"			<- used by custom_filename.py		   
+	-DTFT35_V3_0=
+extra_scripts = 
+   pre:buildroot/scripts/custom_filename.py		; changes filenames to BIGTREE_TFT35_V3.0.26.x
+	buildroot/scripts/stm32f2xx_0x8000_iap.py		; linker script
+	post:buildroot/scripts/bin2elf.py			; names the elf file for debugger
+   ;post:buildroot/scripts/auto_gen_language_pack.py	;optional  -  rebuilds language.ini
+   
+We also need to make sure we have all the extra_scripts present in buildroot\scripts folder, so put a copy of our custom made script file bin2elf.py there. This script copies an ELF file to the output directory for debugging build with a unique filename other than firmware.bin.
+
+
+Setup PlatformIO debug options
+
+At this point you should be able to click the debug icon in PlatformIO on the left side and the debug panel will open. At the top there may be a pulldown menu with some options (see below)
+
+
+
+
+We are almost ready to Click a debug option and Run! 
+ 
+You must click the one that does not skip the Pre Debug step if you haven't built the project, or you may get a task error.
+After doing this once you should be able to run either option.
+
+You can also run by clicking the PIO bug icon to bring up project tasks. Then select a task and under the advanced tab you can do a number of things like test, check, Pre-Debug, Build, Upload, etc.
+
+If you get errors, you may have to check launch.json to get things fixed. 
+
+
+
+Appendix A: Here is the bin2elf.py script
+
+Import("env")					<- gives access to the PIO environment variables
+import shutil					<- shell utilities for the copyfile command
+def bin2elf(source, target, env):			<- defines a function call for the code below
+    print("copying firmware to ELF...")
+    firmware_name = env['PROGNAME']		<- gets the HARDWARE.VER  name i.e. BIGTREE_TFT35_V3.0.26.x
+    firmware_path = env.subst('$BUILD_DIR') + "/"  <- gets the path to the build output i.e.  pio\build\env_name    #print(firmware_name)    #print(firmware_path)
+    shutil.copyfile(firmware_path + firmware_name, firmware_path + firmware_name + ".elf")  <- copy to an .elf extension
+    print("elf file created.")
+    #env.Replace($PROGNAME="firmware_%s" % "elf" )
+env.AddPostAction("buildprog", bin2elf)		<- adds this function to the environment's PostAction list
+						    to execute a script AFTER the compile/link completes.
+						    It has to be done this way. Simply adding the script.py
+						    to the extra_scripts= keyword post: prefix (post:script.py)
+                   does run it at the end of compiler/linker, it will run before
+
+
+
+Additions/Changes for AVR128DB28 Triac Controller version	7/22  -  10/22
+
+The following M codes were added as new commands to Marlin and the TFT35
+M codes for data exchange between Marlin and TFT35 screen over UART,  direction is from the TFT point of view
+
+Mcode   	Function            	TFT SEND to Marlin        	 	Marlin RETURN to TFT       	*If CMD issued from REMOTE USB host
+-------  	--------------    	 --------------------------------------------- 	------------------------   	-------------------------------------------------
+M7900    AVRBlockInfo(-PID)   use M7900 F....                    		M7900 R           		*will echo to REMOTE SERIAL
+M7979    PID flag          	 use M7979 Sx                       		M7900 (blockinfo) 		*also echoes to REMOTE SERIAL
+M7980    RESET AVR flag          use M7980                          		none              		*will reset the AVR, echo ok only
+M7981    PID Kp,Ki,Kd      	 use M7981 Px Ix Dx                 		M7981 R           		*also echoes to REMOTE SERIAL
+M7982    AVR Display Page      use M7982 Px                       		M7900 (blockinfo) 		*will change page, echo ok only
+M7983    AVR PID speed           use M7983 Sx (0, 1, 2)            		M7900 (blockinfo) 		*will change preset, echo ok only
+M7984    AVR PID Reload         use M7984 Sx (1=current 2=default) 	M7900 (blockinfo) 		*will reload, echo ok only
+M7985    Vacuum Enable          happens via M42 P122               	see M42()         		*no response (must use M42 cmd)
+M7986    Stock Top Z-axis         from printing M7986 Rx             	M7986 Tx Zx       		*instructs Marlin to:
+                                                                                  						 R=Get Stock_Top from current Z and subtract
+                                                                                  						 probe plate thickess(value after R)
+                                                                                  						 S=Get Stock_Top from print gcode (val after S)
+                                                                                  						 (already corrected for probe thickness)
+                                                                                  						*Results echoed only to the TFT SERIAL_PORT!
+Added G code(s)
+G39	Returns the active WCS workspace from Marlin
+G39 T	Returns a table of all Workspaces (G53  -  G62) from Marlin
+
+The currently active workspace is also sent with the Temperature Auto Report at the end of the string as follows:
+The string contains Bed Temp Act/Set, Spindle Speed Act/Set, and active WCS (ignore the @:0 B@:0)
+Example:  B:25.00 /0.00 S0:0.00 /0.00 @:0 B@:0 WCS: -1
+
+A new menu for AVRTriac has been added to manage settings for PID speed control, resetting the AVR Control board, and changing the page displayed on the four line LCD on the AVR control board.
+The menu allows selecting from four PID presets, slow, normal, fast, and custom. You can only make parameter changes with the custom preset (the others can be changed in the firmware only). Any changes made will result in a prompt asking you if the changes should be save to the AVR EEPROM as the new default settings. These include PID ON/OFF state, Displayed Page, Selected PID preset, and/or any Custom PID parameter changes while in Custom preset. If you select OK, the new settings are stored and become the default at start up. If you select Cancel, no changes are saved when you exit back out of the AVRTriac Menu, and the default is restored and will be shown on re-entry to the AVRTriac Menu.
+
+(If there is a problem with I2C comm when making changes or saving them, a popup message will prompt you to Reset the AVR control to try to recover).
+
+A new feature setting was added called "Should M0 Pause". When this is turned off, incoming M0 Stops won't show an additional "pause" popup. This reduces the screen clutter by having one less prompt to answer.
+
+The arrangement of the Z-Axis homing and probing has been changed in Marlin Configuration. The Z endstop sensor is moved to the ZMAX connector on the SGEN board. The Z_HOME_DIR is changed from -1 to 1 so that the tool travels upwards to find home position. This position is Z_MAX_POS. Physically, this is 65mm up from the spoilboard, but logically it represents Home (ZERO).
+Then the Z_MIN_POS limit is -65mm to the spoilboard as the toll travels negative during a print. There is no ZMIN endstop, so we rely on software endstops to stop there. Then the configuration becomes:
+ 
+#define Z_MIN_POS -65 	//TG 9/30/2022 min travel of MPCNC (w/15.7mm tool length) just hits spoilboard (if Z Homing down use 0, Z Homing up use -65)
+#define X_MAX_POS X_BED_SIZE
+#define Y_MAX_POS Y_BED_SIZE
+#define Z_MAX_POS 0	  //TG 9/30/2022 max travel of MPCNC before rising past lower bearings (if Z Homing down use 65, Z Homing up use 0)
+
+For probing stock, the probe is connected to the ZMIN connector on the SGEN board and the probe will move from Home(ZERO) down toward the workpiece. When the probe makes contact we get the Z-position of the stock top.
+G1 Z0 or G28 Z cannot be used for probing, since they go upward in travel. We have to use G38.x to probe to target. By giving
+G38.3 Z-65 we send the probe down towards -65mm (our spoilboard surface, or Z = physical zero). When the probe triggers we capture the Z position as the top of the work surface.
+Once we have that number, we can use G54 to move to another WCS workspace in Marlin, followed by G92 Z0 will set the current Z position (our work surface top) as the new ZERO for all further operations and run the job.
+
+NOTE: During the job in WCS 0 (G54), if there is a need to switch tools and re-probe the work surface top, we must first switch back to native workspace WCS -1 (G53) and repeat the above for the new work surface position. The nc post processor will handle all of this automatically and will return the system to native workspace WCS -1 (G53) at the end of the job. Be sure to use the latest post processor in Fusion 360 which is TG MPCNC_V3_3.cps.
+
+NOTE: If the job is aborted at any point, the TFT35 will handle stopping the spindle, lifting the tool, return to X0 Y0 Z0, and return  the system to native workspace WCS -1 (G53).
+
+Additions/Changes for VFD Controller version	12/22  -  12/26
+
+The following M codes were added as new commands to Marlin and the TFT35
+M codes for data exchange between Marlin and TFT35 screen over UART,  direction is from the TFT point of view
+
+Mcode   	Function            	TFT SEND to Marlin        	 	Marlin RETURN to TFT       	*If CMD issued from REMOTE USB host
+-------  	--------------    	 --------------------------------------------- 	------------------------   	-------------------------------------------------
+M7987    VFD Status   	 none  -  Marlin sends every 2 secs           M7987  OF,SF,OC,....DP           	*will echo to REMOTE SERIAL
+M7988    VFD S/W Ver..          	 use M7988  R                       		M7988  SW,CP,BR,FT	*also echoes to REMOTE SERIAL
+M7989    VFDpresent flag         use M7980  R                        		M7989  VFD              	*will reset the AVR, echo ok only
+
+Also, modules vfd.c and vfd.h were added to support vfd functions.
+#ifdef USING_VFD_CONTROLLER was added in areas to only include vfd code if USING_VFD_CONTROLLER is defined.
+#ifdef USING_AVR_TRIAC_CONTROLLER was added in areas to only include AVRTriac code if USING_AVR_TRIAC_CONTROLLER is defined.
+These macros are used in SettingsMenu.c to select the correct Icon for KEY_ICON_5 on the settings screen.
+The following new function was added to GUI.c to provide drawing pseudo-LED widgets
+//TG 12/23/22 draw a single radio button of color with text, specify text pos as RIGHT or BOTTOM
+void RADIO_Create_Single(uint16_t sx, uint16_t sy, uint16_t color, char *text, uint16_t txtdir)  
+And lastly, a new icon was created for VFD Control.    
diff --git a/TGextra/MY_LPC1769(old).cfg b/TGextra/MY_LPC1769(old).cfg
new file mode 100644
index 0000000000..7d45150b8c
--- /dev/null
+++ b/TGextra/MY_LPC1769(old).cfg
@@ -0,0 +1,269 @@
+#**************************************************************************************
+# TG modified for working with LPC1769 on MKS SGEN V1.0 board  1/27/20
+#
+# This config can be used for openocd when running platformio debug or upload.
+# If you want different actions for one or the other you will have to insert
+# some conditional coding in the "commands to run" area below.
+#
+#**************************************************************************************
+
+# set this 0=no echo  1=echo
+set _ECHO 1  
+
+# define unique values for the LPC1769
+set CPURAMSIZE 0x10000
+set CPUROMSIZE 0x80000
+set CHIPNAME lpc17xx
+set CHIPSERIES lpc1700
+#For the LPC1769, the TAP ID value is 0x2BA00477.
+#set CPUTAPID 0x4ba00477		
+set CPUTAPID 0x2ba01477
+#CCLK is also set to 4000 khz in the lpc1xxx cfg file later if not set here
+set CCLK 12000
+
+# check for variables sent from the calling task
+#****************************************************************************
+#**********     Check for variables sent from the calling task     **********
+#****************************************************************************
+# FIRMWARENAME is added at the UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+# if task is Debug, then it is added from the debug_server flags in Platformio.ini (but has .elf extension)
+if { [info exists FIRMWARENAME] } {
+	set _IMAGEFILE $FIRMWARENAME
+	} else {
+	error "FIRMWARENAME not set"
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: FIRMWARENAME received: $_IMAGEFILE"}
+
+# if extension is .elf, change it to .bin
+if { [string first .elf $_IMAGEFILE] > 0} {
+	set _noext [string trimright $_IMAGEFILE elf]
+	set _IMAGEFILE [append _noext bin]
+if {$_ECHO} {echo "MY_LPC1769.CFG: FIRMWARENAME renamed to: $_IMAGEFILE"}
+}
+
+# LOADADDRESS is added from the debug_server flags in Platformio.ini in Debug task
+# if task is Upload, it's added via UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+# note: changing the load adress requires modifying the VTOR at address 0xE000ED08 at bits [29:8] (1st 8 bits{7:0] are reserved)
+if { [info exists LOADADDRESS] } {
+	set _LOADADDRESS $LOADADDRESS
+} else {
+    set _LOADADDRESS 0x00000000
+	if {$_ECHO} {echo "MY_LPC1769.CFG: LOADADDRESS not given...defaulting to 0x00000000"}
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: LOADADDRESS received: $_LOADADDRESS"}
+
+# CALLER is added from the debug_server flags in Platformio.ini in Debug and Upload tasks
+# if task is Upload, it's added via UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+if { [info exists CALLER] } {
+	set _CALLER $CALLER
+} else {
+    set _CALLER UNKNOWN
+	error "MY_LPC1769.CFG: CALLER not set in Platformio.ini under debug_server or upload_flags"
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: CALLER received: $_CALLER"}
+
+#****************************************************************************
+#**********  End of Check for variables sent from the calling task  *********
+#****************************************************************************
+
+
+
+#include the interface file for the target, stlink (for STM32F) or cmsis-dap (for LPC17xx)
+if {$_ECHO} {echo "MY_LPC1769.CFG: loading interface/stlink.cfg]"}
+#source [find interface/stlink.cfg] 
+source [find interface/cmsis-dap.cfg]
+
+#for NXP 17xx MCU-Link use this
+set _TRANSPORT swd
+
+#for STM32 ST-Link use one of these
+#set _TRANSPORT hla_swd
+
+transport select $_TRANSPORT
+
+#Include the main configuration file for the target
+if {$_ECHO} {echo "MY_LPC1769.CFG: loading target/lpc17xx.cfg]"}
+source [find target/lpc17xx.cfg]
+
+adapter speed 4000
+#delays on reset line
+adapter srst delay 200
+
+
+#gdb_memory_map enable
+#gdb_breakpoint_override hard 
+#init
+#cortex_m maskisr steponly
+
+ 
+#****************************************************************************
+#********** Procedures that can be called to simplify some actions **********
+#****************************************************************************
+# Magic to work with any targets, including semi-functional
+global _ERASE_CALLED 0
+set _ERASE_CALLED 0
+proc prepare_target { } {
+    global _ECHO
+    if {$_ECHO} {echo "MY_LPC1769.CFG: initialze target....."}
+	init
+    catch {reset init}
+    #catch {halt}
+}
+# unlock was in here but not supported on stlink
+proc erase_part { start_sector end_sector } {
+    global _ERASE_CALLED
+	global _ECHO
+	if {$_ECHO} {echo "MY_LPC1769.CFG: erase target....."}
+    flash erase_sector 0 $start_sector $end_sector
+	flash erase_check 0
+    if {$_ECHO} {echo "MY_LPC1769.CFG: erase complete....."}
+    set _ERASE_CALLED 1	
+}
+proc dump_part { filename start_adr } {
+    global _ECHO
+    if {$_ECHO} {echo "MY_LPC1769.CFG: dumping target....."}
+	dump_image $filename $start_adr $start_adr
+}
+proc flash_part { filename start_adr } {
+    global _ERASE_CALLED
+	global _ECHO
+	if { !$_ERASE_CALLED } {
+		erase_part 0 29
+	}
+    if {$_ECHO} {echo "MY_LPC1769.CFG: flashing target....."}
+	set result [catch {flash write_image $filename $start_adr bin}] 
+	if {$result != 0} {
+	  error "MY_LPC1769.CFG: Houston - we have a problem - flashing failed!"
+	} else { 
+		if {$_ECHO} {echo "MY_LPC1769.CFG: flashing complete!"} 
+		set _ERASE_CALLED 0
+	}
+	mww 0x400FC040 0x01
+}
+proc verify_flash { filename offset} { 
+   global _ECHO
+   verify_image $filename $offset
+}
+proc eraser {} { 
+   global _ECHO
+   #unlock
+   if {$_ECHO} {echo "MY_LPC1769.CFG: erase target....."}
+   flash erase_sector 0 0 5
+   if {$_ECHO} {echo "MY_LPC1769.CFG: checking if erased....."}
+   flash erase_check 0
+}
+proc unlock {} {
+	global _ECHO
+	if {$_ECHO} {echo "MY_LPC1769.CFG: attempting to unlock flash....."}
+	flash protect 0 0 last off
+}
+
+
+#****************************************************************************
+#****************************************************************************
+#*********  TEST AREA for customized GDB events  ****************************
+#****************************************************************************
+#****************************************************************************
+proc my_GDB_flash_erase_start { } {echo "*****GDB erashing flash.."}
+$CHIPNAME.cpu configure -event gdb-flash-erase-start my_GDB_flash_erase_start
+
+proc my_GDB_flash_erase_end { } {echo "*****GDB erashing done.."}
+$CHIPNAME.cpu configure -event gdb-flash-erase-end my_GDB_flash_erase_end
+
+proc my_GDB_flash_write_start { } {echo "*****GDB writing flash.."}
+$CHIPNAME.cpu configure -event gdb-flash-write-start my_GDB_flash_write_start
+
+proc my_GDB_flash_write_end { } {echo "\n*****GDB writing done.."}
+$CHIPNAME.cpu configure -event gdb-flash-write-end my_GDB_flash_write_end
+
+proc my_GDB_step_start { } {echo "*****GDB stepping start.."}
+$CHIPNAME.cpu configure -event step-start my_GDB_step_start
+
+proc my_GDB_step_end { } {echo "*****GDB stepping end.."}
+$CHIPNAME.cpu configure -event step-end my_GDB_step_end
+
+proc my_GDB_debug_halted { } {echo -n "h"}
+$CHIPNAME.cpu configure -event debug-halted my_GDB_debug_halted
+
+proc my_GDB_debug_resumed { } {echo -n "r"}
+$CHIPNAME.cpu configure -event debug-resumed my_GDB_debug_resumed
+
+proc my_GDB_halted { } {echo "*****GDB target halted"}
+$CHIPNAME.cpu configure -event halted my_GDB_halted
+
+proc my_GDB_resumed { } {echo "*****GDB target resumed"}
+$CHIPNAME.cpu configure -event resumed my_GDB_resumed
+
+
+
+
+
+#****************************************************************************
+#****************************************************************************
+#***** commands to run area (in order of preference - choose only one!) *****
+#****************************************************************************
+#****************************************************************************
+
+#for either UPLOAD or DEBUG process we must call "init and reset-init" before
+#any other reset commands will work
+# for the UPLOAD process we need to program the flash and shutdown
+if {[string equal $_CALLER UPLOAD]} {
+	# do the init / reset-init / reset-halt sequence as first step
+	prepare_target
+	after 100
+	#------- #1 try program command method (highest level code) -----------------
+	# the program command does init/reset init/flash_write_image to erase & write
+	# to flash/verify if specified/and reset run if reset specified
+	if {$_ECHO} {echo "MY_LPC1769.CFG: run program command"}
+	program $_IMAGEFILE verify reset $_LOADADDRESS
+	if {$_ECHO} {echo "MY_LPC1769.CFG: end program command"}
+
+	#comment out shutdown if you want to keep openocd running to use Telnet to interact
+	if {$_ECHO} {echo "MY_LPC1769.CFG: reset-run and shutdown"}
+	reset run
+	shutdown	 
+	}
+
+# for the DEBUG process let GDB do the uploading, note: gdb_flash_program must precede init
+# cortex_m command must come after init
+if {[string equal $_CALLER DEBUG]} {
+	if {$_ECHO} {echo "MY_LPC1769.CFG: setting gdb_ options"}
+	gdb_flash_program enable
+	gdb_memory_map enable
+	gdb_breakpoint_override hard 
+	prepare_target
+	#this can be auto or steponly
+	cortex_m maskisr auto 
+	if {$_ECHO} {echo "MY_LPC1769.CFG: set gdb_flash_program enable"}
+	if {$_ECHO} {echo "MY_LPC1769.CFG: debug - reset-halt"}
+	reset halt
+}
+
+
+
+# These are other methods that can be used to program the flash
+#------- #2 THIS method works too (intermediate calls proc's above) ---------
+#flash_part $_IMAGEFILE $_LOADADDRESS
+#verify_flash $_IMAGEFILE $_LOADADDRESS
+#if {$_ECHO} {echo "MY_LPC1769.CFG: reset-init target for User Mode vectors"}
+#reset init
+#reset run
+
+#------- #3 try init/reset/flash write method (lowest level calls) ----------
+#if {$_ECHO} {echo "MY_LPC1769.CFG: Sending command: init"}
+#init
+#if {$_ECHO} {echo "MY_LPC1769.CFG: Sending command: reset init"}
+#reset init   
+#if {$_ECHO} {echo "MY_LPC1769.CFG: Sending command: flash write_image erase $_IMAGEFILE $_LOADADDRESS bin"}
+#flash erase_sector 0 0 29
+#flash write_image $_IMAGEFILE $_LOADADDRESS bin
+
+#---------- reset option and shutdown methods -----------
+#if {$_ECHO} {echo "MY_LPC1769.CFG: reset-init target for User Mode vectors"}
+# always do reset-init, but check if DEBUG or UPLOAD for next actions
+#reset init
+
+
+#****************************************************************************
+#********** end commands to run area ****************************************
+#****************************************************************************
\ No newline at end of file
diff --git a/TGextra/MY_LPC1769.cfg b/TGextra/MY_LPC1769.cfg
new file mode 100644
index 0000000000..5e07513138
--- /dev/null
+++ b/TGextra/MY_LPC1769.cfg
@@ -0,0 +1,320 @@
+#**************************************************************************************
+# TG modified for working with LPC1769 on MKS SGEN V1.0 board  1/27/20
+#
+# This config can be used for openocd when running platformio debug or upload.
+# If you want different actions for one or the other you will have to insert
+# some conditional coding in the "commands to run" area below.
+#
+#**************************************************************************************
+
+#**************************************
+#***** set this 0=no echo  1=echo *****
+set _ECHO 0  
+
+# define unique values for the LPC1769
+set CPURAMSIZE 0x10000
+set CPUROMSIZE 0x80000
+set CHIPNAME lpc17xx
+set CHIPSERIES lpc1700
+#For the LPC1769, the TAP ID value is 0x2BA00477.
+#set CPUTAPID 0x4ba00477		
+set CPUTAPID 0x2ba01477
+#CCLK is also set to 4000 khz in the lpc1xxx cfg file later if not set here
+set CCLK 4000
+
+# check for variables sent from the calling PlatformIO task
+#****************************************************************************
+#**********     Check for variables sent from the calling task     **********
+#****************************************************************************
+# FIRMWARENAME is added at the UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+# if task is Debug, then it is added from the debug_server flags in Platformio.ini (but has .elf extension)
+if { [info exists FIRMWARENAME] } {
+	set _IMAGEFILE $FIRMWARENAME
+	} else {
+	error "FIRMWARENAME not set"
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: FIRMWARENAME received: $_IMAGEFILE"}
+
+# if extension is .elf, change it to .bin
+if { [string first .elf $_IMAGEFILE] > 0} {
+	set _noext [string trimright $_IMAGEFILE elf]
+	set _IMAGEFILE [append _noext bin]
+if {$_ECHO} {echo "MY_LPC1769.CFG: FIRMWARENAME renamed to: $_IMAGEFILE"}
+}
+
+# LOADADDRESS is added from the debug_server flags in Platformio.ini in Debug task
+# if task is Upload, it's added via UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+# note: changing the load adress requires modifying the VTOR at address 0xE000ED08 at bits [29:8] (1st 8 bits{7:0] are reserved)
+if { [info exists LOADADDRESS] } {
+	set _LOADADDRESS $LOADADDRESS
+} else {
+    set _LOADADDRESS 0x00000000
+	if {$_ECHO} {echo "MY_LPC1769.CFG: LOADADDRESS not given...defaulting to 0x00000000"}
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: LOADADDRESS received: $_LOADADDRESS"}
+
+# CALLER is added from the debug_server flags in Platformio.ini in Debug and Upload tasks
+# if task is Upload, it's added via UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+if { [info exists CALLER] } {
+	set _CALLER $CALLER
+} else {
+    set _CALLER UNKNOWN
+	error "MY_LPC1769.CFG: CALLER not set in Platformio.ini under debug_server or upload_flags"
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: CALLER received: $_CALLER"}
+
+# PROGRAMMER is added from the debug_server flags in Platformio.ini in Debug task
+# if task is Upload, it's added via UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+if { [info exists PROGRAMMER] } {
+	set _PROGRAMMER $PROGRAMMER
+} else {
+    set _PROGRAMMER STLINK
+	if {$_ECHO} {echo "MY_LPC1769.CFG: PROGRAMMER not given...defaulting to STLINK"}
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: PROGRAMMER received: $_PROGRAMMER"}
+
+# PROG_DEVICE is added from the debug_server flags in Platformio.ini in Debug task
+# if task is Upload, it's added via UPLOADER command string in the extra_scripts "lpc17xx_helper.py" file in Platformio.ini
+if { [info exists PROG_DEVICE] } {
+	set _PROG_DEVICE $PROG_DEVICE
+} else {
+    set _PROG_DEVICE STLINK_DISCO
+	if {$_ECHO} {echo "MY_LPC1769.CFG: PROG_DEVICE not given...defaulting to STLINK_DISCO"}
+}
+if {$_ECHO} {echo "MY_LPC1769.CFG: PROG_DEVICE received: $_PROG_DEVICE"}
+
+
+#****************************************************************************
+#**********  End of Check for variables sent from the calling task  *********
+#****************************************************************************
+
+
+#****************************************************************************
+#*****  Check which PROGRAMMER Interface and PROGRAMMER device to use  ******
+#****************************************************************************
+
+if {[string equal MCULINK $_PROGRAMMER] > 0} {set _GOT_MCULINK 1} else {set _GOT_MCULINK 0}
+if {[string equal STLINK $_PROGRAMMER] > 0} {set _GOT_STLINK 1} else {set _GOT_STLINK 0}
+
+echo "MY_LPC1769.CFG: MCULINK $_GOT_MCULINK"
+echo "MY_LPC1769.CFG: STLINK $_GOT_STLINK"
+
+#include the interface file for the target, stlink (for STM32F) or cmsis-dap (for LPC17xx)
+if {$_GOT_MCULINK} {set _INTERFACE cmsis-dap.cfg}
+if {$_GOT_STLINK} {set _INTERFACE stlink.cfg}
+if {$_ECHO} {echo "MY_LPC1769.CFG: loading interface/$_INTERFACE"}
+source [find interface/$_INTERFACE] 
+
+#for NXP MCU-Link use this
+if {$_GOT_MCULINK} {set _TRANSPORT swd}
+#for STM32 ST-Link use this
+if {$_GOT_STLINK} {
+  echo -n "MY_LPC1769.CFG: Using $_PROGRAMMER interface and $_PROG_DEVICE device serial# "
+  set _TRANSPORT hla_swd
+  transport select $_TRANSPORT
+
+  #The STM32F429 Discovery board
+  if {[string equal STLINK_DISCO $_PROG_DEVICE] > 0} {
+    hla_serial "\x50\xff\x76\x06\x50\x66\x50\x51\x48\x22\x18\x87"
+	echo "50ff76065066505148221887"
+  }
+
+  #The Black STLink adapter
+  if {[string equal STLINK_BLACK $_PROG_DEVICE] > 0} {
+    hla_serial "\x54\x00\x58\x00\x04\x00\x00\x31\x50\x37\x50\x4e"
+    echo "54005800040000315037504e"
+  }
+	
+  #The Copper STLink adapter
+  if {[string equal STLINK_COPPER $_PROG_DEVICE] > 0} {
+    hla_serial "\x2d\x35\x0b\x00\x2c\x13\x57\x37\x33\x4d\x4e\x00"
+    echo "2d350b002c135737334d4e00"
+  }
+}
+
+#Include the main configuration file for the target
+if {$_ECHO} {echo "MY_LPC1769.CFG: loading target/lpc17xx.cfg]"}
+source [find target/lpc17xx.cfg]
+
+adapter speed 7000
+#delays on reset line
+adapter srst delay 100
+
+#gdb_memory_map enable
+#gdb_breakpoint_override hard 
+#init
+#cortex_m maskisr steponly
+
+ 
+#****************************************************************************
+#********** Procedures that can be called to simplify some actions **********
+#****************************************************************************
+# Magic to work with any targets, including semi-functional
+global _ERASE_CALLED 0
+set _ERASE_CALLED 0
+proc prepare_target { } {
+    global _ECHO
+    if {$_ECHO} {echo "MY_LPC1769.CFG: initialze target....."}
+	init
+    catch {reset init}
+    #catch {halt}
+}
+# unlock was in here but not supported on stlink
+proc erase_part { start_sector end_sector } {
+    global _ERASE_CALLED
+	global _ECHO
+	if {$_ECHO} {echo "MY_LPC1769.CFG: erase target....."}
+    flash erase_sector 0 $start_sector $end_sector
+	flash erase_check 0
+    if {$_ECHO} {echo "MY_LPC1769.CFG: erase complete....."}
+    set _ERASE_CALLED 1	
+}
+proc dump_part { filename start_adr } {
+    global _ECHO
+    if {$_ECHO} {echo "MY_LPC1769.CFG: dumping target....."}
+	dump_image $filename $start_adr $start_adr
+}
+proc flash_part { filename start_adr } {
+    global _ERASE_CALLED
+	global _ECHO
+	if { !$_ERASE_CALLED } {
+		erase_part 0 29
+	}
+    if {$_ECHO} {echo "MY_LPC1769.CFG: flashing target....."}
+	set result [catch {flash write_image $filename $start_adr bin}] 
+	if {$result != 0} {
+	  error "MY_LPC1769.CFG: Houston - we have a problem - flashing failed!"
+	} else { 
+		if {$_ECHO} {echo "MY_LPC1769.CFG: flashing complete!"} 
+		set _ERASE_CALLED 0
+	}
+	mww 0x400FC040 0x01
+}
+proc verify_flash { filename offset} { 
+   global _ECHO
+   verify_image $filename $offset
+}
+proc eraser {} { 
+   global _ECHO
+   #unlock
+   if {$_ECHO} {echo "MY_LPC1769.CFG: erase target....."}
+   flash erase_sector 0 0 5
+   if {$_ECHO} {echo "MY_LPC1769.CFG: checking if erased....."}
+   flash erase_check 0
+}
+proc unlock {} {
+	global _ECHO
+	if {$_ECHO} {echo "MY_LPC1769.CFG: attempting to unlock flash....."}
+	flash protect 0 0 last off
+}
+
+
+#****************************************************************************
+#****************************************************************************
+#*********  TEST AREA for customized GDB events  ****************************
+#****************************************************************************
+#****************************************************************************
+proc my_GDB_flash_erase_start { } {echo "*****GDB erasing flash.."}
+$CHIPNAME.cpu configure -event gdb-flash-erase-start my_GDB_flash_erase_start
+
+proc my_GDB_flash_erase_end { } {global _ECHO  if {$_ECHO} {echo "*****GDB erasing done.."}}
+$CHIPNAME.cpu configure -event gdb-flash-erase-end my_GDB_flash_erase_end
+
+proc my_GDB_flash_write_start { } {echo "*****GDB writing flash.."}
+$CHIPNAME.cpu configure -event gdb-flash-write-start my_GDB_flash_write_start
+
+proc my_GDB_flash_write_end { } {global _ECHO  if {$_ECHO} {echo "\n*****GDB writing done.."}}
+$CHIPNAME.cpu configure -event gdb-flash-write-end my_GDB_flash_write_end
+
+#proc my_GDB_step_start { } {echo "*****GDB stepping start.."}
+#$CHIPNAME.cpu configure -event step-start my_GDB_step_start
+
+#proc my_GDB_step_end { } {echo "*****GDB stepping end.."}
+#$CHIPNAME.cpu configure -event step-end my_GDB_step_end
+
+proc my_GDB_debug_halted { } {global _ECHO  if {$_ECHO} {echo -n "h"}}
+#$CHIPNAME.cpu configure -event debug-halted my_GDB_debug_halted
+
+proc my_GDB_debug_resumed { } {global _ECHO  if {$_ECHO} {echo -n "r"}}
+#$CHIPNAME.cpu configure -event debug-resumed my_GDB_debug_resumed
+
+proc my_GDB_halted { } {echo "*****GDB target stopped"}
+#$CHIPNAME.cpu configure -event halted my_GDB_halted
+
+proc my_GDB_resumed { } {echo "*****GDB target running"}
+#$CHIPNAME.cpu configure -event resumed my_GDB_resumed
+
+
+
+
+
+#****************************************************************************
+#****************************************************************************
+#***** commands to run area (in order of preference - choose only one!) *****
+#****************************************************************************
+#****************************************************************************
+
+#for either UPLOAD or DEBUG process we must call "init and reset-init" before
+#any other reset commands will work
+# for the UPLOAD process we need to program the flash and shutdown
+if {[string equal $_CALLER UPLOAD]} {
+	# do the init / reset-init / reset-halt sequence as first step
+	prepare_target
+	after 100
+	#------- #1 try program command method (highest level code) -----------------
+	# the program command does init/reset init/flash_write_image to erase & write
+	# to flash/verify if specified/and reset run if reset specified
+	if {$_ECHO} {echo "MY_LPC1769.CFG: run program command"}
+	program $_IMAGEFILE verify reset $_LOADADDRESS
+	if {$_ECHO} {echo "MY_LPC1769.CFG: end program command"}
+
+	#comment out shutdown if you want to keep openocd running to use Telnet to interact
+	if {$_ECHO} {echo "MY_LPC1769.CFG: reset-run and shutdown"}
+	reset run
+	shutdown	 
+	}
+
+# for the DEBUG process let GDB do the uploading, note: gdb_flash_program must precede init
+# cortex_m command must come after init
+if {[string equal $_CALLER DEBUG]} {
+	if {$_ECHO} {echo "MY_LPC1769.CFG: setting gdb_ options"}
+	gdb_flash_program enable
+	gdb_memory_map enable
+	#gdb_breakpoint_override hard 
+	prepare_target
+    set CCLK 120000000
+	#this can be auto or steponly, but can't be used with stlink interface
+	#cortex_m maskisr auto 
+	if {$_ECHO} {echo "MY_LPC1769.CFG: set gdb_flash_program enable"}
+	if {$_ECHO} {echo "MY_LPC1769.CFG: debug - reset-halt"}
+	reset halt
+}
+
+
+
+# These are other methods that can be used to program the flash
+#------- #2 THIS method works too (intermediate calls proc's above) ---------
+#flash_part $_IMAGEFILE $_LOADADDRESS
+#verify_flash $_IMAGEFILE $_LOADADDRESS
+#if {$_ECHO} {echo "MY_LPC1769.CFG: reset-init target for User Mode vectors"}
+#reset init
+#reset run
+
+#------- #3 try init/reset/flash write method (lowest level calls) ----------
+#if {$_ECHO} {echo "MY_LPC1769.CFG: Sending command: init"}
+#init
+#if {$_ECHO} {echo "MY_LPC1769.CFG: Sending command: reset init"}
+#reset init   
+#if {$_ECHO} {echo "MY_LPC1769.CFG: Sending command: flash write_image erase $_IMAGEFILE $_LOADADDRESS bin"}
+#flash erase_sector 0 0 29
+#flash write_image $_IMAGEFILE $_LOADADDRESS bin
+
+#---------- reset option and shutdown methods -----------
+#if {$_ECHO} {echo "MY_LPC1769.CFG: reset-init target for User Mode vectors"}
+# always do reset-init, but check if DEBUG or UPLOAD for next actions
+#reset init
+
+
+#****************************************************************************
+#********** end commands to run area ****************************************
+#****************************************************************************
\ No newline at end of file
diff --git a/TGextra/MY_LPC17xx_helper.py b/TGextra/MY_LPC17xx_helper.py
new file mode 100644
index 0000000000..ffca28aed0
--- /dev/null
+++ b/TGextra/MY_LPC17xx_helper.py
@@ -0,0 +1,117 @@
+# Custom helper for LPC17XX series chips by TG 1/26/20
+# creates variable FIRMWARENAME, LOADADDRESS, and CALLER variables for use by config
+# files to get env info when called by PIO Upload task (debug task doesn't need help).
+# Also calculates checksum needed from the first 7 words of flash and puts it in the
+# seventh word. LPC chips validate this checksum and won't run the user code if it is wrong.
+# This checksum is added to the .bin and .elf files.
+
+
+Import("env")
+
+# get any py modules that are needed if not already present
+try:
+ import sys
+except:
+ env.Execute("$PYTHONEXE -m pip install sys")
+try:
+ import struct
+except:
+ env.Execute("$PYTHONEXE -m pip install struct")
+try:
+ import argparse
+except:
+ env.Execute("$PYTHONEXE -m pip install argparse")
+try:
+ import intelhex
+except:
+ env.Execute("$PYTHONEXE -m pip install intelhex")
+try:
+ import os.path
+except:
+ env.Execute("$PYTHONEXE -m pip install os.path")
+
+# this allows reading the upload flags and appending all of them to the openocd invocation command
+# note: setting 'upload_command=openocd' and 'upload_flags= (optional commands, etc) in platformio.ini
+# doesn't call openocd correctly, the upload_flags are NOT added unless we do this here as workaround!
+#env.Prepend(UPLOADERFLAGS=["-c", "set FIRMWARENAME {$PROJECT_DIR\$SOURCE}"])  #want this done early!
+env.Replace(
+    UPLOADER="$PROJECT_PACKAGES_DIR\\tool-openocd\\bin\\openocd",
+    UPLOADCMD="$UPLOADER $UPLOADERFLAGS"
+)
+
+#start of the LPC checksum calc needed for all LPC1700 parts to run loaded program correctly.
+"""
+Calculate checksum image for LPC firmware images and write. Code is a Python port of the C version
+written by Roel Verdult named `lpcrc'. The checksum is the two's-complement of the sum of the first
+seven 4-byte blocks (w.r.t the start address). This value is placed in the eight block.
+The checksum is written back to the file and is returned. When read_only is set to True,
+the file will not be changed.
+
+filename  -- firmware file to checksum
+format    -- (optional) input file format (bin or hex, doesn't matter hsndles both bin and elf)
+read_only -- (optional) whether to write checksum back to the file (default False)
+"""
+
+def start_checksum(source, target, env):
+                 
+    #get the name of the output file
+    #print("lpc17xx_helper.py: Calculating lpc_checksum.................")
+    firmware_path = env.subst('$BUILD_DIR') + "\\"
+        
+    #patch the bin file first
+    print ("")
+    shortfilename = env.get("PROGNAME") + ".bin"
+    filename = firmware_path + shortfilename
+    if os.path.isfile(filename):
+        (checksum(filename,shortfilename,"bin"))
+    
+    #now patch the elf file
+    shortfilename = env.get("PROGNAME") + ".elf"
+    filename = firmware_path + shortfilename
+    #if os.path.isfile(filename):
+    #    (checksum(filename,shortfilename,"bin"))
+    
+    print ("")
+
+def checksum(filename, shortfilename, format="bin", read_only=False):
+    BLOCK_COUNT = 7
+    BLOCK_SIZE = 4
+    BLOCK_TOTAL = (BLOCK_COUNT * BLOCK_SIZE)
+    
+    # Open the firmware file.
+    handle = intelhex.IntelHex()
+    handle.loadfile(filename, format=format)
+    
+    #bin file code starts at 0x00000000
+    block_start = handle.minaddr() 
+    #elf file code starts at 0x00010000
+    if "elf" in filename:
+        block_start = block_start + 0x00010000
+
+    # Read the data blocks used for checksum calculation.
+    block = bytearray(handle.gets(block_start, BLOCK_TOTAL))
+
+    if len(block) != BLOCK_TOTAL:
+        raise Exception("lpc17xx_helper.py: Could not read the required number of bytes.")
+
+    # Compute the checksum value.
+    result = 0
+    for i in range(BLOCK_COUNT):
+        value, = struct.unpack_from("I", block, i * BLOCK_SIZE)
+        result = (result + value) & 0xFFFFFFFF                  # add up the first 7 vectors in interrupt table @0x00000000
+
+    result = ((~result) + 1) & 0xFFFFFFFF                       # form two's complement
+
+    # Write checksum back to the file.
+    if not read_only:
+        handle.puts(block_start + BLOCK_TOTAL, struct.pack("I", result))
+        handle.tofile(filename, format=format)
+
+    print("lpc17xx_helper.py: Succesfully updated " + shortfilename + " checksum to 0x{0:X}".format(result))
+    #print(" checksum to 0x%08x \n" % result)
+    # Done
+    return result
+
+# add the desired actions to the appropriate tasks here
+env.AddPostAction("buildprog", start_checksum)  # make sure this calls after the build finishes (.bin file must be present first!)
+env.AddPreAction("upload", start_checksum)      # make sure this calls before any upload begins
\ No newline at end of file
diff --git a/TGextra/__SETUP OF PLATFORMIO.INI and VSCODE FOLDER.txt b/TGextra/__SETUP OF PLATFORMIO.INI and VSCODE FOLDER.txt
new file mode 100644
index 0000000000..ebca7cec45
--- /dev/null
+++ b/TGextra/__SETUP OF PLATFORMIO.INI and VSCODE FOLDER.txt	
@@ -0,0 +1,18 @@
+To have consistent successful compile and debug of a Marlin Project do the following:
+
+in c_cpp_properties.json make sure the libdeps folder is envname_DEBUG and not RELEASE, as below
+
+"c:/Users/tony/Documents/CNC/MAINBOARD/MKS-SGEN/Marlin-2.0.9.2-100321-SGEN/.pio/libdeps/LPC1769_DEBUG/U8glib-HAL/src"
+
+in launch.json make sure the executable and projectEnvName properties are also envname_DEBUG and not RELEASE, as below
+
+"executable": "c:/Users/tony/Documents/CNC/MAINBOARD/MKS-SGEN/Marlin-2.0.9.2-100321-SGEN/.pio/build/LPC1769_DEBUG/firmware.elf",
+"projectEnvName": "LPC1769_DEBUG",
+
+Also, be sure to have modified Marlin\buildroot\share\PlatformIO\scripts\common-cxxflags.py for the /debug folder fix!
+
+
+For release binary build as RELEASE
+For Debug outputs build as DEBUG
+
+Use the RUN> PIO Debug toolbar to debug a connected target (NOTE: any previous .pio\build\envname_RELEASE folder will be deleted) 
\ No newline at end of file
diff --git a/TGextra/bin2elf.py b/TGextra/bin2elf.py
new file mode 100644
index 0000000000..25e321bce0
--- /dev/null
+++ b/TGextra/bin2elf.py
@@ -0,0 +1,16 @@
+Import("env")
+import shutil
+
+def elf2bin(source, target, env):
+ print("copying ELF to BIN................................................")
+ 
+ firmware_name = env['PROGNAME']
+ firmware_path = env.subst('$BUILD_DIR') + "\\"
+ #print(firmware_name)
+ #print(firmware_path)
+ shutil.copyfile(firmware_path + firmware_name + ".elf", firmware_path + firmware_name + ".bin")
+ print("bin file created.")
+ #env.Replace($PROGNAME="firmware_%s" % "elf" )
+
+env.AddPostAction("$BUILD_DIR/${PROGNAME}.elf", elf2bin)
+env.AddPreAction("upload", elf2bin) # added to make .elf file before uploading when only running upload
\ No newline at end of file
diff --git a/TGextra/common-cxxflags.py b/TGextra/common-cxxflags.py
new file mode 100644
index 0000000000..031394e3cc
--- /dev/null
+++ b/TGextra/common-cxxflags.py
@@ -0,0 +1,34 @@
+#
+# common-cxxflags.py
+# Convenience script to apply customizations to CPP flags
+#
+Import("env")
+env.Append(CXXFLAGS=[
+  "-Wno-register"
+  #"-Wno-incompatible-pointer-types",
+  #"-Wno-unused-const-variable",
+  #"-Wno-maybe-uninitialized",
+  #"-Wno-sign-compare"
+])
+
+#
+# Add CPU frequency as a compile time constant instead of a runtime variable
+#
+def add_cpu_freq():
+	if 'BOARD_F_CPU' in env:
+		env['BUILD_FLAGS'].append('-DBOARD_F_CPU=' + env['BOARD_F_CPU'])
+
+# Useful for JTAG debugging
+#
+# It will separate release and debug build folders.
+# It useful to keep two live versions: a debug version for debugging and another for
+# release, for flashing when upload is not done automatically by jlink/stlink.
+# Without this, PIO needs to recompile everything twice for any small change.
+if env.GetBuildType() == "debug" and env.get('UPLOAD_PROTOCOL') not in ['jlink', 'stlink','custom']:  
+	env['BUILD_DIR'] = '$PROJECT_BUILD_DIR/$PIOENV/debug'  #TG added 'custom' to fix /debug folder issues
+
+# On some platform, F_CPU is a runtime variable. Since it's used to convert from ns
+# to CPU cycles, this adds overhead preventing small delay (in the order of less than
+# 30 cycles) to be generated correctly. By using a compile time constant instead
+# the compiler will perform the computation and this overhead will be avoided
+add_cpu_freq()
diff --git a/TGextra/dump_env.py b/TGextra/dump_env.py
new file mode 100644
index 0000000000..f2da050235
--- /dev/null
+++ b/TGextra/dump_env.py
@@ -0,0 +1,17 @@
+Import("env")
+print("RUNNING EXTRA SCRIPT")
+#print(env.Dump())
+build_flags = env.ParseFlags(env['BUILD_FLAGS'])
+#print(env.get("PROGNAME"))
+filename = env.get("PROGNAME") + env.get("PROGSUFFIX")
+filetype = env.get("PROGSUFFIX").lstrip(".")
+print(filename)
+print(filetype)
+# this allows reading the upload flags and appending all to the openocd invocation
+# putting the openocd as upload_command and items in upload_flags doesn't call
+# openocd correctly, the upload_flags are NOT added unless we do this here as workaround
+env.Replace(
+    UPLOADER="$PROJECT_PACKAGES_DIR\\tool-openocd\\bin\\openocd",
+    UPLOADCMD="$UPLOADER $UPLOADERFLAGS"
+)
+print(env.Dump())
\ No newline at end of file
diff --git a/TGextra/elf2bin.py b/TGextra/elf2bin.py
new file mode 100644
index 0000000000..25e321bce0
--- /dev/null
+++ b/TGextra/elf2bin.py
@@ -0,0 +1,16 @@
+Import("env")
+import shutil
+
+def elf2bin(source, target, env):
+ print("copying ELF to BIN................................................")
+ 
+ firmware_name = env['PROGNAME']
+ firmware_path = env.subst('$BUILD_DIR') + "\\"
+ #print(firmware_name)
+ #print(firmware_path)
+ shutil.copyfile(firmware_path + firmware_name + ".elf", firmware_path + firmware_name + ".bin")
+ print("bin file created.")
+ #env.Replace($PROGNAME="firmware_%s" % "elf" )
+
+env.AddPostAction("$BUILD_DIR/${PROGNAME}.elf", elf2bin)
+env.AddPreAction("upload", elf2bin) # added to make .elf file before uploading when only running upload
\ No newline at end of file
diff --git a/TGextra/noext2elf.py b/TGextra/noext2elf.py
new file mode 100644
index 0000000000..ce8fa98ac4
--- /dev/null
+++ b/TGextra/noext2elf.py
@@ -0,0 +1,16 @@
+Import("env")
+import shutil
+
+def noext2elf(source, target, env):
+ print("copying firmware to ELF...")
+ 
+ firmware_name = env['PROGNAME']
+ firmware_path = env.subst('$BUILD_DIR') + "/"
+ #print(firmware_name)
+ #print(firmware_path)
+ shutil.copyfile(firmware_path + firmware_name, firmware_path + firmware_name)
+ print("bin file created.")
+ #env.Replace($PROGNAME="firmware_%s" % "elf" )
+
+env.AddPostAction("buildprog", noext2elf)
+env.AddPreAction("upload", noext2elf) # added to make .elf file before uploading when only running upload
\ No newline at end of file
diff --git a/TGextra/set_folder_name.py b/TGextra/set_folder_name.py
new file mode 100644
index 0000000000..571f4550ba
--- /dev/null
+++ b/TGextra/set_folder_name.py
@@ -0,0 +1,15 @@
+Import("env")
+
+# this code will fetch the project directory (full path) from platformio env
+# then if not empty will split into a list of strings at "//" chars, then
+# supply the last string in the list to the new env variable SRCFOLDER
+
+foldername = env['PROJECT_DIR']
+if foldername != "":
+  ary = foldername.split("\\")
+else:
+  ary = ["src folder unknown"]
+
+#print(ary[len(ary)-1])
+env.Append(SRCFOLDER = ary[len(ary)-1])  
+
diff --git a/TGextra/sgen_v1_lpc1769.cfg b/TGextra/sgen_v1_lpc1769.cfg
new file mode 100644
index 0000000000..317f3a6921
--- /dev/null
+++ b/TGextra/sgen_v1_lpc1769.cfg
@@ -0,0 +1,25 @@
+# TG modified for working with LPC1769 on MKS SGEN V1.0 board
+#
+#
+
+set CPURAMSIZE 0x10000
+set CPUROMSIZE 0x80000
+set CHIPSERIES lpc1700
+#set CPUTAPID 0x4ba00477
+set CPUTAPID 0x2ba01477
+
+#CCLK is set in the lpc17xx/lpc1xxx cfg file chain
+
+#include the interface file for the target
+source [find interface/stlink.cfg]
+stlink_api 1
+set _TRANSPORT hla_swd
+transport select $_TRANSPORT
+
+#Include the main configuration file for the target
+#source [find target/lpc17xx.cfg]
+
+# if srst is not fitted, use SYSRESETREQ to perform a soft reset
+#cortex_m reset_config sysresetreq
+
+
diff --git a/WinMergeCompare.txt b/WinMergeCompare.txt
new file mode 100644
index 0000000000..b6a7d1c72a
--- /dev/null
+++ b/WinMergeCompare.txt
@@ -0,0 +1,18 @@
+Notes:
+
+remaining items to analyze for diff's are:
+
+src>
+feature
+gcode
+HAL
+inc
+lcd
+libs
+module
+pins
+sd
+MarlinCore cpp/h
+
+
+everything else has been compared and adjusted
\ No newline at end of file
diff --git a/buildroot/bin/run_tests b/buildroot/bin/run_tests
index 9a03be3cc7..26284fa693 100755
--- a/buildroot/bin/run_tests
+++ b/buildroot/bin/run_tests
@@ -67,7 +67,7 @@ else
       printf "\033[0;32mMatching test \033[0m#$3\033[0;32m: '\033[0m$test_name\033[0;32m'\n"
     fi
   fi
-  "$TESTS/$2" $1 $2 "$test_name"
+  $TESTS/$2 $1 $2 "$test_name"
   if [[ $GIT_RESET_HARD == "true" ]]; then
     git reset --hard HEAD
   else
diff --git a/buildroot/share/fonts/bdf2u8g/Makefile b/buildroot/share/fonts/bdf2u8g/Makefile
deleted file mode 100644
index cb00c7bb74..0000000000
--- a/buildroot/share/fonts/bdf2u8g/Makefile
+++ /dev/null
@@ -1,15 +0,0 @@
-CFLAGS = -g -Wall
-#CFLAGS = -O4 -Wall
-
-SRC = bdf2u8g.c
-
-OBJ = $(SRC:.c=.o)
-
-bdf2u8g: $(OBJ)
-	$(CC) $(CFLAGS) $(LDFLAGS) $(OBJ) -o bdf2u8g.exe
-
-clean:
-	-rm $(OBJ) bdf2u8g.exe
-
-test:
-	./bdf2u8g.exe -f 2 ../bdf/9x18.bdf u8g_aafont_9x18 u8g_aafont_9x18.c
diff --git a/buildroot/share/fonts/bdf2u8g/bdf2u8g.c b/buildroot/share/fonts/bdf2u8g/bdf2u8g.c
deleted file mode 100644
index 0421bbd87f..0000000000
--- a/buildroot/share/fonts/bdf2u8g/bdf2u8g.c
+++ /dev/null
@@ -1,1214 +0,0 @@
-/*
-  general font collections
-    http://www.smashingmagazine.com/2007/11/08/40-excellent-freefonts-for-professional-design/
-    http://techmagazine.ws/most-popular-free-quality-fonts/
-    http://openfontlibrary.org/
-  bitmap font collections
-    http://www.orgdot.com/aliasfonts/ (includes links)
-    http://www.04.jp.org/
-    http://www.miniml.com
-    http://www.fontspace.com/010bus
-
-  http://en.wikipedia.org/wiki/Unicode_typeface
-      da kÃ¶nnten auch ein paar fonts dabei sein, die die m2tklib sonderzeichen beinhalten:
-      Caslon Roman              http://en.wikipedia.org/wiki/Caslon_Roman
-      Charis Sil                http://en.wikipedia.org/wiki/Charis_SIL
-      DejaVu Sans       http://en.wikipedia.org/wiki/DejaVu_fonts
-      Doulos            http://en.wikipedia.org/wiki/Doulos_SIL
-      Free Serif        http://en.wikipedia.org/wiki/FreeSerif          http://ftp.gnu.org/gnu/freefont/
-            --> keine box, aber es gibt pfeile/invertierte pfeile und kreise fÃ¼r m2tklib
-      Gentium Plus ????    http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=Gentium_download#02b091ae
-            --> keine graphic
-      GNU Unifont       http://en.wikipedia.org/wiki/GNU_Unifont, http://unifoundry.com/unifont.html
-
-      Titus cyberbit Basic      http://en.wikipedia.org/wiki/TITUS_Cyberbit_Basic
-
-  fonts
-    Gentium
-      http://openfontlibrary.org/font/gentium
-      license: OFL
-    Old-Standard
-      http://openfontlibrary.org/font/old-standard
-      license: OFL
-    Hanuman
-      http://openfontlibrary.org/font/hanumanb
-      license: OFL
-    FreeUniversal
-      http://openfontlibrary.org/font/freeuniversal
-      license: OFL
-    FriendShip-Code  <--- nicht so sicher...
-      http://openfontlibrary.org/font/friendship-code
-      license: CC-BY-SA
-    LinuxLibertine
-      http://de.wikipedia.org/wiki/Linux_Libertine
-      http://sourceforge.net/projects/linuxlibertine/files/linuxlibertine/5.1.3-2/
-      license: OFL
-    DidactGothic
-      source: http://openfontlibrary.org/
-    judson
-      source: http://openfontlibrary.org/
-    unicons
-      source: http://openfontlibrary.org/
-      license: OFL
-      suggested pt: 26, 30
-    org_V01, fixed_V0
-      source: http://www.orgdot.com/aliasfonts/
-      license: open source, individual, cite required
-      suggested pt: 8
-    04b_03b.zip  04b_03.zip  04b_09.zip  04b_11.zip  04b_19.zip  04b_21.zip  04b_25.zip  04b_30.zip
-      source: http://www.04.jp.org/
-      license: "Freeware: You may use them as you like"
-    7px4bus
-      source: http://www.fontspace.com/010bus
-      license: Licensed as: Freeware, Commercial use allowed!
-      suggested 7pt
-    8pxbus
-      source: http://www.fontspace.com/010bus
-      license: Licensed as: Freeware, Commercial use allowed!
-      suggested 8pt
-
-*/
-
-/*
-  only supports metric set "0"
-  assume DWIDTH second arg to be 0 for all glyphs
-  assumes that (0,0) of the BBX is placed on the base line
-  assumes ISO10646 encoding of the BDF file
-
-  font information
-  offset
-  0             font format
-  1             FONTBOUNDINGBOX width           unsigned
-  2             FONTBOUNDINGBOX height          unsigned
-  3             FONTBOUNDINGBOX x-offset         signed
-  4             FONTBOUNDINGBOX y-offset        signed
-  5             capital A height                                unsigned
-  6             start 'A'
-  8             start 'a'
-  10            encoding start
-  11            encoding end
-  12            descent 'g'                     negative: below baseline
-  13            font max ascent
-  14            font min decent             negative: below baseline
-  15            xascent (ascent of "(")
-  16            xdescent (descent of ")")
-
-format 0
-    glyph information
-    offset
-    0             BBX width                                       unsigned
-    1             BBX height                                      unsigned
-    2             data size                                          unsigned    (BBX width + 7)/8 * BBX height
-    3             DWIDTH                                          signed
-    4             BBX xoffset                                    signed
-    5             BBX yoffset                                    signed
-
-format 1
-  0             BBX xoffset                                    signed   --> upper 4 Bit
-  0             BBX yoffset                                    signed --> lower 4 Bit
-  1             BBX width                                       unsigned --> upper 4 Bit
-  1             BBX height                                      unsigned --> lower 4 Bit
-  2             data size                                           unsigned -(BBX width + 7)/8 * BBX height  --> lower 4 Bit
-  2             DWIDTH                                          signed --> upper  4 Bit
-  byte 0 == 255 indicates empty glyph
-
-format 2
-  like format 0, but 4 gray levels for the glyph (4 pixel per byte in the glyph data)
-
-  The glyph bitmap size is defined by BBX width and BBX height
-  number of bytes in the bitmap data (BBX width + 7)/8 * BBX height (format 0 and 1)
-
-  draw_text(x,y,str)
-  get_text_frame(x,y,str, &x1, &y1, &width, &height)
-  frame( x1, y1, width, height)
-  underline( x1, y-1, width )
-
-  size of the surrounding bbox
-
-  width = - xoffset(c1) + DWIDTH(c1) + DWIDTH(c2) + ... + DWIDTH(cn-1) + width(cn) + xoffset(cn)
-  height = FONTBOUNDINGBOX height
-  x1 = x + xoffset(c1)
-  y1 = y + yoffset(c1)
-
-ISO-8859-1 was incorporated as the first 256 code points of ISO/IEC 10646 and Unicode.
-
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#define BDF2U8G_COMPACT_OUTPUT
-#define BDF2U8G_VERSION "1.01"
-//#define VERBOSE
-
-/*=== forward declaration ===*/
-void bdf_aa_ClearDoShow(void);
-void bdf_aa_Do(void);
-
-/*=== result data ===*/
-#define DATA_BUF_SIZE (1024 * 64)
-unsigned char data_buf[DATA_BUF_SIZE];
-int data_pos = 0;
-
-void data_Init(void) {
-  data_pos = 0;
-}
-
-void data_Put(unsigned char c) {
-  data_buf[data_pos] = c;
-  data_pos++;
-}
-
-void data_Write(FILE *out_fp, const char *indent) {
-  int i;
-  int bytes_per_line = 16;
-  for (i = 0; i < data_pos; i++) {
-    fprintf(out_fp, "0x%02X", data_buf[i]);
-    if (i + 1 != data_pos)
-      fprintf(out_fp, ",");
-    if ((i + 1) % bytes_per_line == 0)
-      fprintf(out_fp, "\n%s", indent);
-  }
-}
-
-/*=== low level parser ===*/
-#define P_BUF_SIZE (1024 * 4)
-int p_current_char;
-const char *p_line;
-char p_buf[P_BUF_SIZE];
-
-/* put next char into p_current_char */
-static int p_next_char(void) {
-  p_current_char = *p_line;
-  if (p_current_char == '\0')
-    return 0;
-  p_line++;
-  return 1;
-}
-
-int p_first_char(const char *line) {
-  p_line = line;
-  return p_next_char();
-}
-
-void p_err(const char *msg) {
-}
-
-int p_skip_space(void) {
-  for (;;) {
-    if (p_current_char == 0 || p_current_char > 32)
-      break;
-    if (p_next_char() == 0)
-      return 0;
-  }
-  return 1;
-}
-
-/* put identifier into p_buf */
-int p_get_identifier(void) {
-  int i = 0;
-  if (p_current_char == '\0')
-    return p_err("unexpected EOF (expected identifier)"), 0;
-  for (;;) {
-    if (p_current_char <= 32)
-      break;
-    p_buf[i++] =  p_current_char;
-    if (p_next_char() == 0)
-      break;
-  }
-  p_buf[i++] =  '\0';
-  p_skip_space();
-  return 1;
-}
-
-/* put identifier into p_buf */
-int p_get_identifier_with_blank(void) {
-  int i = 0;
-  for (;;) {
-    if (p_current_char < 32)
-      break;
-    p_buf[i++] =  p_current_char;
-    if (p_next_char() == 0)
-      break;
-  }
-  p_buf[i++] =  '\0';
-  p_skip_space();
-  return 1;
-}
-
-int p_get_string(void) {
-  int i = 0;
-  if (p_current_char == '\0')
-    return 0;
-  if (p_current_char != '\"')
-    return p_err("\" expected"), 0;
-  if (p_next_char() == 0)
-    return p_err("unexpected EOF (\")"), 0;
-  for (;;) {
-    if (p_current_char == '\\') {
-      if (p_next_char() == 0)
-        return p_err("unexpected EOF (\\)"), 0;
-    }
-    else if (p_current_char == '\"') {
-      p_next_char();
-      break;
-    }
-    p_buf[i++] =  p_current_char;
-    if (p_next_char() == 0)
-      return p_err("unexpected EOF (\")"), 0;
-  }
-  p_buf[i] =  '\0';
-  return 1;
-}
-
-int p_get_any(void) {
-  if (p_current_char == '\"')
-    return p_get_string();
-  return p_get_identifier();
-}
-
-int p_get_val(void) {
-  p_get_any();
-  return atoi(p_buf);
-}
-
-int p_get_hex(void) {
-  int value = 0;
-  if (p_current_char >= '0' && p_current_char <= '9')
-    value = p_current_char - '0';
-  else if (p_current_char >= 'a' && p_current_char <= 'f')
-    value = p_current_char - 'a' + 10;
-  else if (p_current_char >= 'A' && p_current_char <= 'F')
-    value = p_current_char - 'A' + 10;
-  p_next_char();
-  return value;
-}
-
-int p_get_hex_byte(void) {
-  int v;
-  v  = p_get_hex();
-  v *= 16;
-  v += p_get_hex();
-  return v;
-}
-
-/*=== encoding mapping ===*/
-/* the internal u8g index number (0..255) is mapped to the unicode number */
-/* for the conversion we need the reverse search */
-/* 0 is special and means not found */
-int map_u8g_to_unicode[256];
-
-int map_UnicodeToU8G(int unicode) {
-  int i;
-  for (i = 0; i < 256; i++)
-    if (map_u8g_to_unicode[i] == unicode)
-      return i;
-  return 0;
-}
-
-void map_Init(void) {
-  int i;
-  map_u8g_to_unicode[0] = 0;
-  for (i = 0; i < 256; i++) map_u8g_to_unicode[i] = i;
-}
-
-void map_UpperLowerPage(int lower_page, int upper_page, int shift, int upper_shift) {
-  int i;
-  int encoding;
-  int tmp[256];
-  // map_u8g_to_unicode[0] = 0;
-  for (i = 0; i < 128; i++) {
-    encoding              = i + lower_page * 128;
-    map_u8g_to_unicode[i] = encoding;
-  }
-
-  for (i = 128; i < 256; i++) {
-    encoding = i - 128 + upper_page * 128;
-    if (i + upper_shift < 256)
-      map_u8g_to_unicode[i + upper_shift] = encoding;
-  }
-
-  for (i = 0; i < 256; i++) tmp[i] = map_u8g_to_unicode[i];
-
-  for (i = 0; i < shift; i++) map_u8g_to_unicode[i] = -1;
-
-  for (i = shift; i < 256; i++) map_u8g_to_unicode[i] = tmp[(i + 256 - shift) % 256];
-  /*
-  printf("map_u8g_to_unicode[ 32 ] = %d\n", map_u8g_to_unicode[ 32 ]);
-  printf("map_u8g_to_unicode[ 33 ] = %d\n", map_u8g_to_unicode[ 33 ]);
-  */
-}
-
-/*=== store bdf file positions ===*/
-
-long bdf_last_line_start_pos;
-long bdf_encoding_pos[256];
-
-void bdf_InitFilePos(void) {
-  int i;
-  for (i = 0; i < 256; i++) bdf_encoding_pos[i] = 0;
-}
-
-void bdf_SetFilePos(FILE *fp, int encoding) {
-  if (encoding < 0)
-    return;
-  if (bdf_encoding_pos[encoding] == 0L)
-    return;
-  fseek(fp, bdf_encoding_pos[encoding], SEEK_SET);
-  // fprintf(stderr, "setting file for encoding %d to pos %ld\n", encoding, bdf_encoding_pos[encoding]);
-}
-
-int bdf_IsEncodingAvailable(int encoding) {
-  if (bdf_encoding_pos[encoding] == 0L)
-    // printf("encoding %d not availabe\n", encoding);
-    return 0;
-  return 1;
-}
-
-void bdf_StoreFilePos(int encoding, long pos) {
-  // if ( encoding == 33 )
-  // printf("encoding %d at pos %ld\n", encoding, pos);
-  if (bdf_encoding_pos[encoding] != 0L)
-    return;
-  bdf_encoding_pos[encoding] = pos;
-}
-
-/*=== bdf file read ===*/
-
-int bdf_font_format = 0;
-
-#define BDF_STATE_FONT_DATA 0
-#define BDF_STATE_ENCODING 1
-
-int bdf_state              = BDF_STATE_FONT_DATA;
-int bdf_requested_encoding = 0;
-
-#define BDF_LINE_MAX (1024 * 4)
-#define BDF_LINE_STATE_KEYWORDS 0
-#define BDF_LINE_STATE_BITMAP 1
-#define BDF_MAX_HEIGHT 200
-#define BDF_AA_OFFSET 1
-
-char bdf_copyright[BDF_LINE_MAX];
-char bdf_font[BDF_LINE_MAX];
-unsigned char bdf_bitmap_line[BDF_MAX_HEIGHT][20];
-unsigned char bdf_aa_bitmap_line[BDF_MAX_HEIGHT + 2 * BDF_AA_OFFSET][(20 + 2 * BDF_AA_OFFSET) * 8];
-
-int bdf_line_state   = BDF_LINE_STATE_KEYWORDS;
-int bdf_line_bm_line = 0;
-
-int bdf_font_size;            /* point font size */
-
-int bdf_font_width;           /* FONTBOUNDINGBOX arg 1 */
-int bdf_font_height;          /* FONTBOUNDINGBOX arg 2 */
-int bdf_font_x;               /* FONTBOUNDINGBOX arg 3 */
-int bdf_font_y;               /* FONTBOUNDINGBOX arg 4 */
-
-int bdf_capital_A_height;
-int bdf_capital_1_height;
-int bdf_lower_g_descent;
-
-int bdf_char_width;           /* BBX arg 1 */
-int bdf_char_max_width;
-int bdf_char_height;          /* BBX arg 2 */
-int bdf_char_ascent;          /* defined as BBX arg 2 + BBX arg 4 */
-int bdf_char_xascent;
-int bdf_char_xdescent;
-int bdf_char_max_ascent;
-int bdf_char_max_height;
-int bdf_char_x;               /* BBX arg 3 */
-int bdf_char_max_x;
-int bdf_char_min_x;
-int bdf_char_y;               /* BBX arg 4 */
-int bdf_char_max_y;
-int bdf_char_min_y;
-
-int bdf_delta_x_default = -1;
-int bdf_delta_x         = -1; /* DWIDTH arg 1 */
-int bdf_delta_max_x;
-int bdf_delta_min_x;
-int bdf_delta_y;              /* DWIDTH arg 2 */
-int bdf_delta_max_y;
-int bdf_delta_min_y;
-
-int bdf_glyph_data_len;
-int bdf_glyph_data_max_len;
-
-int bdf_encoding;
-
-int bdf_encoding_65_pos;
-int bdf_encoding_97_pos;
-int bdf_is_encoding_successfully_done;
-
-char bdf_info[32000 * 2];
-
-int bdf_is_put_glyph_completed = 0; /* indicator, when the glyph has been processed */
-
-void bdf_ResetMax(void) {
-  bdf_char_max_width     = 0;
-  bdf_char_max_height    = 0;
-  bdf_char_max_x         = 0;
-  bdf_char_max_y         = 0;
-  bdf_delta_max_x        = 0;
-  bdf_delta_max_y        = 0;
-  bdf_char_min_x         = 0;
-  bdf_char_min_y         = 0;
-  bdf_delta_min_x        = 0;
-  bdf_delta_min_y        = 0;
-  bdf_glyph_data_max_len = 0;
-  bdf_char_max_ascent    = 0;
-  bdf_char_xascent       = 0;
-  bdf_char_xdescent      = 0;
-}
-
-void bdf_UpdateMax(void) {
-  if (bdf_char_max_width < bdf_char_width)
-    bdf_char_max_width = bdf_char_width;
-  if (bdf_char_max_height < bdf_char_height)
-    bdf_char_max_height = bdf_char_height;
-
-  if (bdf_char_max_x < bdf_char_x)
-    bdf_char_max_x = bdf_char_x;
-
-  if (bdf_char_max_y < bdf_char_y)
-    bdf_char_max_y = bdf_char_y;
-
-  if (bdf_delta_max_x < bdf_delta_x)
-    bdf_delta_max_x = bdf_delta_x;
-  if (bdf_delta_max_y < bdf_delta_y)
-    bdf_delta_max_y = bdf_delta_y;
-
-  if (bdf_char_min_x > bdf_char_x)
-    bdf_char_min_x = bdf_char_x;
-
-  if (bdf_char_min_y > bdf_char_y)
-    bdf_char_min_y = bdf_char_y;
-
-  if (bdf_delta_min_x > bdf_delta_x)
-    bdf_delta_min_x = bdf_delta_x;
-  if (bdf_delta_min_y > bdf_delta_y)
-    bdf_delta_min_y = bdf_delta_y;
-
-  if (bdf_glyph_data_max_len < bdf_glyph_data_len)
-    bdf_glyph_data_max_len = bdf_glyph_data_len;
-
-  if (bdf_char_max_ascent < bdf_char_ascent)
-    bdf_char_max_ascent = bdf_char_ascent;
-}
-
-void bdf_ShowGlyph(void) {
-  #ifdef VERBOSE
-    int x, y, byte, bit;
-    int gx, gy;
-    char *p;
-    gy = bdf_char_height - 1 + bdf_char_y;
-    printf("bbx %d %d %d %d encoding %d\n", bdf_char_width, bdf_char_height, bdf_char_x, bdf_char_y, bdf_encoding);
-    for (y = 0; y < bdf_line_bm_line; y++) {
-      printf("%02d ", gy);
-      gx = bdf_char_x;
-      for (x = 0; x < bdf_char_width; x++) {
-        byte = x >> 3;
-        bit  = 7 - (x & 7);
-        if ((bdf_bitmap_line[y][byte] & (1 << bit)) == 0)
-          p = " .";
-        else
-          p = " *";
-        if (gy == 0 && gx == 0)
-          p = " o";
-        printf("%s", p);
-        gx++;
-      }
-      printf(" ");
-      for (x = 0; x < ((bdf_char_width + 7) / 8); x++) printf( "%02X", bdf_bitmap_line[y][x]);
-      gy--;
-      printf("\n");
-    }
-  #else
-    printf("bbx %d %d %d %d encoding %d\n", bdf_char_width, bdf_char_height, bdf_char_x, bdf_char_y, bdf_encoding);
-    fflush(stdout);
-  #endif
-}
-
-void bdf_ClearGlyphBuffer(void) {
-  int x, y;
-  for (y = 0; y < BDF_MAX_HEIGHT; y++)
-    for (x = 0; x < 20; x++) bdf_bitmap_line[y][x] = 0;
-}
-
-void bdf_PutGlyph(void) {
-  int len;
-  int y, x;
-
-  if (bdf_state == BDF_STATE_ENCODING) {
-    //if (bdf_char_width == 0 && bdf_char_height == 0) bdf_char_y = 0;
-
-    bdf_char_ascent = bdf_char_height + bdf_char_y;
-    //printf("h:%d w:%d ascent: %d\n", bdf_char_height, bdf_char_width, bdf_char_ascent);
-
-    if (bdf_encoding == 'A')
-      bdf_capital_A_height = bdf_char_height;
-    if (bdf_encoding == '1')
-      bdf_capital_1_height = bdf_char_height;
-
-    if (bdf_encoding == 'g')
-      bdf_lower_g_descent = bdf_char_y;
-
-    if (bdf_char_xascent < bdf_capital_A_height)
-      bdf_char_xascent = bdf_capital_A_height;
-    if (bdf_char_xascent < bdf_capital_1_height)
-      bdf_char_xascent = bdf_capital_1_height;
-    if (bdf_encoding == '(')
-      if (bdf_char_xascent < bdf_char_ascent)
-        bdf_char_xascent = bdf_char_ascent;
-    if (bdf_encoding == '[')
-      if (bdf_char_xascent < bdf_char_ascent)
-        bdf_char_xascent = bdf_char_ascent;
-
-    if (bdf_char_xdescent > bdf_lower_g_descent)
-      bdf_char_xdescent = bdf_lower_g_descent;
-    if (bdf_encoding == '(')
-      if (bdf_char_xdescent > bdf_char_y)
-        bdf_char_xdescent = bdf_char_y;
-    if (bdf_encoding == '[')
-      if (bdf_char_xdescent > bdf_char_y)
-        bdf_char_xdescent = bdf_char_y;
-
-    if (bdf_requested_encoding != bdf_encoding)
-      return;
-
-    assert( bdf_line_bm_line == bdf_char_height);
-
-    bdf_ShowGlyph();
-    #ifdef VERBOSE
-      bdf_aa_ClearDoShow();
-    #endif
-
-    bdf_UpdateMax();
-
-    if (bdf_font_format <= 1)
-      len = (bdf_char_width + 7) / 8 * bdf_char_height;
-    else
-      len = (bdf_char_width + 2 * BDF_AA_OFFSET + 3) / 4 * (bdf_char_height + 2 * BDF_AA_OFFSET);
-    if (len > 255) {
-      fprintf(stderr, "Glyph with encoding %d is too large (%d > 255)\n", bdf_encoding, len);
-      exit(1);
-    }
-
-    bdf_glyph_data_len = len;
-
-    /*
-      format 0 and format 2
-      glyph information
-      offset
-      0             BBX width                                       unsigned
-      1             BBX height                                      unsigned
-      2             data size                                          unsigned    (BBX width + 7)/8 * BBX height
-      3             DWIDTH                                          signed
-      4             BBX xoffset                                    signed
-      5             BBX yoffset                                    signed
-    */
-
-    if (bdf_font_format == 0) {
-      data_Put(bdf_char_width);
-      data_Put(bdf_char_height);
-      data_Put(bdf_glyph_data_len);
-      data_Put(bdf_delta_x);
-      data_Put(bdf_char_x);
-      data_Put(bdf_char_y);
-      // data_Put(bdf_encoding);
-      bdf_is_encoding_successfully_done = 1;
-    }
-    else if (bdf_font_format == 2) {
-      data_Put(bdf_char_width + 2 * BDF_AA_OFFSET);
-      data_Put(bdf_char_height + 2 * BDF_AA_OFFSET);
-      data_Put(bdf_glyph_data_len);
-      data_Put(bdf_delta_x);
-      data_Put(bdf_char_x - BDF_AA_OFFSET);
-      data_Put(bdf_char_y - BDF_AA_OFFSET);
-      // data_Put(bdf_encoding);
-      bdf_is_encoding_successfully_done = 1;
-    }
-    else {
-      /**
-       * format 1
-       *   0             BBX xoffset         signed   --> upper 4 Bit
-       *   0             BBX yoffset         signed --> lower 4 Bit
-       *   1             BBX width           unsigned --> upper 4 Bit
-       *   1             BBX height          unsigned --> lower 4 Bit
-       *   2             data size           unsigned -(BBX width + 7)/8 * BBX height  --> lower 4 Bit
-       *   2             DWIDTH              signed --> upper  4 Bit
-       *   byte 0 == 255 indicates empty glyph
-       */
-      if (bdf_glyph_data_len < 0 || bdf_glyph_data_len > 15) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (data len = %d)\n", bdf_encoding, bdf_glyph_data_len);
-        exit(1);
-      }
-      if (bdf_delta_x < 0 || bdf_delta_x > 15) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (DWIDTH = %d)\n", bdf_encoding, bdf_delta_x);
-        exit(1);
-      }
-      if (bdf_char_x < 0 || bdf_char_x > 15) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (x-off = %d)\n", bdf_encoding, bdf_char_x);
-        exit(1);
-      }
-      if (bdf_char_y < -2 || bdf_char_y > 13) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (y-off = %d [%d..%d])\n", bdf_encoding, bdf_char_y, bdf_char_min_y, bdf_char_max_y);
-        exit(1);
-      }
-      if (bdf_char_width < 0 || bdf_char_width > 15) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (width = %d)\n", bdf_encoding, bdf_char_width);
-        exit(1);
-      }
-      if (bdf_char_height < 0 || bdf_char_height > 15) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (height = %d)\n", bdf_encoding, bdf_char_height);
-        exit(1);
-      }
-      // data_Put(bdf_encoding);
-      if (((bdf_char_x << 4) | (bdf_char_y + 2)) == 255) {
-        fprintf(stderr, "Glyph with encoding %d does not fit for format 1 (skip mark generated)\n", bdf_encoding);
-        exit(1);
-      }
-      data_Put((bdf_char_x << 4) | (bdf_char_y + 2));
-      data_Put((bdf_char_width << 4) | bdf_char_height );
-      data_Put((bdf_delta_x << 4) | bdf_glyph_data_len );
-      bdf_is_encoding_successfully_done = 1;
-    }
-
-    sprintf(bdf_info + strlen(bdf_info), "/* encoding %d %c, bbx %d %d %d %d  asc %d dx %d*/\n",
-      bdf_encoding,
-      bdf_encoding > 32 && bdf_encoding <= 'z' ? bdf_encoding : ' ',
-      bdf_char_width,
-      bdf_char_height,
-      bdf_char_x,
-      bdf_char_y,
-      bdf_char_ascent,
-      bdf_delta_x);
-
-    if (bdf_font_format <= 1) {
-      for (y = 0; y < bdf_char_height; y++)
-        for (x = 0; x < ((bdf_char_width + 7) / 8); x++) {
-          data_Put(bdf_bitmap_line[y][x]);
-          len--;
-        }
-      assert( len == 0 );
-      bdf_is_put_glyph_completed = 1;
-    }
-    else { /* format == 2 */
-      int b, cnt;
-      bdf_aa_Do();
-      for (y = 0; y < bdf_char_height + 2 * BDF_AA_OFFSET; y++) {
-        b   = 0;
-        cnt = 0;
-        for (x = 0; x < bdf_char_width + 2 * BDF_AA_OFFSET; x++) {
-          b <<= 2;
-          b  |= bdf_aa_bitmap_line[y][x] & 3;
-          cnt++;
-          if (cnt == 4) {
-            data_Put(b);
-            b   = 0;
-            cnt = 0;
-            len--;
-          }
-        }
-
-        if (cnt != 0) {
-          b <<= 2 * (4 - cnt);
-          data_Put(b);
-          b   = 0;
-          cnt = 0;
-          len--;
-        }
-      }
-      assert( len == 0 );
-    }
-  }
-}
-
-/*=========================================================================*/
-/* Glyph Clipping */
-
-int bdf_IsColZero(int x) {
-  int y, byte, bit;
-  for (y = 0; y < bdf_char_height; y++) {
-    byte = x >> 3;
-    bit  = 7 - (x & 7);
-    if ((bdf_bitmap_line[y][byte] & (1 << bit)) != 0)
-      return 0;
-  }
-  return 1;
-}
-
-int bdf_IsRowZero(int y) {
-  int x, byte, bit;
-  for (x = 0; x < bdf_char_width; x++) {
-    byte = x >> 3;
-    bit  = 7 - (x & 7);
-    if ((bdf_bitmap_line[y][byte] & (1 << bit)) != 0)
-      return 0;
-  }
-  return 1;
-}
-
-void bdf_DeleteFirstCol(void) {
-  int m = (bdf_char_width + 7) / 8;
-  int x, y;
-  for (y = 0; y < bdf_char_height; y++)
-    for (x = 0; x < m; x++) {
-      bdf_bitmap_line[y][x] <<= 1;
-      bdf_bitmap_line[y][x]  |= bdf_bitmap_line[y][x + 1] >> 7;
-    }
-}
-
-void bdf_DeleteFirstRow(void) {
-  int m = (bdf_char_width + 7) / 8;
-  int x, y;
-  for (y = 0; y + 1 < bdf_char_height; y++)
-    for (x = 0; x < m; x++)
-      bdf_bitmap_line[y][x] = bdf_bitmap_line[y + 1][x];
-}
-
-void bdf_ReduceGlyph(void) {
-  while (bdf_char_width > 0) {
-    if (bdf_IsColZero(bdf_char_width - 1) == 0)
-      break;
-    bdf_char_width--;
-  }
-
-  while (bdf_char_height > 0) {
-    if (bdf_IsRowZero(bdf_char_height - 1) == 0)
-      break;
-    bdf_line_bm_line--;
-    bdf_char_height--;
-    bdf_char_y++;
-  }
-
-  while (bdf_IsColZero(0) != 0 && bdf_char_width > 0) {
-    bdf_DeleteFirstCol();
-    bdf_char_x++;
-    bdf_char_width--;
-  }
-
-  while (bdf_char_height > 0) {
-    if (bdf_IsRowZero(0) == 0)
-      break;
-    bdf_DeleteFirstRow();
-    bdf_line_bm_line--;
-    bdf_char_height--;
-  }
-}
-
-/*=========================================================================*/
-/* Anti Aliasing / Graylevel Glyph */
-
-int bdf_GetXYVal(int x, int y) {
-  int byte, bit;
-
-  if (x < 0) return 0;
-  if (y < 0) return 0;
-  if (x >= bdf_char_width) return 0;
-  if (y >= bdf_char_height) return 0;
-
-  byte = x >> 3;
-  bit  = 7 - (x & 7);
-  if ((bdf_bitmap_line[y][byte] & (1 << bit)) != 0) return 1;
-  return 0;
-}
-
-void bdf_aa_Clear(void) {
-  int x, y;
-  for (y = 0; y < BDF_MAX_HEIGHT + 2 * BDF_AA_OFFSET; y++)
-    for (x = 0; x < (20 + 2 * BDF_AA_OFFSET) * 8; x++)
-      bdf_aa_bitmap_line[y][x] = 0;
-}
-
-void bdf_aa_SetXYVal(int x, int y, int val) {
-  bdf_aa_bitmap_line[y][x] = val;
-}
-
-int bdf_aa_matrix[9] = {
-  1, 3, 1,
-  3, 4, 3,
-  1, 3, 1
-};
-int bdf_aa_sum = 20;
-int bdf_aa_gray_levels = 4;
-
-void bdf_aa_Do(void) {
-  int x, y, val, sx, sy, sum, gray;
-  bdf_aa_Clear();
-  for (y = 0; y < bdf_char_height + 2 * BDF_AA_OFFSET; y++)
-    for (x = 0; x < bdf_char_width + 2 * BDF_AA_OFFSET; x++) {
-      if (bdf_GetXYVal(x - BDF_AA_OFFSET, y - BDF_AA_OFFSET) == 0) {
-        sum = 0;
-        for (sy = -BDF_AA_OFFSET; sy <= BDF_AA_OFFSET; sy++)
-          for (sx = -BDF_AA_OFFSET; sx <= BDF_AA_OFFSET; sx++) {
-            val  = bdf_GetXYVal(x + sx - BDF_AA_OFFSET, y + sy - BDF_AA_OFFSET);
-            val *= bdf_aa_matrix[(sy + BDF_AA_OFFSET) * (2 * BDF_AA_OFFSET + 1) + sx + BDF_AA_OFFSET];
-            sum += val;
-          }
-        if (sum <= 5)
-          gray = 0;
-        else
-          gray = (sum * (bdf_aa_gray_levels - 1) + (bdf_aa_sum / 2)) / bdf_aa_sum;
-        if (gray >= bdf_aa_gray_levels)
-          gray = bdf_aa_gray_levels - 1;
-      }
-      else {
-        gray = bdf_aa_gray_levels - 1;
-      }
-      bdf_aa_SetXYVal(x, y, gray);
-    }
-}
-
-void bdf_aa_Show(void) {
-  int x, y;
-  if (bdf_font_format == 2) {
-    for (y = 0; y < bdf_char_height + 2 * BDF_AA_OFFSET; y++) {
-      for (x = 0; x < bdf_char_width + 2 * BDF_AA_OFFSET; x++)
-        switch (bdf_aa_bitmap_line[y][x]) {
-          case 0: printf("."); break;
-          case 1: printf("-"); break;
-          case 2: printf("+"); break;
-          case 3: printf("#"); break;
-        }
-      printf("\n");
-    }
-  }
-}
-
-void bdf_aa_ClearDoShow(void) {
-  bdf_aa_Do();
-  bdf_aa_Show();
-}
-
-/*=========================================================================*/
-/* Parser */
-
-void bdf_ReadLine(const char *s) {
-  /*
-  if ( bdf_line_state == BDF_LINE_STATE_BITMAP && bdf_requested_encoding != bdf_encoding && *s != 'E' )
-    return;
-  */
-
-  if (p_first_char(s) == 0) return;
-  if (p_skip_space() == 0) return;
-
-  if (bdf_line_state == BDF_LINE_STATE_KEYWORDS) {
-    p_get_identifier();
-    if (strcmp(p_buf, "COPYRIGHT") == 0) {
-      p_get_any();
-      strcpy(bdf_copyright, p_buf);
-    }
-    else if (strcmp(p_buf, "FONT") == 0) {
-      /* p_get_any(); */
-      p_get_identifier_with_blank();
-      strcpy(bdf_font, p_buf);
-    }
-    else if (strcmp(p_buf, "SIZE") == 0) {
-      bdf_font_size = p_get_val();
-    }
-    else if (strcmp(p_buf, "ENCODING") == 0) {
-      bdf_encoding = map_UnicodeToU8G(p_get_val());
-      bdf_StoreFilePos(bdf_encoding, bdf_last_line_start_pos);
-    }
-    else if (strcmp(p_buf, "DWIDTH") == 0) {
-      bdf_delta_x = p_get_val();
-      bdf_delta_y = p_get_val();
-    }
-    else if (strcmp(p_buf, "FONTBOUNDINGBOX") == 0) {
-      bdf_font_width  = p_get_val();
-      bdf_font_height = p_get_val();
-      bdf_font_x      = p_get_val();
-      bdf_font_y      = p_get_val();
-    }
-    else if (strcmp(p_buf, "BBX") == 0) {
-      bdf_char_width  = p_get_val();
-      bdf_char_height = p_get_val();
-      bdf_char_x      = p_get_val();
-      bdf_char_y      = p_get_val();
-      bdf_char_ascent = bdf_char_height + bdf_char_y;
-      // printf("h:%d w:%d ascent: %d\n", bdf_char_height, bdf_char_width, bdf_char_ascent);
-    }
-    else if (strcmp(p_buf, "CHARS") == 0) {
-      if (bdf_delta_x < 0)
-        bdf_delta_x = 0;
-      if (bdf_delta_x_default < 0)
-        bdf_delta_x_default = bdf_delta_x;
-    }
-    else if (strcmp(p_buf, "STARTCHAR") == 0) {
-      if (bdf_delta_x_default < 0)
-        bdf_delta_x_default = 0;
-      bdf_delta_x = bdf_delta_x_default;
-    }
-    else if (strcmp(p_buf, "BITMAP") == 0) {
-      bdf_line_state   = BDF_LINE_STATE_BITMAP;
-      bdf_line_bm_line = 0;
-    }
-  }
-  else if (bdf_line_state == BDF_LINE_STATE_BITMAP) {
-    if (strncmp(s, "ENDCHAR", 7) == 0) {
-      bdf_ReduceGlyph();
-      bdf_PutGlyph();
-      bdf_line_state   = BDF_LINE_STATE_KEYWORDS;
-      bdf_line_bm_line = 0;
-    }
-    else if (bdf_requested_encoding == bdf_encoding)  {
-      int i = 0;
-      for (;;) {
-        if (p_current_char < '0') break;
-        bdf_bitmap_line[bdf_line_bm_line][i] = p_get_hex_byte();
-        i++;
-      }
-      bdf_line_bm_line++;
-      assert(bdf_line_bm_line < BDF_MAX_HEIGHT);
-    }
-  }
-}
-
-int bdf_ReadFP(FILE *fp) {
-  static char bdf_line[BDF_LINE_MAX];
-  bdf_is_put_glyph_completed = 0;
-  for (;;) {
-    bdf_last_line_start_pos = ftell(fp);
-    if (fgets(bdf_line, BDF_LINE_MAX - 1, fp) == NULL)
-      break;
-    bdf_ReadLine(bdf_line);
-    if (bdf_is_put_glyph_completed != 0)
-      break;
-  }
-  return 1;
-}
-
-int bdf_ReadFile(const char *filename, int encoding) {
-  int r;
-  FILE *fp;
-  fp = fopen(filename, "rb");
-  if (fp != NULL) {
-    bdf_SetFilePos(fp, encoding);
-    r = bdf_ReadFP(fp);
-    fclose(fp);
-    return r;
-  }
-  return 0; /* open error */
-}
-
-void bdf_GenerateFontData(const char *filename, int begin, int end) {
-  bdf_state = BDF_STATE_FONT_DATA;
-  bdf_ReadFile(filename, -1);
-  /**
-   * font information
-   *
-   * offset
-   *   0          font format
-   *   1          FONTBOUNDINGBOX width         unsigned
-   *   2          FONTBOUNDINGBOX height        unsigned
-   *   3          FONTBOUNDINGBOX x-offset      signed
-   *   4          FONTBOUNDINGBOX y-offset      signed
-   *   5          Capital A Height              unsigned
-   *   6          position of encoding 65 'A'   high byte first
-   *   8          position of encoding 97 'a'   high byte first
-   */
-  data_Put(bdf_font_format);
-  data_Put(bdf_font_width);
-  data_Put(bdf_font_height);
-  data_Put(bdf_font_x);
-  data_Put(bdf_font_y);
-  data_Put(bdf_capital_A_height > 0 ? bdf_capital_A_height : bdf_capital_1_height);
-  data_Put(0);
-  data_Put(0);
-  data_Put(0);
-  data_Put(0);
-  data_Put(begin);
-  data_Put(end);                /* will be overwritten later */
-  data_Put(0);                  /* lower g descent */
-  data_Put(0);                  /* max ascent */
-  data_Put(0);                  /* min y = descent */
-  data_Put(0);                  /* x ascent */
-  data_Put(0);                  /* x descent */
-}
-
-void bdf_GenerateGlyph(const char *filename, int encoding) {
-  bdf_ClearGlyphBuffer();
-  bdf_requested_encoding = encoding;
-  bdf_state = BDF_STATE_ENCODING;
-  bdf_ReadFile(filename, encoding);
-}
-
-void bdf_Generate(const char *filename, int begin, int end) {
-  int i;
-  int last_valid_encoding;
-
-  bdf_encoding_65_pos = 0;
-  bdf_encoding_97_pos = 0;
-
-  bdf_InitFilePos();
-  bdf_ResetMax();
-  bdf_info[0]      = '\0';
-  bdf_font[0]      = '\0';
-  bdf_copyright[0] = '\0';
-
-  bdf_GenerateFontData(filename, begin, end);
-  for (i = begin; i <= end; i++) {
-
-    if (i == 65) bdf_encoding_65_pos = data_pos;
-    if (i == 97) bdf_encoding_97_pos = data_pos;
-
-    bdf_is_encoding_successfully_done = 0;
-    if (bdf_IsEncodingAvailable(i))
-      bdf_GenerateGlyph(filename, i);
-    if (bdf_is_encoding_successfully_done == 0)
-      data_Put(255);          /* no char encoding */
-    if (bdf_is_encoding_successfully_done != 0)
-      last_valid_encoding = i;
-  }
-  /* data_Put(255); obsolete, not required any more for format 0 */         /* encoding 255, end of font data (format 0) */
-
-  data_buf[5] = bdf_capital_A_height > 0 ? bdf_capital_A_height : bdf_capital_1_height;
-
-  data_buf[6] = (bdf_encoding_65_pos >> 8);
-  data_buf[7] = (bdf_encoding_65_pos & 255);
-  data_buf[8] = (bdf_encoding_97_pos >> 8);
-  data_buf[9] = (bdf_encoding_97_pos & 255);
-
-  data_buf[12] = bdf_lower_g_descent;
-  data_buf[13] = bdf_char_max_ascent;
-  data_buf[14] = bdf_char_min_y;
-  data_buf[15] = bdf_char_xascent;
-  data_buf[16] = bdf_char_xdescent;
-
-  if (0) data_buf[11] = last_valid_encoding;
-
-}
-
-void bdf_WriteC(const char *outname, const char *fontname) {
-  int capital_ascent;
-  FILE *out_fp;
-  out_fp = fopen(outname, "wb");
-  assert( out_fp != NULL );
-
-  capital_ascent = bdf_capital_A_height > 0 ? bdf_capital_A_height : bdf_capital_1_height;
-
-  fprintf(out_fp, "/*\n");
-  fprintf(out_fp, "  Fontname: %s\n", bdf_font);
-  fprintf(out_fp, "  Copyright: %s\n", bdf_copyright);
-  fprintf(out_fp, "  Capital A Height: %d, '1' Height: %d\n", bdf_capital_A_height, bdf_capital_1_height);
-  fprintf(out_fp, "  Calculated Max Values w=%2d h=%2d x=%2d y=%2d dx=%2d dy=%2d ascent=%2d len=%2d\n",
-    bdf_char_max_width, bdf_char_max_height, bdf_char_max_x, bdf_char_max_y, bdf_delta_max_x, bdf_delta_max_y,
-    bdf_char_max_ascent, bdf_glyph_data_max_len);
-  fprintf(out_fp, "  Font Bounding box     w=%2d h=%2d x=%2d y=%2d\n",
-    bdf_font_width, bdf_font_height, bdf_font_x, bdf_font_y);
-  fprintf(out_fp, "  Calculated Min Values           x=%2d y=%2d dx=%2d dy=%2d\n",
-    bdf_char_min_x, bdf_char_min_y, bdf_delta_min_x, bdf_delta_min_y);
-
-  fprintf(out_fp, "  Pure Font   ascent =%2d descent=%2d\n", capital_ascent, bdf_lower_g_descent);
-  fprintf(out_fp, "  X Font      ascent =%2d descent=%2d\n", bdf_char_xascent, bdf_char_xdescent);
-  fprintf(out_fp, "  Max Font    ascent =%2d descent=%2d\n", bdf_char_max_ascent, bdf_char_min_y);
-
-  fprintf(out_fp, "*/\n");
-  fprintf(out_fp, "const u8g_fntpgm_uint8_t %s[%d] U8G_FONT_SECTION(\"%s\") = {\n", fontname, data_pos, fontname);
-  fprintf(out_fp, "  ");
-  data_Write(out_fp, "  ");
-  fprintf(out_fp, "};\n");
-  #ifndef BDF2U8G_COMPACT_OUTPUT
-    fprintf(out_fp, "%s\n", bdf_info);
-  #endif
-
-  fclose(out_fp);
-}
-
-int ga_argc;
-char **ga_argv;
-
-void ga_remove_arg(void) {
-  if (ga_argc == 0) return;
-  ga_argc--;
-  ga_argv++;
-}
-
-int ga_is_arg(char opt) {
-  if (ga_argc == 0) return 0;
-  if (ga_argv[0] == NULL) return 0;
-  if (ga_argv[0][0] != '-') return 0;
-  if (ga_argv[0][1] != opt) return 0;
-  ga_remove_arg();
-  return 1;
-}
-
-int main(int argc, char **argv) {
-  int lower_page          = 0;
-  int upper_page          = 1;
-  int mapping_shift       = 0;
-  int upper_mapping_shift = 0;
-  int begin               = 32;
-  int end                 = 255;
-
-  if (argc < 4) {
-    printf("bdf to u8glib font format converter v" BDF2U8G_VERSION "\n");
-    printf("%s [-l page] [-u page] [-s shift] [-S upper-shift] [-b begin] [-e end] [-f format] fontfile fontname outputfile\n", argv[0]);
-    return 1;
-  }
-
-  ga_argc = argc;
-  ga_argv = argv;
-  ga_remove_arg();              /* remove program name */
-
-  for (;;) {
-    if (ga_is_arg('l')) {
-      lower_page = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else if (ga_is_arg('u')) {
-      upper_page = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else if (ga_is_arg('s')) {
-      mapping_shift = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else if (ga_is_arg('S')) {
-      upper_mapping_shift = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else if (ga_is_arg('b')) {
-      begin = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else if (ga_is_arg('e')) {
-      end = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else if (ga_is_arg('f')) {
-      bdf_font_format = atoi(ga_argv[0]);
-      ga_remove_arg();
-    }
-    else {
-      break;
-    }
-  }
-
-  printf("encoding range %d..%d\n", begin, end);
-
-  data_Init();
-  map_Init();
-  map_UpperLowerPage(lower_page, upper_page, mapping_shift, upper_mapping_shift);
-
-  /*
-  puts(bdf_font);
-  puts(bdf_copyright);
-  if (ga_argc < 3) {
-    printf("from page %d to page %d\n", lower_page, upper_page);
-    return 1;
-  }
-  */
-
-  bdf_Generate(ga_argv[0], begin, end);
-  bdf_WriteC(ga_argv[2], ga_argv[1]);
-
-  printf("input file '%s'\n", ga_argv[0]);
-  printf("u8g font name '%s'\n", ga_argv[1]);
-  printf("output file '%s'\n", ga_argv[2]);
-
-  return 0;
-}
diff --git a/buildroot/share/fonts/genallfont.sh b/buildroot/share/fonts/genallfont.sh
index 5d85c88a18..ebb99b273f 100755
--- a/buildroot/share/fonts/genallfont.sh
+++ b/buildroot/share/fonts/genallfont.sh
@@ -24,9 +24,19 @@ my_getpath() {
   echo -n "${DN}"
   [[ -z "$FN" ]] || echo -n "/${FN}"
 }
-
+#DN_EXEC=`echo "$0" | ${EXEC_AWK} -F/ '{b=$1; for (i=2; i < NF; i ++) {b=b "/" $(i)}; print b}'`
 DN_EXEC=$(dirname $(my_getpath "$0") )
 
+EXEC_WXGGEN="${DN_EXEC}/uxggenpages.sh"
+
+#
+# Locate the bdf2u8g command
+#
+EXEC_BDF2U8G=`which bdf2u8g`
+[ -x "${EXEC_BDF2U8G}" ] || EXEC_BDF2U8G="${DN_EXEC}/bdf2u8g"
+[ -x "${EXEC_BDF2U8G}" ] || EXEC_BDF2U8G="${PWD}/bdf2u8g"
+[ -x "${EXEC_BDF2U8G}" ] || { EOL=$'\n' ; echo "ERR: Can't find bdf2u8g!${EOL}See uxggenpages.md for bdf2u8g build instructions." >&2 ; exit 1; }
+
 #
 # Get language arguments
 #
@@ -45,43 +55,33 @@ OLDWD=`pwd`
 [[ -f "Configuration.h" ]] || { echo -n "cd to the 'Marlin' folder to run " ; basename $0 ; exit 1; }
 
 #
-# Compile the 'genpages.exe' and 'bdf2u8g.exe' commands in-place
+# Compile the 'genpages' command in-place
 #
-if [[ ! -x "${DN_EXEC}/genpages/genpages.exe" ]]; then
-  echo "Building genpages.exe..."
-  ( cd ${DN_EXEC}/genpages ; cc -o genpages.exe genpages.c getline.c )
-  [[ -x "${DN_EXEC}/genpages/genpages.exe" ]] || { echo "Build of genpages.exe failed" ; exit 1 ; }
-fi
-
-if [[ ! -x "${DN_EXEC}/bdf2u8g/bdf2u8g.exe" ]]; then
-  echo "Building bdf2u8g.exe..."
-  ( cd ${DN_EXEC}/bdf2u8g ; make )
-  [[ -x "${DN_EXEC}/bdf2u8g/bdf2u8g.exe" ]] || { echo "Build of bdf2u8g.exe failed" ; exit 1 ; }
-fi
+(cd ${DN_EXEC}; cc -o genpages genpages.c getline.c)
 
 #
 # By default loop through all languages
 #
-LANGS_DEFAULT="an bg ca cz da de el el_CY en es eu fi fr fr_na gl hr hu it jp_kana ko_KR nl pl pt pt_br ro ru sk sv tr uk vi zh_CN zh_TW test"
+LANGS_DEFAULT="an bg ca cz da de el el_CY en es eu fi fr gl hr hu it jp_kana ko_KR nl pl pt pt_br ro ru sk sv tr uk vi zh_CN zh_TW test"
 
 #
 # Generate data for language list MARLIN_LANGS or all if not provided
 #
-for ALANG in ${LANG_ARG:=$LANGS_DEFAULT} ; do
-  echo "Generating Marlin language data for '${ALANG}'" >&2
-  case "$ALANG" in
+for LANG in ${LANG_ARG:=$LANGS_DEFAULT} ; do
+  echo "Generating Marlin language data for '${LANG}'" >&2
+  case "$LANG" in
      zh_* ) FONTFILE="wenquanyi_12pt" ;;
      ko_* ) FONTFILE="${DN_EXEC}/NanumGothic.bdf" ;;
         * ) FONTFILE="${DN_EXEC}/marlin-6x12-3.bdf" ;;
   esac
-  DN_WORK=$(mktemp -d)
+  DN_WORK=`mktemp -d`
   cp Configuration.h ${DN_WORK}/
-  cp src/lcd/language/language_${ALANG}.h ${DN_WORK}/
+  cp src/lcd/language/language_${LANG}.h ${DN_WORK}/
   cd "${DN_WORK}"
-  ${DN_EXEC}/uxggenpages.sh "${FONTFILE}" $ALANG
+  ${EXEC_WXGGEN} "${FONTFILE}"
   sed -i fontutf8-data.h -e 's|fonts//|fonts/|g' -e 's|fonts//|fonts/|g' -e 's|[/0-9a-zA-Z_\-]*buildroot/share/fonts|buildroot/share/fonts|' 2>/dev/null
   cd - >/dev/null
-  mv ${DN_WORK}/fontutf8-data.h src/lcd/dogm/fontdata/langdata_${ALANG}.h
+  mv ${DN_WORK}/fontutf8-data.h src/lcd/dogm/fontdata/langdata_${LANG}.h
   rm -rf ${DN_WORK}
 done
 
@@ -89,10 +89,9 @@ done
 # Generate default ASCII font (char range 0-255):
 #   Marlin/src/lcd/dogm/fontdata/fontdata_ISO10646_1.h
 #
-EXEC_BDF2U8G="${DN_EXEC}/bdf2u8g/bdf2u8g.exe"
 #if [ "${MARLIN_LANGS}" == "${LANGS_DEFAULT}" ]; then
 if [ 1 = 1 ]; then
-  DN_WORK=$(mktemp -d)
+  DN_WORK=`mktemp -d`
   cd ${DN_WORK}
   ${EXEC_BDF2U8G} -b 1 -e 127 ${FN_FONT} ISO10646_1_5x7 tmp1.h >/dev/null
   ${EXEC_BDF2U8G} -b 1 -e 255 ${FN_FONT} ISO10646_1_5x7 tmp2.h >/dev/null
@@ -104,7 +103,7 @@ if [ 1 = 1 ]; then
   cat <<EOF >src/lcd/dogm/fontdata/fontdata_ISO10646_1.h
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2023 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
@@ -140,4 +139,6 @@ EOF
 
 fi
 
+(cd ${DN_EXEC}; rm genpages)
+
 cd "$OLDWD"
diff --git a/buildroot/share/fonts/genpages/genpages.c b/buildroot/share/fonts/genpages.c
similarity index 99%
rename from buildroot/share/fonts/genpages/genpages.c
rename to buildroot/share/fonts/genpages.c
index dea5b05c5c..8009e553fa 100644
--- a/buildroot/share/fonts/genpages/genpages.c
+++ b/buildroot/share/fonts/genpages.c
@@ -66,7 +66,7 @@ wchar_t get_val_utf82uni(uint8_t *pstart) {
  */
 uint8_t* get_utf8_value(uint8_t *pstart, wchar_t *pval) {
   uint32_t val = 0;
-  uint8_t *p = pstart;
+  const uint8_t *p = pstart;
   /*size_t maxlen = strlen(pstart);*/
 
   assert(NULL != pstart);
diff --git a/buildroot/share/fonts/get-bdf2u8g.sh b/buildroot/share/fonts/get-bdf2u8g.sh
new file mode 100755
index 0000000000..5851bf93e3
--- /dev/null
+++ b/buildroot/share/fonts/get-bdf2u8g.sh
@@ -0,0 +1,35 @@
+#!/usr/bin/env bash
+
+#####################################################################
+# get-bdf2u8g.sh for Marlin
+#
+# This script downloads, patches, and builds bdf2u8g
+# License: CC-SA
+#
+# Execute from within buildroot/share/fonts
+#
+#####################################################################
+
+HERE=$(pwd)
+
+for CMD in curl unzip patch make; do
+  which $CMD >/dev/null || { echo "'$CMD' is required for this script." ; exit 1 ; }
+done
+
+[[ $HERE =~ 'buildroot/share/fonts'$ ]] || { echo "Change to buildroot/share/fonts to run $(basename $0)" ; exit 1; }
+
+# Download u8glib
+curl -LJO https://github.com/olikraus/u8glib/archive/master.zip
+unzip u8glib-master.zip >/dev/null 2>&1
+
+# Patch and build bdf2u8g
+cd u8glib-master/tools/font/bdf2u8g
+patch -p0 <../../../../u8glib-bdf2u8g.patch bdf2u8g.c >/dev/null 2>&1
+make >/dev/null 2>&1
+mv bdf2u8g ../../../../
+
+# Clean up
+cd -
+rm -rf u8glib-master*
+
+cd "$HERE"
diff --git a/buildroot/share/fonts/genpages/getline.c b/buildroot/share/fonts/getline.c
similarity index 100%
rename from buildroot/share/fonts/genpages/getline.c
rename to buildroot/share/fonts/getline.c
diff --git a/buildroot/share/fonts/genpages/getline.h b/buildroot/share/fonts/getline.h
similarity index 100%
rename from buildroot/share/fonts/genpages/getline.h
rename to buildroot/share/fonts/getline.h
diff --git a/buildroot/share/fonts/make_lang_na.sh b/buildroot/share/fonts/make_lang_na.sh
deleted file mode 100755
index d7453e2820..0000000000
--- a/buildroot/share/fonts/make_lang_na.sh
+++ /dev/null
@@ -1,39 +0,0 @@
-#!/usr/bin/env bash
-#
-# make_lang_na.sh
-#
-# Create non-accented language files given a list of accented language files.
-#
-
-which gsed >/dev/null || { echo "gsed is required for this script." ; exit 1 ; }
-which perl >/dev/null || { echo "perl is required for this script." ; exit 1 ; }
-
-#
-# Get language arguments
-#
-[ $# ] || { echo "One or more language codes (such as 'fr') must be supplied." ; exit 1 ; }
-
-LANG_ARG="$@"
-
-#
-# Change to working directory 'Marlin'
-#
-OLDWD=`pwd`
-[[ $(basename "$OLDWD") != 'Marlin' && -d "Marlin" ]] && cd Marlin
-[[ -f "Configuration.h" ]] || { echo -n "cd to the 'Marlin' folder to run " ; basename $0 ; exit 1; }
-
-#
-# Generate a non-accented language file
-#
-for ALANG in $LANG_ARG ; do
-  echo "Generating a non-accented language for '${ALANG}'" >&2
-  OUTFILE=src/lcd/language/language_${ALANG}_na.h
-  cp src/lcd/language/language_${ALANG}.h $OUTFILE
-  perl -pi -e 's/\s*#define DISPLAY_CHARSET_.+\n*//g' $OUTFILE
-  perl -pi -e 's/\s*constexpr .+ CHARSIZE.+\n*//g' $OUTFILE
-  perl -pi -e "s/namespace Language_${ALANG}/#define DISPLAY_CHARSET_ISO10646_1\n#define NOT_EXTENDED_ISO10646_1_5X7\n\nnamespace Language_${ALANG}_na/" $OUTFILE
-  gsed -i 'y/ÄÃ¡ÇŽÃ Ã¢Ã¤Ä“Ã©Ä›Ã¨ÃªÄ«Ã­ÇÃ¬Ã¯Ã®ÅÃ³Ç’Ã²Ã¶Ã´Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼Ã»Ä€ÃÇÃ€Ä’Ã‰ÄšÃˆÃŠÄªÃÇÃŒÃŽÅŒÃ“Ç‘Ã’Ã”ÅªÃšÇ“Ã™Ç•Ç—Ç™Ç›ÃœÃ›Ã‡Ã§Ã‘Ã±/aaaaaaeeeeeiiiiiioooooouuuuuuuuuuAAAAEEEEEIIIIIOOOOOUUUUUUUUUUCcNn/' $OUTFILE
-  perl -pi -e 's/ÃŸ/ss/g' $OUTFILE
-done
-
-cd "$OLDWD"
diff --git a/buildroot/share/fonts/u8glib-bdf2u8g.patch b/buildroot/share/fonts/u8glib-bdf2u8g.patch
new file mode 100644
index 0000000000..1201e99800
--- /dev/null
+++ b/buildroot/share/fonts/u8glib-bdf2u8g.patch
@@ -0,0 +1,32 @@
+178c178
+<     fprintf(out_fp, "%d", data_buf[i]);
+---
+>     fprintf(out_fp, "0x%02x", data_buf[i]);
+180c180
+<     fprintf(out_fp, "%3d", data_buf[i]);
+---
+>     fprintf(out_fp, "0x%02x", data_buf[i]);
+487c487,488
+< int bdf_delta_x;           /* DWIDTH arg 1 */
+---
+> int bdf_delta_x_default = -1;
+> int bdf_delta_x = -1;           /* DWIDTH arg 1 */
+1097a1099,1114
+>     else if ( strcmp(p_buf, "CHARS") == 0 )
+>     {
+>         if (bdf_delta_x < 0) {
+>             bdf_delta_x = 0;
+>         }
+>         if (bdf_delta_x_default < 0) {
+>             bdf_delta_x_default = bdf_delta_x;
+>         }
+>     }
+>     else if ( strcmp(p_buf, "STARTCHAR") == 0 )
+>     {
+>         if (bdf_delta_x_default < 0) {
+>             bdf_delta_x_default = 0;
+>         }
+>         bdf_delta_x = bdf_delta_x_default;
+>     }
+1293d1309
+<   fprintf(out_fp, "#include \"u8g.h\"\n");  
diff --git a/buildroot/share/fonts/uxggenpages.sh b/buildroot/share/fonts/uxggenpages.sh
index 2d39297b8f..047d3ae661 100755
--- a/buildroot/share/fonts/uxggenpages.sh
+++ b/buildroot/share/fonts/uxggenpages.sh
@@ -1,12 +1,12 @@
 #!/usr/bin/env bash
 
 #####################################################################
-# uxggenpages.sh for u8g
+# genpages.sh for u8g
 #
 # This script will generate u8g c files for specified fonts
 #
 # Copyright 2015-2018 Yunhui Fu <yhfudev@gmail.com>
-# License: BSD
+# License: GPL/BSD
 #####################################################################
 
 my_getpath() {
@@ -31,11 +31,16 @@ DN_EXEC=$(dirname $(my_getpath "$0") )
 
 #####################################################################
 
-EXEC_GENPAGES=${DN_EXEC}/genpages/genpages.exe
+EXEC_GENPAGES=${DN_EXEC}/genpages
+[ -x "${EXEC_GENPAGES}" ] || EXEC_GENPAGES="$(my_getpath ${DN_EXEC}/../../../genpages)"
+[ -x "${EXEC_GENPAGES}" ] || EXEC_GENPAGES=$(which genpages)
 [ -x "${EXEC_GENPAGES}" ] || { echo "Error: genpages not found!" ; exit 1; }
+#echo "EXEC_GENPAGES=${EXEC_GENPAGES}"
 
-EXEC_BDF2U8G=${DN_EXEC}/bdf2u8g/bdf2u8g.exe
-[ -x "${EXEC_BDF2U8G}" ] || { echo "Error: bdf2u8g not found!" ; exit 1; }
+EXEC_BDF2U8G=${DN_EXEC}/bdf2u8g
+[ -x "${EXEC_BDF2U8G}" ] || EXEC_BDF2U8G="${DN_EXEC}/../../../bdf2u8g"
+[ -x "${EXEC_BDF2U8G}" ] || EXEC_BDF2U8G=$(which bdf2u8g)
+[ -x "${EXEC_BDF2U8G}" ] || { echo "Error: bdf2u8g not found!" ; echo "Please compile u8glib/tools/font/bdf2u8g/bdf2u8g and link to it from here!"; exit 1; }
 
 DN_CUR=$(pwd)
 DN_DATA=$(pwd)/datatmp
@@ -51,7 +56,6 @@ FN_FONT_BASE="marlin-6x12-3"
 #FN_FONT_BASE=wenquanyi_9pt
 
 FN_FONT="${1:-}"
-LANG="$2"
 DN_FONT0=`dirname ${FN_FONT}`
 DN_FONT="$(my_getpath  ${DN_FONT0})"
 FN_FONT="$(my_getpath "${DN_FONT}")/"`basename ${FN_FONT}`
@@ -147,14 +151,14 @@ grep -Hrn _UxGT . | grep '"' \
       ${EXEC_BDF2U8G} -u ${PAGE} -b ${BEGIN} -e ${END} ${FN_FONT} fontpage_${PAGE}_${BEGIN}_${END} ${DN_DATA}/fontpage_${PAGE}_${BEGIN}_${END}.h > /dev/null 2>&1 ;
     fi ; \
     grep -A 10000000000 u8g_fntpgm_uint8_t ${DN_DATA}/fontpage_${PAGE}_${BEGIN}_${END}.h >> tmpa ; \
-    echo "  FONTDATA_ITEM(${PAGE}, ${BEGIN}, ${END}, fontpage_${PAGE}_${BEGIN}_${END}), // '${UTF8BEGIN}' -- '${UTF8END}'" >> tmpb ;\
+    echo "    FONTDATA_ITEM(${PAGE}, ${BEGIN}, ${END}, fontpage_${PAGE}_${BEGIN}_${END}), // '${UTF8BEGIN}' -- '${UTF8END}'" >> tmpb ;\
   done
 
 TMPA=$(cat tmpa)
 TMPB=$(cat tmpb)
 
 EOL=$'\n'
-[[ ! "$TMPA" == "" ]] && TMPA="$TMPA$EOL$EOL"
+[[ ! "$TMPA" == "" ]] && TMPA="$EOL$TMPA$EOL"
 [[ ! "$TMPB" == "" ]] && TMPB="$EOL$TMPB$EOL"
 
 rm -f tmpa tmpb "proc.awk"
@@ -165,9 +169,8 @@ cat <<EOF >fontutf8-data.h
  * Contents will be REPLACED by future processing!
  * Use genallfont.sh to generate font data for updated languages.
  */
-#pragma once
-
-#include "langdata.h"
-
-${TMPA}static const uxg_fontinfo_t g_fontinfo_${LANG}[] PROGMEM = {${TMPB}};
+#include <U8glib-HAL.h>
+$TMPA
+#define FONTDATA_ITEM(page, begin, end, data) { page, begin, end, COUNT(data), data }
+static const uxg_fontinfo_t g_fontinfo[] PROGMEM = {$TMPB};
 EOF
diff --git a/buildroot/share/sublime/MarlinFirmware.sublime-project b/buildroot/share/sublime/MarlinFirmware.sublime-project
index 11808dd45d..e0cf953fa8 100644
--- a/buildroot/share/sublime/MarlinFirmware.sublime-project
+++ b/buildroot/share/sublime/MarlinFirmware.sublime-project
@@ -11,7 +11,7 @@
 				".vscode"
 			],
 			"binary_file_patterns":
-			[ "*.psd", "*.png", "*.jpg", "*.jpeg", "*.bdf", "*.patch", "avrdude_5.*", "*.svg", "*.bin", "*.woff", "*.otf" ],
+			[ "*.psd", "*.png", "*.jpg", "*.jpeg", "*.bdf", "*.patch", "avrdude_5.*", "*.svg", "*.bin", "*.woff" ],
 			"file_exclude_patterns":
 			[
 				"Marlin/platformio.ini",
diff --git a/ini/features.ini b/ini/features.ini
index c9c7528658..66b0ecb267 100644
--- a/ini/features.ini
+++ b/ini/features.ini
@@ -239,6 +239,12 @@ IS_SCARA                               = src_filter=+<src/module/scara.cpp>
 HAS_SERVOS                             = src_filter=+<src/module/servo.cpp> +<src/gcode/control/M280.cpp>
 MORGAN_SCARA                           = src_filter=+<src/gcode/scara>
 HAS_MICROSTEPS                         = src_filter=+<src/gcode/control/M350_M351.cpp>
+#TG 3/9/23 added sources
+PIDSPINDLE_USE_PIDTEMPBED              = src_filter=+<src/gcode/config/M304.cpp>
+USE_RPM_SENSOR                         = src_filter=+<src/module/rpmSensor/rpmTimer.cpp>
+TG_I2C_SUPPORT                         = src_filter=+<src/gcode/config/M7979.cpp> +<src/module/TG_I2C/TG_I2CSlave.cpp> +<C:\Users\tony\.platformio\packages\framework-arduino-lpc176x\system\CMSIS\driver>
+VFD_CONTROLLER                         = src_filter=+<src/module/vfd.cpp> +<src/gcode/config/M7979.cpp>
+#TG end added sources
 (ESP3D_)?WIFISUPPORT                   = AsyncTCP, ESP Async WebServer
                                          ESP3DLib=https://github.com/luc-github/ESP3DLib/archive/master.zip
                                          arduinoWebSockets=links2004/WebSockets@2.3.4
diff --git a/ini/lpc1769_sgen.ini b/ini/lpc1769_sgen.ini
new file mode 100644
index 0000000000..1c105ebaac
--- /dev/null
+++ b/ini/lpc1769_sgen.ini
@@ -0,0 +1,127 @@
+[common_LPC]
+platform = https://github.com/p3p/pio-nxplpc-arduino-lpc176x/archive/0.1.3.zip
+platform_packages = p3p/framework-arduino-lpc176x@^0.2.9
+lib_ldf_mode = off
+lib_compat_mode = strict
+extra_scripts = ${common.extra_scripts}
+              Marlin/src/HAL/LPC1768/upload_extra_script.py
+src_filter = ${common.default_src_filter} +<src/HAL/LPC1768> +<src/HAL/shared/backtrace>
+lib_deps = ${common.lib_deps}
+	Servo
+custom_marlin.USES_LIQUIDCRYSTAL = arduino-libraries/LiquidCrystal@~1.0.7
+custom_marlin.NEOPIXEL_LED = Adafruit NeoPixel=https://github.com/p3p/Adafruit_NeoPixel/archive/1.5.0.zip
+build_flags = ${common.build_flags} -DU8G_HAL_LINKS -IMarlin/src/HAL/LPC1768/include -IMarlin/src/HAL/LPC1768/u8g
+	-Wno-int-in-bool-context -Wno-unused-variable -Wno-unknown-pragmas
+
+[env:LPC1768]
+platform = ${common_LPC.platform}
+extends = common_LPC
+board = nxp_lpc1768
+lib_deps = marlinfirmware/U8glib-HAL@^0.5.0
+
+[env:LPC1769]
+platform = ${common_LPC.platform}
+extends  = common_LPC
+board    = nxp_lpc1769
+lib_deps = marlinfirmware/U8glib-HAL@^0.5.0
+
+[env:LPC1769_RELEASE]
+build_type = release
+platform = ${common_LPC.platform}
+extends  = env:LPC1769 ; needed to prevent "Error: Build environment 'LPC1769 RELEASE' is incompatible with BOARD_MKS_SGEN. Use one of these: LPC1769"
+board    = nxp_lpc1769
+build_flags = ${common_LPC.build_flags} -g -ggdb -O1 ; any optimize levels -O1,-O2,-O3,-Os may cause Marlin Mode failure on TFT35
+;build_flags =  ${common_LPC.build_flags}  -g -Wa,-L,-adhlns=asm.s   ;-save-temps    ;   -Wa,-adhlns=$(<:%%.c=$(OBJDIR)/%%.lst)
+;build_flags =  ${common_LPC.build_flags}  -g -S
+
+extra_scripts = ${common_LPC.extra_scripts}
+  TGExtra\MY_LPC17xx_helper.py            ; calcs LPC checksum and writes it to 0x0000001c in binary file
+  ;TGExtra\dump_env.py
+;Add upload related commands
+upload_protocol= custom  ; for LPC17xx use custom, cmsis-dap inserts an extra "-t, lpc1768" to upload_flags, causing errors
+
+;strange, the arguments to command below must all be on the same line, unlike the debug_server =, (or put args in upload_flags)
+upload_command = $PROJECT_PACKAGES_DIR\tool-openocd\bin\openocd
+upload_flags =
+  -c
+  set FIRMWARENAME {$PROJECT_DIR\$SOURCE}   ; for upload, $SOURCE seems to be available as output filename
+  -c
+  set CALLER UPLOAD                       ; so that all cfg files know who called them
+  -c 
+  set LOADADDRESS 0x00000000              ; MAKE SURE TO SET THIS CORRECTLY!!!!!  For now LPC parts must start at zero!
+  -c
+  set PROGRAMMER STLINK                   ; tell MY_LPC1769.cfg whether to use STLink or MCULink interface
+  -c
+  set PROG_DEVICE  STLINK_COPPER          ; tell MY_LPC1769.cfg which device (STLINK_DISCO, STLINK_BLACK, STLINK_COPPER) 
+  -f 
+  $PROJECT_PACKAGES_DIR\tool-openocd\scripts\board\MY_LPC1769.cfg
+lib_deps = marlinfirmware/U8glib-HAL@^0.5.0  ; needed by Marlin 2.0.8 release
+
+
+[env:LPC1769_DEBUG]
+extends = env:LPC1769_RELEASE   ; so this inherits the upload_protocol, upload_command, upload_flags too!
+platform_packages = platformio/tool-openocd@^2.1100.211028 
+					p3p/framework-arduino-lpc176x@^0.2.9
+
+build_type = debug
+build_flags = ${common_LPC.build_flags} -g3 -O1 -ggdb -DDEBUG -DVECT_TAB_FLASH=0x00000000  
+debug_tool = custom
+debug_server = $PLATFORMIO_CORE_DIR/packages/tool-openocd/bin/openocd
+     -c 
+     gdb_port 3334
+     -c 
+     tcl_port disabled
+     -c 
+     telnet_port disabled
+     -c
+     set CALLER DEBUG                     ; so that all cfg files know who called them
+     -c         
+     set LOADADDRESS 0x00000000           ; MAKE SURE TO SET THIS CORRECTLY!!!!!
+     -c       
+     set FIRMWARENAME {$PROG_PATH}        ; for debug, use $PROG_PATH ($SOURCE is not available) for output filename
+     -c
+     set PROGRAMMER STLINK                ; tell MY_LPC1769.cfg whether to use STLink or MCULink interface
+     -c
+     set PROG_DEVICE  STLINK_COPPER       ; tell MY_LPC1769.cfg which device (STLINK_DISCO, STLINK_BLACK, STLINK_COPPER) 
+     -f                                   ; it outputs .elf, but the MY_LPC1769.cfg will rename it to .bin
+     $PLATFORMIO_CORE_DIR/packages\tool-openocd\scripts\board\MY_LPC1769.cfg
+;Add debug related commands
+debug_build_flags = -g3 -O0 -ggdb3 -DDEBUG
+debug_load_mode = modified
+debug_port = localhost:3334               ; where GDB connects to OpenOCD
+debug_load_cmds = load
+debug_init_break = ;tbreak loop  ;main    ; leave empty to not stop on main(), or set a function name or line to break at
+debug_init_cmds =
+	;mon gdb_memory_map enable
+	define pio_reset_halt_target
+	  monitor reset
+	  monitor halt
+	end
+	define pio_reset_run_target
+	  monitor reset
+	end
+	define pio_restart_target
+	  pio_reset_halt_target
+	end
+	target remote $DEBUG_PORT
+	
+    ;mon set non-stop on
+    ;define hook-stop
+    ;echo "hook-stop"
+    ;mon cortex_m maskisr on
+    ;end
+    ;define hook-continue
+    ;echo "hook-continue" 
+    ;mon cortex_m maskisr off 
+    ;end 
+	monitor init                            ; GDB monitor commands to send to OpenOCD
+	monitor reset init                      ; sets MEMMAP (0x400FC040) to 0x1 for User Flash mapped to address 0x00000000
+	set mem inaccessible-by-default off     ; GDB commands
+	monitor mdw 0x400FC040                  ; look to see if User Reset (1) and not Bootloader (0)
+	$INIT_BREAK                             ; GDB commands this sends whatever is in (debug_init_break = )
+	$LOAD_CMDS                              ; GDB commands this sends whatever is in (debug_load_cmds = )
+debug_extra_cmds =
+	set remotetimeout 15000                 ; GDB command to extend timeout from target 15000 seconds
+	show remotetimeout
+lib_deps = marlinfirmware/U8glib-HAL@^0.5.0 ; needed by Marlin 2.0.8 release
+
diff --git a/platformio.ini b/platformio.ini
index 991c17b2ff..ee0589e573 100644
--- a/platformio.ini
+++ b/platformio.ini
@@ -13,29 +13,30 @@
 [platformio]
 src_dir      = Marlin
 boards_dir   = buildroot/share/PlatformIO/boards
-default_envs = mega2560
+default_envs = LPC1769_DEBUG
 include_dir  = Marlin
+    
 extra_configs =
     Marlin/config.ini
-    ini/avr.ini
-    ini/due.ini
-    ini/esp32.ini
-    ini/features.ini
-    ini/lpc176x.ini
-    ini/native.ini
-    ini/samd21.ini
-    ini/samd51.ini
-    ini/stm32-common.ini
-    ini/stm32f0.ini
-    ini/stm32f1-maple.ini
-    ini/stm32f1.ini
-    ini/stm32f4.ini
-    ini/stm32f7.ini
-    ini/stm32h7.ini
-    ini/stm32g0.ini
-    ini/teensy.ini
+    ini/features.ini        ; contains all the features to include, used to be in platformio.ini in earlier versions
+    ini/lpc1769_sgen.ini    ; contains env's for LPC1769, debug and release, used to be in platformio.ini in earlier versions
+    #ini/avr.ini
+    #ini/due.ini
+    #ini/esp32.ini
+    #ini/features.ini
+    #ini/lpc176x.ini
+    #ini/native.ini
+    #ini/samd51.ini
+    #ini/stm32-common.ini
+    #ini/stm32f0.ini
+    #ini/stm32f1-maple.ini
+    #ini/stm32f1.ini
+    #ini/stm32f4.ini
+    #ini/stm32f7.ini
+    #ini/stm32h7.ini
+    #ini/stm32g0.ini
+    #ini/teensy.ini
     ini/renamed.ini
-
 #
 # The 'common' section applies to most Marlin builds.
 #
@@ -43,14 +44,18 @@ extra_configs =
 # Remove '-fmax-errors=5' from build_flags below to see all.
 #
 [common]
-build_flags        = -g3 -D__MARLIN_FIRMWARE__ -DNDEBUG
+build_flags        = -g -D__MARLIN_FIRMWARE__ -DNDEBUG -fmerge-constants
                      -fmax-errors=5
+                     -DSRC_FILE_NAME='"${SRCFOLDER}"'          #TG added 2/12/23 to supply source folder name to CPP
 extra_scripts      =
   pre:buildroot/share/PlatformIO/scripts/configuration.py
   pre:buildroot/share/PlatformIO/scripts/common-dependencies.py
   pre:buildroot/share/PlatformIO/scripts/common-cxxflags.py
   pre:buildroot/share/PlatformIO/scripts/preflight-checks.py
   post:buildroot/share/PlatformIO/scripts/common-dependencies-post.py
+  pre:TGExtra/set_folder_name.py                #TG added 2/12/23 to obtain source folder name in newly
+                                                # added .env variable $SRCFOLDER (see above ${common.build_flags})
+
 lib_deps           =
 default_src_filter = +<src/*> -<src/config> -<src/HAL> +<src/HAL/shared> -<src/tests>
   -<src/lcd/HD44780> -<src/lcd/TFTGLCD> -<src/lcd/dogm> -<src/lcd/tft> -<src/lcd/tft_io>
@@ -187,6 +192,7 @@ default_src_filter = +<src/*> -<src/config> -<src/HAL> +<src/HAL/shared> -<src/t
   -<src/gcode/config/M540.cpp>
   -<src/gcode/config/M575.cpp>
   -<src/gcode/config/M672.cpp>
+  -<src/gcode/config/M7979.cpp>
   -<src/gcode/control/M7-M9.cpp>
   -<src/gcode/control/M211.cpp>
   -<src/gcode/control/M350_M351.cpp>
@@ -264,7 +270,8 @@ default_src_filter = +<src/*> -<src/config> -<src/HAL> +<src/HAL/shared> -<src/t
   -<src/module/scara.cpp>
   -<src/module/servo.cpp> -<src/gcode/control/M280.cpp> -<src/gcode/config/M281.cpp> -<src/gcode/control/M282.cpp>
   -<src/module/stepper/TMC26X.cpp>
-
+  -<src/module/rpmSensor/rpmTimer.cpp>
+  
 #
 # Default values apply to all 'env:' prefixed environments
 #
@@ -282,7 +289,8 @@ monitor_filters   = colorize, time, send_on_enter
 # Just print the dependency tree
 #
 [env:include_tree]
-platform         = atmelavr
-board            = megaatmega2560
-build_flags      = -c -H -std=gnu++11 -Wall -Os -D__MARLIN_FIRMWARE__
-build_src_filter = +<src/MarlinCore.cpp>
+extends     = env:LPC1769
+;platform    = atmelavr
+;board       = megaatmega2560
+build_flags = -c -H -std=gnu++11 -Wall -Os -D__MARLIN_FIRMWARE__
+build_src_filter  = +<src/MarlinCore.cpp>
diff --git a/removed/abl.cpp b/removed/abl.cpp
new file mode 100644
index 0000000000..ece7481981
--- /dev/null
+++ b/removed/abl.cpp
@@ -0,0 +1,421 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+#include "../bedlevel.h"
+
+#include "../../../module/motion.h"
+
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../../core/debug_out.h"
+
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../../../lcd/extui/ui_api.h"
+#endif
+
+xy_pos_t bilinear_grid_spacing, bilinear_start;
+xy_float_t bilinear_grid_factor;
+bed_mesh_t z_values;
+
+/**
+ * Extrapolate a single point from its neighbors
+ */
+static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
+  if (!isnan(z_values[x][y])) return;
+  if (DEBUGGING(LEVELING)) {
+    DEBUG_ECHOPGM("Extrapolate [");
+    if (x < 10) DEBUG_CHAR(' ');
+    DEBUG_ECHO(x);
+    DEBUG_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
+    DEBUG_CHAR(' ');
+    if (y < 10) DEBUG_CHAR(' ');
+    DEBUG_ECHO(y);
+    DEBUG_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
+    DEBUG_ECHOLNPGM("]");
+  }
+
+  // Get X neighbors, Y neighbors, and XY neighbors
+  const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
+  float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
+        b1 = z_values[x ][y1], b2 = z_values[x ][y2],
+        c1 = z_values[x1][y1], c2 = z_values[x2][y2];
+
+  // Treat far unprobed points as zero, near as equal to far
+  if (isnan(a2)) a2 = 0.0;
+  if (isnan(a1)) a1 = a2;
+  if (isnan(b2)) b2 = 0.0;
+  if (isnan(b1)) b1 = b2;
+  if (isnan(c2)) c2 = 0.0;
+  if (isnan(c1)) c1 = c2;
+
+  const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
+
+  // Take the average instead of the median
+  z_values[x][y] = (a + b + c) / 3.0;
+  TERN_(EXTENSIBLE_UI, ExtUI::onMeshUpdate(x, y, z_values[x][y]));
+
+  // Median is robust (ignores outliers).
+  // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
+  //                                : ((c < b) ? b : (a < c) ? a : c);
+}
+
+//Enable this if your SCARA uses 180Â° of total area
+//#define EXTRAPOLATE_FROM_EDGE
+
+#if ENABLED(EXTRAPOLATE_FROM_EDGE)
+  #if (GRID_MAX_POINTS_X) < (GRID_MAX_POINTS_Y)
+    #define HALF_IN_X
+  #elif (GRID_MAX_POINTS_Y) < (GRID_MAX_POINTS_X)
+    #define HALF_IN_Y
+  #endif
+#endif
+
+/**
+ * Fill in the unprobed points (corners of circular print surface)
+ * using linear extrapolation, away from the center.
+ */
+void extrapolate_unprobed_bed_level() {
+  #ifdef HALF_IN_X
+    constexpr uint8_t ctrx2 = 0, xend = GRID_MAX_POINTS_X - 1;
+  #else
+    constexpr uint8_t ctrx1 = (GRID_MAX_CELLS_X) / 2, // left-of-center
+                      ctrx2 = (GRID_MAX_POINTS_X) / 2,  // right-of-center
+                      xend = ctrx1;
+  #endif
+
+  #ifdef HALF_IN_Y
+    constexpr uint8_t ctry2 = 0, yend = GRID_MAX_POINTS_Y - 1;
+  #else
+    constexpr uint8_t ctry1 = (GRID_MAX_CELLS_Y) / 2, // top-of-center
+                      ctry2 = (GRID_MAX_POINTS_Y) / 2,  // bottom-of-center
+                      yend = ctry1;
+  #endif
+
+  LOOP_LE_N(xo, xend)
+    LOOP_LE_N(yo, yend) {
+      uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
+      #ifndef HALF_IN_X
+        const uint8_t x1 = ctrx1 - xo;
+      #endif
+      #ifndef HALF_IN_Y
+        const uint8_t y1 = ctry1 - yo;
+        #ifndef HALF_IN_X
+          extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
+        #endif
+        extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
+      #endif
+      #ifndef HALF_IN_X
+        extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
+      #endif
+      extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
+    }
+
+}
+
+void print_bilinear_leveling_grid() {
+  SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
+  print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
+    [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
+  );
+}
+
+#if ENABLED(ABL_BILINEAR_SUBDIVISION)
+
+  #define ABL_GRID_POINTS_VIRT_X GRID_MAX_CELLS_X * (BILINEAR_SUBDIVISIONS) + 1
+  #define ABL_GRID_POINTS_VIRT_Y GRID_MAX_CELLS_Y * (BILINEAR_SUBDIVISIONS) + 1
+  #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
+  #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
+  float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
+  xy_pos_t bilinear_grid_spacing_virt;
+  xy_float_t bilinear_grid_factor_virt;
+
+  void print_bilinear_leveling_grid_virt() {
+    SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
+    print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
+      [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
+    );
+  }
+
+  #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
+  float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
+    uint8_t ep = 0, ip = 1;
+    if (x > (GRID_MAX_POINTS_X) + 1 || y > (GRID_MAX_POINTS_Y) + 1) {
+      // The requested point requires extrapolating two points beyond the mesh.
+      // These values are only requested for the edges of the mesh, which are always an actual mesh point,
+      // and do not require interpolation. When interpolation is not needed, this "Mesh + 2" point is
+      // cancelled out in bed_level_virt_cmr and does not impact the result. Return 0.0 rather than
+      // making this function more complex by extrapolating two points.
+      return 0.0;
+    }
+    if (!x || x == ABL_TEMP_POINTS_X - 1) {
+      if (x) {
+        ep = (GRID_MAX_POINTS_X) - 1;
+        ip = GRID_MAX_CELLS_X - 1;
+      }
+      if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
+        return LINEAR_EXTRAPOLATION(
+          z_values[ep][y - 1],
+          z_values[ip][y - 1]
+        );
+      else
+        return LINEAR_EXTRAPOLATION(
+          bed_level_virt_coord(ep + 1, y),
+          bed_level_virt_coord(ip + 1, y)
+        );
+    }
+    if (!y || y == ABL_TEMP_POINTS_Y - 1) {
+      if (y) {
+        ep = (GRID_MAX_POINTS_Y) - 1;
+        ip = GRID_MAX_CELLS_Y - 1;
+      }
+      if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
+        return LINEAR_EXTRAPOLATION(
+          z_values[x - 1][ep],
+          z_values[x - 1][ip]
+        );
+      else
+        return LINEAR_EXTRAPOLATION(
+          bed_level_virt_coord(x, ep + 1),
+          bed_level_virt_coord(x, ip + 1)
+        );
+    }
+    return z_values[x - 1][y - 1];
+  }
+
+  static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
+    return (
+        p[i-1] * -t * sq(1 - t)
+      + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
+      + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
+      - p[i+2] * sq(t) * (1 - t)
+    ) * 0.5f;
+  }
+
+  static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const_float_t tx, const_float_t ty) {
+    float row[4], column[4];
+    LOOP_L_N(i, 4) {
+      LOOP_L_N(j, 4) {
+        column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
+      }
+      row[i] = bed_level_virt_cmr(column, 1, ty);
+    }
+    return bed_level_virt_cmr(row, 1, tx);
+  }
+
+  void bed_level_virt_interpolate() {
+    bilinear_grid_spacing_virt = bilinear_grid_spacing / (BILINEAR_SUBDIVISIONS);
+    bilinear_grid_factor_virt = bilinear_grid_spacing_virt.reciprocal();
+    LOOP_L_N(y, GRID_MAX_POINTS_Y)
+      LOOP_L_N(x, GRID_MAX_POINTS_X)
+        LOOP_L_N(ty, BILINEAR_SUBDIVISIONS)
+          LOOP_L_N(tx, BILINEAR_SUBDIVISIONS) {
+            if ((ty && y == (GRID_MAX_POINTS_Y) - 1) || (tx && x == (GRID_MAX_POINTS_X) - 1))
+              continue;
+            z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
+              bed_level_virt_2cmr(
+                x + 1,
+                y + 1,
+                (float)tx / (BILINEAR_SUBDIVISIONS),
+                (float)ty / (BILINEAR_SUBDIVISIONS)
+              );
+          }
+  }
+#endif // ABL_BILINEAR_SUBDIVISION
+
+// Refresh after other values have been updated
+void refresh_bed_level() {
+  bilinear_grid_factor = bilinear_grid_spacing.reciprocal();
+  TERN_(ABL_BILINEAR_SUBDIVISION, bed_level_virt_interpolate());
+}
+
+#if ENABLED(ABL_BILINEAR_SUBDIVISION)
+  #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt.A
+  #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt.A
+  #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
+  #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
+  #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
+#else
+  #define ABL_BG_SPACING(A) bilinear_grid_spacing.A
+  #define ABL_BG_FACTOR(A)  bilinear_grid_factor.A
+  #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
+  #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
+  #define ABL_BG_GRID(X,Y)  z_values[X][Y]
+#endif
+
+// Get the Z adjustment for non-linear bed leveling
+float bilinear_z_offset(const xy_pos_t &raw) {
+
+  static float z1, d2, z3, d4, L, D;
+
+  static xy_pos_t prev { -999.999, -999.999 }, ratio;
+
+  // Whole units for the grid line indices. Constrained within bounds.
+  static xy_int8_t thisg, nextg, lastg { -99, -99 };
+
+  // XY relative to the probed area
+  xy_pos_t rel = raw - bilinear_start.asFloat();
+
+  #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
+    #define FAR_EDGE_OR_BOX 2   // Keep using the last grid box
+  #else
+    #define FAR_EDGE_OR_BOX 1   // Just use the grid far edge
+  #endif
+
+  if (prev.x != rel.x) {
+    prev.x = rel.x;
+    ratio.x = rel.x * ABL_BG_FACTOR(x);
+    const float gx = constrain(FLOOR(ratio.x), 0, ABL_BG_POINTS_X - (FAR_EDGE_OR_BOX));
+    ratio.x -= gx;      // Subtract whole to get the ratio within the grid box
+
+    #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
+      // Beyond the grid maintain height at grid edges
+      NOLESS(ratio.x, 0); // Never <0 (>1 is ok when nextg.x==thisg.x)
+    #endif
+
+    thisg.x = gx;
+    nextg.x = _MIN(thisg.x + 1, ABL_BG_POINTS_X - 1);
+  }
+
+  if (prev.y != rel.y || lastg.x != thisg.x) {
+
+    if (prev.y != rel.y) {
+      prev.y = rel.y;
+      ratio.y = rel.y * ABL_BG_FACTOR(y);
+      const float gy = constrain(FLOOR(ratio.y), 0, ABL_BG_POINTS_Y - (FAR_EDGE_OR_BOX));
+      ratio.y -= gy;
+
+      #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
+        // Beyond the grid maintain height at grid edges
+        NOLESS(ratio.y, 0); // Never < 0.0. (> 1.0 is ok when nextg.y==thisg.y.)
+      #endif
+
+      thisg.y = gy;
+      nextg.y = _MIN(thisg.y + 1, ABL_BG_POINTS_Y - 1);
+    }
+
+    if (lastg != thisg) {
+      lastg = thisg;
+      // Z at the box corners
+      z1 = ABL_BG_GRID(thisg.x, thisg.y);       // left-front
+      d2 = ABL_BG_GRID(thisg.x, nextg.y) - z1;  // left-back (delta)
+      z3 = ABL_BG_GRID(nextg.x, thisg.y);       // right-front
+      d4 = ABL_BG_GRID(nextg.x, nextg.y) - z3;  // right-back (delta)
+    }
+
+    // Bilinear interpolate. Needed since rel.y or thisg.x has changed.
+                L = z1 + d2 * ratio.y;   // Linear interp. LF -> LB
+    const float R = z3 + d4 * ratio.y;   // Linear interp. RF -> RB
+
+    D = R - L;
+  }
+
+  const float offset = L + ratio.x * D;   // the offset almost always changes
+
+  /*
+  static float last_offset = 0;
+  if (ABS(last_offset - offset) > 0.2) {
+    SERIAL_ECHOLNPGM("Sudden Shift at x=", rel.x, " / ", bilinear_grid_spacing.x, " -> thisg.x=", thisg.x);
+    SERIAL_ECHOLNPGM(" y=", rel.y, " / ", bilinear_grid_spacing.y, " -> thisg.y=", thisg.y);
+    SERIAL_ECHOLNPGM(" ratio.x=", ratio.x, " ratio.y=", ratio.y);
+    SERIAL_ECHOLNPGM(" z1=", z1, " z2=", z2, " z3=", z3, " z4=", z4);
+    SERIAL_ECHOLNPGM(" L=", L, " R=", R, " offset=", offset);
+  }
+  last_offset = offset;
+  //*/
+
+  return offset;
+}
+
+#if IS_CARTESIAN && DISABLED(SEGMENT_LEVELED_MOVES)
+
+  #define CELL_INDEX(A,V) ((V - bilinear_start.A) * ABL_BG_FACTOR(A))
+
+  /**
+   * Prepare a bilinear-leveled linear move on Cartesian,
+   * splitting the move where it crosses grid borders.
+   */
+  void bilinear_line_to_destination(const_feedRate_t scaled_fr_mm_s, uint16_t x_splits, uint16_t y_splits) {
+    // Get current and destination cells for this line
+    xy_int_t c1 { CELL_INDEX(x, current_position.x), CELL_INDEX(y, current_position.y) },
+             c2 { CELL_INDEX(x, destination.x), CELL_INDEX(y, destination.y) };
+    LIMIT(c1.x, 0, ABL_BG_POINTS_X - 2);
+    LIMIT(c1.y, 0, ABL_BG_POINTS_Y - 2);
+    LIMIT(c2.x, 0, ABL_BG_POINTS_X - 2);
+    LIMIT(c2.y, 0, ABL_BG_POINTS_Y - 2);
+
+    // Start and end in the same cell? No split needed.
+    if (c1 == c2) {
+      current_position = destination;
+      line_to_current_position(scaled_fr_mm_s);
+      return;
+    }
+
+    #define LINE_SEGMENT_END(A) (current_position.A + (destination.A - current_position.A) * normalized_dist)
+
+    float normalized_dist;
+    xyze_pos_t end;
+    const xy_int8_t gc { _MAX(c1.x, c2.x), _MAX(c1.y, c2.y) };
+
+    // Crosses on the X and not already split on this X?
+    // The x_splits flags are insurance against rounding errors.
+    if (c2.x != c1.x && TEST(x_splits, gc.x)) {
+      // Split on the X grid line
+      CBI(x_splits, gc.x);
+      end = destination;
+      destination.x = bilinear_start.x + ABL_BG_SPACING(x) * gc.x;
+      normalized_dist = (destination.x - current_position.x) / (end.x - current_position.x);
+      destination.y = LINE_SEGMENT_END(y);
+    }
+    // Crosses on the Y and not already split on this Y?
+    else if (c2.y != c1.y && TEST(y_splits, gc.y)) {
+      // Split on the Y grid line
+      CBI(y_splits, gc.y);
+      end = destination;
+      destination.y = bilinear_start.y + ABL_BG_SPACING(y) * gc.y;
+      normalized_dist = (destination.y - current_position.y) / (end.y - current_position.y);
+      destination.x = LINE_SEGMENT_END(x);
+    }
+    else {
+      // Must already have been split on these border(s)
+      // This should be a rare case.
+      current_position = destination;
+      line_to_current_position(scaled_fr_mm_s);
+      return;
+    }
+
+    destination.z = LINE_SEGMENT_END(z);
+    destination.e = LINE_SEGMENT_END(e);
+
+    // Do the split and look for more borders
+    bilinear_line_to_destination(scaled_fr_mm_s, x_splits, y_splits);
+
+    // Restore destination from stack
+    destination = end;
+    bilinear_line_to_destination(scaled_fr_mm_s, x_splits, y_splits);
+  }
+
+#endif // IS_CARTESIAN && !SEGMENT_LEVELED_MOVES
+
+#endif // AUTO_BED_LEVELING_BILINEAR
diff --git a/removed/abl.h b/removed/abl.h
new file mode 100644
index 0000000000..3d54c55695
--- /dev/null
+++ b/removed/abl.h
@@ -0,0 +1,45 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+#include "../../../inc/MarlinConfigPre.h"
+
+extern xy_pos_t bilinear_grid_spacing, bilinear_start;
+extern xy_float_t bilinear_grid_factor;
+extern bed_mesh_t z_values;
+float bilinear_z_offset(const xy_pos_t &raw);
+
+void extrapolate_unprobed_bed_level();
+void print_bilinear_leveling_grid();
+void refresh_bed_level();
+#if ENABLED(ABL_BILINEAR_SUBDIVISION)
+  void print_bilinear_leveling_grid_virt();
+  void bed_level_virt_interpolate();
+#endif
+
+#if IS_CARTESIAN && DISABLED(SEGMENT_LEVELED_MOVES)
+  void bilinear_line_to_destination(const_feedRate_t scaled_fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF);
+#endif
+
+#define _GET_MESH_X(I) float(bilinear_start.x + (I) * bilinear_grid_spacing.x)
+#define _GET_MESH_Y(J) float(bilinear_start.y + (J) * bilinear_grid_spacing.y)
+#define Z_VALUES_ARR  z_values
